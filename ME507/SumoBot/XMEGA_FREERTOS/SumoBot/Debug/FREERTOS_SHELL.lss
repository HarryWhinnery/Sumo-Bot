
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003dfe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000009a  00802000  00003dfe  00003e92  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000020aa  0080209a  0080209a  00003f2c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003f2c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003f5c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a0  00000000  00000000  00003f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011098  00000000  00000000  0000463c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006ad8  00000000  00000000  000156d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004e8f  00000000  00000000  0001c1ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012a4  00000000  00000000  0002103c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000056e0  00000000  00000000  000222e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000058bb  00000000  00000000  000279c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  0002d27b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9f 02 	jmp	0x53e	; 0x53e <__ctors_end>
       4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
       8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
       c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      10:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      14:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      18:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      1c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      20:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      24:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      28:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      2c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      30:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      34:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      38:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      3c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      40:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      44:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      48:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      4c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      50:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      54:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      58:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      5c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      60:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      64:	0c 94 27 1b 	jmp	0x364e	; 0x364e <__vector_25>
      68:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      6c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      70:	0c 94 7f 1b 	jmp	0x36fe	; 0x36fe <__vector_28>
      74:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      78:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      7c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      80:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      84:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      88:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      8c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      90:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      94:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      98:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      9c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      a0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      a4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      a8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      ac:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      b0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      b4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      b8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      bc:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      c0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      c4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      c8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      cc:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      d0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      d4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      d8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      dc:	0c 94 fd 0a 	jmp	0x15fa	; 0x15fa <__vector_55>
      e0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      e4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      e8:	0c 94 87 1c 	jmp	0x390e	; 0x390e <__vector_58>
      ec:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      f0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      f4:	0c 94 df 1c 	jmp	0x39be	; 0x39be <__vector_61>
      f8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
      fc:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     100:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     104:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     108:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     10c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     110:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     114:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     118:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     11c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     120:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     124:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     128:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     12c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     130:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     134:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     138:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     13c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     140:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     144:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     148:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     14c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     150:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     154:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     158:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     15c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     160:	0c 94 d7 1b 	jmp	0x37ae	; 0x37ae <__vector_88>
     164:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     168:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     16c:	0c 94 2f 1c 	jmp	0x385e	; 0x385e <__vector_91>
     170:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     174:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     178:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     17c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     180:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     184:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     188:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     18c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     190:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     194:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     198:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     19c:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1a0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1a4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1a8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1ac:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1b0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1b4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1b8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1bc:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1c0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1c4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1c8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1cc:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1d0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1d4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1d8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1dc:	0c 94 37 1d 	jmp	0x3a6e	; 0x3a6e <__vector_119>
     1e0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1e4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1e8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1ec:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1f0:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1f4:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1f8:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <__bad_interrupt>
     1fc:	f1 18       	sub	r15, r1
     1fe:	f4 18       	sub	r15, r4
     200:	f7 18       	sub	r15, r7
     202:	fa 18       	sub	r15, r10
     204:	fd 18       	sub	r15, r13
     206:	00 19       	sub	r16, r0
     208:	02 19       	sub	r16, r2
     20a:	13 19       	sub	r17, r3
     20c:	1b 19       	sub	r17, r11
     20e:	25 19       	sub	r18, r5
     210:	23 19       	sub	r18, r3

00000212 <__trampolines_start>:
     212:	0c 94 9c 02 	jmp	0x538	; 0x538 <_call_static_run_method>
     216:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <prvIdleTask>
     21a:	0c 94 88 04 	jmp	0x910	; 0x910 <_ZN10task_MOTOR3runEv>
     21e:	0c 94 11 04 	jmp	0x822	; 0x822 <_ZN14task_EdgeSense3runEv>
     222:	0c 94 00 19 	jmp	0x3200	; 0x3200 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     226:	0c 94 20 16 	jmp	0x2c40	; 0x2c40 <_ZN14frt_text_queue14check_for_charEv>
     22a:	0c 94 7c 1a 	jmp	0x34f8	; 0x34f8 <_ZN5rs23212clear_screenEv>
     22e:	0c 94 25 19 	jmp	0x324a	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
     232:	0c 94 f7 18 	jmp	0x31ee	; 0x31ee <_ZN8emstreamlsE15ser_manipulator+0x2a>
     236:	0c 94 f8 1d 	jmp	0x3bf0	; 0x3bf0 <_GLOBAL__sub_I_print_ser_queue>
     23a:	0c 94 69 1a 	jmp	0x34d2	; 0x34d2 <_ZN5rs23214check_for_charEv>
     23e:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <_ZN5rs2327getcharEv>
     242:	0c 94 9b 18 	jmp	0x3136	; 0x3136 <_ZN8emstream12transmit_nowEv>
     246:	0c 94 fd 18 	jmp	0x31fa	; 0x31fa <_ZN8emstreamlsE15ser_manipulator+0x36>
     24a:	0c 94 99 18 	jmp	0x3132	; 0x3132 <_ZN8emstream14check_for_charEv>
     24e:	0c 94 b8 14 	jmp	0x2970	; 0x2970 <_ZN8frt_task12print_statusER8emstream>
     252:	0c 94 f4 18 	jmp	0x31e8	; 0x31e8 <_ZN8emstreamlsE15ser_manipulator+0x24>
     256:	0c 94 13 19 	jmp	0x3226	; 0x3226 <_ZN8emstreamlsE15ser_manipulator+0x62>
     25a:	0c 94 1b 19 	jmp	0x3236	; 0x3236 <_ZN8emstreamlsE15ser_manipulator+0x72>
     25e:	0c 94 02 19 	jmp	0x3204	; 0x3204 <_ZN8emstreamlsE15ser_manipulator+0x40>
     262:	0c 94 9c 18 	jmp	0x3138	; 0x3138 <_ZN8emstream12clear_screenEv>
     266:	0c 94 95 06 	jmp	0xd2a	; 0xd2a <_ZN9task_user3runEv>
     26a:	0c 94 fa 18 	jmp	0x31f4	; 0x31f4 <_ZN8emstreamlsE15ser_manipulator+0x30>
     26e:	0c 94 02 16 	jmp	0x2c04	; 0x2c04 <_ZN14frt_text_queue7getcharEv>
     272:	0c 94 23 19 	jmp	0x3246	; 0x3246 <_ZN8emstreamlsE15ser_manipulator+0x82>
     276:	0c 94 94 18 	jmp	0x3128	; 0x3128 <_ZN8emstream13ready_to_sendEv>
     27a:	0c 94 96 18 	jmp	0x312c	; 0x312c <_ZN8emstream7getcharEv>
     27e:	0c 94 e3 17 	jmp	0x2fc6	; 0x2fc6 <__cxa_pure_virtual>
     282:	0c 94 2b 16 	jmp	0x2c56	; 0x2c56 <_ZN14frt_text_queue7putcharEc>
     286:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <_ZN5rs2327putcharEc>
     28a:	0c 94 f1 18 	jmp	0x31e2	; 0x31e2 <_ZN8emstreamlsE15ser_manipulator+0x1e>

0000028e <__trampolines_end>:
     28e:	2c 20       	and	r2, r12
     290:	54 43       	sbci	r21, 0x34	; 52
     292:	43 30       	cpi	r20, 0x03	; 3
     294:	43 43       	sbci	r20, 0x33	; 51
     296:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000299 <_ZZN9task_user11show_statusEvE3__c_3>:
     299:	2f 00                                               /.

0000029b <_ZZN9task_user11show_statusEvE3__c_2>:
     29b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002a9 <_ZZN9task_user11show_statusEvE3__c_1>:
     2a9:	54 69 6d 65 3a 20 00                                Time: .

000002b0 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b0:	44 65 63 20 20 34 20 32 30 31 39 00                 Dec  4 2019.

000002bc <_ZZN9task_user11show_statusEvE3__c>:
     2bc:	4d 45 35 30 37 20 46 72 65 65 52 54 4f 53 20 78     ME507 FreeRTOS x
     2cc:	6d 65 67 61 20 70 6f 72 74 20 00                    mega port .

000002d7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2d7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002e6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2e6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     2f6:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000301 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     301:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     311:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000031f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     31f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     32f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     33f:	6d 61 74 69 6f 6e 00                                mation.

00000346 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     346:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     356:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000367 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     367:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     377:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000037f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     37f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     38f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000039b <_ZZN9task_user18print_help_messageEvE3__c_3>:
     39b:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3ab:	68 65 20 41 56 52 00                                he AVR.

000003b2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3b2:	20 68 65 6c 70 00                                    help.

000003b8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3b8:	4d 45 35 30 37 20 46 72 65 65 52 54 4f 53 20 78     ME507 FreeRTOS x
     3c8:	6d 65 67 61 20 70 6f 72 74 20 00                    mega port .

000003d3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3d3:	1b 5b 33 30 6d 00                                   .[30m.

000003d9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3d9:	1b 5b 34 36 6d 00                                   .[46m.

000003df <_ZZN9task_user3runEvE3__c_3>:
     3df:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ef:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

000003fc <_ZZN9task_user3runEvE3__c_2>:
     3fc:	3a 57 54 46 3f 00                                   :WTF?.

00000402 <_ZZN9task_user3runEvE3__c_1>:
     402:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     412:	65 00                                               e.

00000414 <_ZZN9task_user3runEvE3__c_0>:
     414:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000422 <_ZZN9task_user3runEvE3__c>:
     422:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     432:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000440 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     440:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000044a <_ZZN8frt_task15emergency_resetEvE3__c>:
     44a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000459 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     459:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     469:	61 73 6b 20 00                                      ask .

0000046e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     46e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000047c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     47c:	20 63 72 65 61 74 65 64 00                           created.

00000485 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     485:	54 61 73 6b 20 00                                   Task .

0000048b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     48b:	1b 5b 32 32 6d 00                                   .[22m.

00000491 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     491:	54 61 73 6b 3a 20 00                                Task: .

00000498 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     498:	1b 5b 31 6d 00                                      .[1m.

0000049d <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     49d:	1b 5b 32 32 6d 00                                   .[22m.

000004a3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4a3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004ae <_ZZ17print_task_stacksP8emstreamE3__c>:
     4ae:	1b 5b 31 6d 00                                      .[1m.

000004b3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4b3:	09 09 00                                            ...

000004b6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4b6:	2f 00                                               /.

000004b8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4b8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004c3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4c3:	09 2d 2d 2d 2d 00                                   .----.

000004c9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4c9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004d5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4d5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004e6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4e6:	09 52 75 6e 73 00                                   .Runs.

000004ec <_ZZ15print_task_listP8emstreamE3__c_2>:
     4ec:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000004f8 <_ZZ15print_task_listP8emstreamE3__c_1>:
     4f8:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000509 <_ZZ15print_task_listP8emstreamE3__c_0>:
     509:	09 53 74 61 63 6b 00                                .Stack.

00000510 <_ZZ15print_task_listP8emstreamE3__c>:
     510:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000051b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     51b:	09 00                                               ..

0000051d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     51d:	09 00                                               ..

0000051f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     51f:	2f 00                                               /.

00000521 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     521:	09 00                                               ..

00000523 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     523:	09 00                                               ..

00000525 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     525:	1b 5b 32 32 6d 00                                   .[22m.

0000052b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     52b:	1b 5b 31 6d 00                                      .[1m.

00000530 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     530:	1b 5b 31 6d 00                                      .[1m.

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     535:	20 20 00                                              .

00000538 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     538:	0e 94 50 13 	call	0x26a0	; 0x26a0 <_ZN8frt_task22_call_users_run_methodEPS_>

0000053c <__ctors_start>:
     53c:	f8 1d       	adc	r31, r8

0000053e <__ctors_end>:
     53e:	11 24       	eor	r1, r1
     540:	1f be       	out	0x3f, r1	; 63
     542:	cf ef       	ldi	r28, 0xFF	; 255
     544:	cd bf       	out	0x3d, r28	; 61
     546:	df e5       	ldi	r29, 0x5F	; 95
     548:	de bf       	out	0x3e, r29	; 62
     54a:	00 e0       	ldi	r16, 0x00	; 0
     54c:	0c bf       	out	0x3c, r16	; 60

0000054e <__do_copy_data>:
     54e:	10 e2       	ldi	r17, 0x20	; 32
     550:	a0 e0       	ldi	r26, 0x00	; 0
     552:	b0 e2       	ldi	r27, 0x20	; 32
     554:	ee ef       	ldi	r30, 0xFE	; 254
     556:	fd e3       	ldi	r31, 0x3D	; 61
     558:	00 e0       	ldi	r16, 0x00	; 0
     55a:	0b bf       	out	0x3b, r16	; 59
     55c:	02 c0       	rjmp	.+4      	; 0x562 <__do_copy_data+0x14>
     55e:	07 90       	elpm	r0, Z+
     560:	0d 92       	st	X+, r0
     562:	aa 39       	cpi	r26, 0x9A	; 154
     564:	b1 07       	cpc	r27, r17
     566:	d9 f7       	brne	.-10     	; 0x55e <__do_copy_data+0x10>

00000568 <__do_clear_bss>:
     568:	21 e4       	ldi	r18, 0x41	; 65
     56a:	aa e9       	ldi	r26, 0x9A	; 154
     56c:	b0 e2       	ldi	r27, 0x20	; 32
     56e:	01 c0       	rjmp	.+2      	; 0x572 <.do_clear_bss_start>

00000570 <.do_clear_bss_loop>:
     570:	1d 92       	st	X+, r1

00000572 <.do_clear_bss_start>:
     572:	a4 34       	cpi	r26, 0x44	; 68
     574:	b2 07       	cpc	r27, r18
     576:	e1 f7       	brne	.-8      	; 0x570 <.do_clear_bss_loop>

00000578 <__do_global_ctors>:
     578:	12 e0       	ldi	r17, 0x02	; 2
     57a:	cf e9       	ldi	r28, 0x9F	; 159
     57c:	d2 e0       	ldi	r29, 0x02	; 2
     57e:	00 e0       	ldi	r16, 0x00	; 0
     580:	06 c0       	rjmp	.+12     	; 0x58e <__do_global_ctors+0x16>
     582:	21 97       	sbiw	r28, 0x01	; 1
     584:	01 09       	sbc	r16, r1
     586:	80 2f       	mov	r24, r16
     588:	fe 01       	movw	r30, r28
     58a:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <__tablejump2__>
     58e:	ce 39       	cpi	r28, 0x9E	; 158
     590:	d1 07       	cpc	r29, r17
     592:	80 e0       	ldi	r24, 0x00	; 0
     594:	08 07       	cpc	r16, r24
     596:	a9 f7       	brne	.-22     	; 0x582 <__do_global_ctors+0xa>
     598:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <main>
     59c:	0c 94 fd 1e 	jmp	0x3dfa	; 0x3dfa <_exit>

000005a0 <__bad_interrupt>:
     5a0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005a4 <_ZN9IR_sensorC1EP11PORT_structh>:


#include "IR_sensor.h"

// default constructor
IR_sensor::IR_sensor(PORT_t* p_port, uint8_t pin):gp_port(p_port),gpin_bm(1<<pin)
     5a4:	fc 01       	movw	r30, r24
     5a6:	60 83       	st	Z, r22
     5a8:	71 83       	std	Z+1, r23	; 0x01
     5aa:	21 e0       	ldi	r18, 0x01	; 1
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	02 c0       	rjmp	.+4      	; 0x5b4 <_ZN9IR_sensorC1EP11PORT_structh+0x10>
     5b0:	22 0f       	add	r18, r18
     5b2:	33 1f       	adc	r19, r19
     5b4:	4a 95       	dec	r20
     5b6:	e2 f7       	brpl	.-8      	; 0x5b0 <_ZN9IR_sensorC1EP11PORT_structh+0xc>
     5b8:	22 83       	std	Z+2, r18	; 0x02
{
	gp_port->DIR &= ~(gpin_bm);
     5ba:	fb 01       	movw	r30, r22
     5bc:	80 81       	ld	r24, Z
     5be:	20 95       	com	r18
     5c0:	28 23       	and	r18, r24
     5c2:	20 83       	st	Z, r18
     5c4:	08 95       	ret

000005c6 <_ZN9IR_sensor4readEv>:


//Read output of IR sensor
bool IR_sensor::read(void)
{
	bool value = gp_port->IN & gpin_bm;
     5c6:	dc 01       	movw	r26, r24
     5c8:	ed 91       	ld	r30, X+
     5ca:	fc 91       	ld	r31, X
     5cc:	11 97       	sbiw	r26, 0x01	; 1
     5ce:	20 85       	ldd	r18, Z+8	; 0x08
	return value;
     5d0:	12 96       	adiw	r26, 0x02	; 2
     5d2:	8c 91       	ld	r24, X
     5d4:	92 2f       	mov	r25, r18
     5d6:	98 23       	and	r25, r24
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	09 f4       	brne	.+2      	; 0x5de <_ZN9IR_sensor4readEv+0x18>
     5dc:	80 e0       	ldi	r24, 0x00	; 0
}
     5de:	08 95       	ret

000005e0 <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_>:


#include "Motor_Driver.h"

// default constructor
Motor_Driver::Motor_Driver(PORT_t* p_port, uint8_t pinA, uint8_t pinB, uint8_t pinhA, uint8_t pinhB, TC0_t* t_ctrlA, TC0_t* t_ctrlB):gp_port(p_port), gpinA_bm(1<<pinA), gpinB_bm(1<<pinB), gpinhA_bm(1<<pinhA), gpinhB_bm(1<<pinhB), gt_ctrlA(t_ctrlA), gt_ctrlB(t_ctrlB)
     5e0:	6f 92       	push	r6
     5e2:	7f 92       	push	r7
     5e4:	8f 92       	push	r8
     5e6:	9f 92       	push	r9
     5e8:	af 92       	push	r10
     5ea:	bf 92       	push	r11
     5ec:	cf 92       	push	r12
     5ee:	df 92       	push	r13
     5f0:	ef 92       	push	r14
     5f2:	0f 93       	push	r16
     5f4:	cf 93       	push	r28
     5f6:	df 93       	push	r29
     5f8:	fc 01       	movw	r30, r24
     5fa:	62 83       	std	Z+2, r22	; 0x02
     5fc:	73 83       	std	Z+3, r23	; 0x03
     5fe:	84 2e       	mov	r8, r20
     600:	91 2c       	mov	r9, r1
     602:	81 e0       	ldi	r24, 0x01	; 1
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	38 2f       	mov	r19, r24
     608:	04 2e       	mov	r0, r20
     60a:	01 c0       	rjmp	.+2      	; 0x60e <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x2e>
     60c:	33 0f       	add	r19, r19
     60e:	0a 94       	dec	r0
     610:	ea f7       	brpl	.-6      	; 0x60c <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x2c>
     612:	34 83       	std	Z+4, r19	; 0x04
     614:	62 2e       	mov	r6, r18
     616:	71 2c       	mov	r7, r1
     618:	38 2f       	mov	r19, r24
     61a:	02 2e       	mov	r0, r18
     61c:	01 c0       	rjmp	.+2      	; 0x620 <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x40>
     61e:	33 0f       	add	r19, r19
     620:	0a 94       	dec	r0
     622:	ea f7       	brpl	.-6      	; 0x61e <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x3e>
     624:	35 83       	std	Z+5, r19	; 0x05
     626:	ec 01       	movw	r28, r24
     628:	02 c0       	rjmp	.+4      	; 0x62e <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x4e>
     62a:	cc 0f       	add	r28, r28
     62c:	dd 1f       	adc	r29, r29
     62e:	0a 95       	dec	r16
     630:	e2 f7       	brpl	.-8      	; 0x62a <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x4a>
     632:	c6 83       	std	Z+6, r28	; 0x06
     634:	01 c0       	rjmp	.+2      	; 0x638 <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x58>
     636:	88 0f       	add	r24, r24
     638:	ea 94       	dec	r14
     63a:	ea f7       	brpl	.-6      	; 0x636 <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_+0x56>
     63c:	87 83       	std	Z+7, r24	; 0x07
     63e:	c0 86       	std	Z+8, r12	; 0x08
     640:	d1 86       	std	Z+9, r13	; 0x09
     642:	a2 86       	std	Z+10, r10	; 0x0a
     644:	b3 86       	std	Z+11, r11	; 0x0b
{
	pin1 = pinA;
     646:	40 83       	st	Z, r20
	pin2 = pinB;
     648:	21 83       	std	Z+1, r18	; 0x01
	
	period = 1000;
     64a:	88 ee       	ldi	r24, 0xE8	; 232
     64c:	93 e0       	ldi	r25, 0x03	; 3
     64e:	84 87       	std	Z+12, r24	; 0x0c
     650:	95 87       	std	Z+13, r25	; 0x0d
	gp_port->DIR |= gpinhA_bm;
     652:	db 01       	movw	r26, r22
     654:	8c 91       	ld	r24, X
     656:	c8 2b       	or	r28, r24
     658:	cc 93       	st	X, r28
	gp_port->DIR |= gpinhB_bm;
     65a:	c2 81       	ldd	r28, Z+2	; 0x02
     65c:	d3 81       	ldd	r29, Z+3	; 0x03
     65e:	98 81       	ld	r25, Y
     660:	87 81       	ldd	r24, Z+7	; 0x07
     662:	89 2b       	or	r24, r25
     664:	88 83       	st	Y, r24
	gp_port->OUT |= gpinhA_bm;
     666:	c2 81       	ldd	r28, Z+2	; 0x02
     668:	d3 81       	ldd	r29, Z+3	; 0x03
     66a:	9c 81       	ldd	r25, Y+4	; 0x04
     66c:	86 81       	ldd	r24, Z+6	; 0x06
     66e:	89 2b       	or	r24, r25
     670:	8c 83       	std	Y+4, r24	; 0x04
	gp_port->OUT |= gpinhB_bm;
     672:	c2 81       	ldd	r28, Z+2	; 0x02
     674:	d3 81       	ldd	r29, Z+3	; 0x03
     676:	9c 81       	ldd	r25, Y+4	; 0x04
     678:	87 81       	ldd	r24, Z+7	; 0x07
     67a:	89 2b       	or	r24, r25
     67c:	8c 83       	std	Y+4, r24	; 0x04
	gp_port->DIR |= gpinA_bm;
     67e:	c2 81       	ldd	r28, Z+2	; 0x02
     680:	d3 81       	ldd	r29, Z+3	; 0x03
     682:	98 81       	ld	r25, Y
     684:	84 81       	ldd	r24, Z+4	; 0x04
     686:	89 2b       	or	r24, r25
     688:	88 83       	st	Y, r24
	gp_port->DIR |= gpinB_bm;
     68a:	c2 81       	ldd	r28, Z+2	; 0x02
     68c:	d3 81       	ldd	r29, Z+3	; 0x03
     68e:	98 81       	ld	r25, Y
     690:	85 81       	ldd	r24, Z+5	; 0x05
     692:	89 2b       	or	r24, r25
     694:	88 83       	st	Y, r24
	gt_ctrlA->CTRLA = ~TC0_CLKSEL_gm | TC_CLKSEL_DIV1_gc;					//Set clock division in control register A to 1
     696:	c0 85       	ldd	r28, Z+8	; 0x08
     698:	d1 85       	ldd	r29, Z+9	; 0x09
     69a:	81 ef       	ldi	r24, 0xF1	; 241
     69c:	88 83       	st	Y, r24
	gt_ctrlA->PER = period;													//Set period in PER register
     69e:	c0 85       	ldd	r28, Z+8	; 0x08
     6a0:	d1 85       	ldd	r29, Z+9	; 0x09
     6a2:	84 85       	ldd	r24, Z+12	; 0x0c
     6a4:	95 85       	ldd	r25, Z+13	; 0x0d
     6a6:	8e a3       	std	Y+38, r24	; 0x26
     6a8:	9f a3       	std	Y+39, r25	; 0x27
	gt_ctrlA->CTRLB = (~(TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm | TC0_WGMODE_gm)) | TC_WGMODE_SS_gc | TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;	//Set single slope mode and enable channel
     6aa:	c0 85       	ldd	r28, Z+8	; 0x08
     6ac:	d1 85       	ldd	r29, Z+9	; 0x09
     6ae:	8b ef       	ldi	r24, 0xFB	; 251
     6b0:	89 83       	std	Y+1, r24	; 0x01
	gt_ctrlA->CTRLD = (~(TC0_EVACT_gm | TC0_EVSEL_gm)) | TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
     6b2:	c0 85       	ldd	r28, Z+8	; 0x08
     6b4:	d1 85       	ldd	r29, Z+9	; 0x09
     6b6:	80 e1       	ldi	r24, 0x10	; 16
     6b8:	8b 83       	std	Y+3, r24	; 0x03
	*(&gt_ctrlA->CCA + pinA) = 0;
     6ba:	c0 85       	ldd	r28, Z+8	; 0x08
     6bc:	d1 85       	ldd	r29, Z+9	; 0x09
     6be:	a8 96       	adiw	r28, 0x28	; 40
     6c0:	c4 01       	movw	r24, r8
     6c2:	88 0f       	add	r24, r24
     6c4:	99 1f       	adc	r25, r25
     6c6:	c8 0f       	add	r28, r24
     6c8:	d9 1f       	adc	r29, r25
     6ca:	18 82       	st	Y, r1
     6cc:	19 82       	std	Y+1, r1	; 0x01
	*(&gt_ctrlA->CCA + pinB) = 0;
     6ce:	00 84       	ldd	r0, Z+8	; 0x08
     6d0:	f1 85       	ldd	r31, Z+9	; 0x09
     6d2:	e0 2d       	mov	r30, r0
     6d4:	b8 96       	adiw	r30, 0x28	; 40
     6d6:	c3 01       	movw	r24, r6
     6d8:	88 0f       	add	r24, r24
     6da:	99 1f       	adc	r25, r25
     6dc:	e8 0f       	add	r30, r24
     6de:	f9 1f       	adc	r31, r25
     6e0:	10 82       	st	Z, r1
     6e2:	11 82       	std	Z+1, r1	; 0x01

} //Motor_Driver
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	0f 91       	pop	r16
     6ea:	ef 90       	pop	r14
     6ec:	df 90       	pop	r13
     6ee:	cf 90       	pop	r12
     6f0:	bf 90       	pop	r11
     6f2:	af 90       	pop	r10
     6f4:	9f 90       	pop	r9
     6f6:	8f 90       	pop	r8
     6f8:	7f 90       	pop	r7
     6fa:	6f 90       	pop	r6
     6fc:	08 95       	ret

000006fe <_ZN12Motor_Driver14set_duty_cycleEa>:

void Motor_Driver::set_duty_cycle(int8_t duty_cycle)
{
     6fe:	cf 93       	push	r28
     700:	df 93       	push	r29
     702:	fc 01       	movw	r30, r24
	if (duty_cycle>=0)
     704:	66 23       	and	r22, r22
     706:	0c f4       	brge	.+2      	; 0x70a <_ZN12Motor_Driver14set_duty_cycleEa+0xc>
     708:	47 c0       	rjmp	.+142    	; 0x798 <_ZN12Motor_Driver14set_duty_cycleEa+0x9a>
	{
		if (duty_cycle>=100)
     70a:	64 36       	cpi	r22, 0x64	; 100
     70c:	dc f0       	brlt	.+54     	; 0x744 <_ZN12Motor_Driver14set_duty_cycleEa+0x46>
		{
			*(&gt_ctrlA->CCA + pin1) = period;
     70e:	a0 85       	ldd	r26, Z+8	; 0x08
     710:	b1 85       	ldd	r27, Z+9	; 0x09
     712:	98 96       	adiw	r26, 0x28	; 40
     714:	80 81       	ld	r24, Z
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	88 0f       	add	r24, r24
     71a:	99 1f       	adc	r25, r25
     71c:	a8 0f       	add	r26, r24
     71e:	b9 1f       	adc	r27, r25
     720:	84 85       	ldd	r24, Z+12	; 0x0c
     722:	95 85       	ldd	r25, Z+13	; 0x0d
     724:	8d 93       	st	X+, r24
     726:	9c 93       	st	X, r25
			*(&gt_ctrlA->CCA + pin2) = 0;
     728:	20 85       	ldd	r18, Z+8	; 0x08
     72a:	31 85       	ldd	r19, Z+9	; 0x09
     72c:	28 5d       	subi	r18, 0xD8	; 216
     72e:	3f 4f       	sbci	r19, 0xFF	; 255
     730:	81 81       	ldd	r24, Z+1	; 0x01
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	88 0f       	add	r24, r24
     736:	99 1f       	adc	r25, r25
     738:	f9 01       	movw	r30, r18
     73a:	e8 0f       	add	r30, r24
     73c:	f9 1f       	adc	r31, r25
     73e:	10 82       	st	Z, r1
     740:	11 82       	std	Z+1, r1	; 0x01
     742:	6c c0       	rjmp	.+216    	; 0x81c <_ZN12Motor_Driver14set_duty_cycleEa+0x11e>
		}
		else
		{
			*(&gt_ctrlA->CCA + pin1) = period*(duty_cycle)/100;
     744:	c0 85       	ldd	r28, Z+8	; 0x08
     746:	d1 85       	ldd	r29, Z+9	; 0x09
     748:	a8 96       	adiw	r28, 0x28	; 40
     74a:	80 81       	ld	r24, Z
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	88 0f       	add	r24, r24
     750:	99 1f       	adc	r25, r25
     752:	c8 0f       	add	r28, r24
     754:	d9 1f       	adc	r29, r25
     756:	44 85       	ldd	r20, Z+12	; 0x0c
     758:	55 85       	ldd	r21, Z+13	; 0x0d
     75a:	64 03       	mulsu	r22, r20
     75c:	90 01       	movw	r18, r0
     75e:	65 9f       	mul	r22, r21
     760:	30 0d       	add	r19, r0
     762:	11 24       	eor	r1, r1
     764:	36 95       	lsr	r19
     766:	27 95       	ror	r18
     768:	36 95       	lsr	r19
     76a:	27 95       	ror	r18
     76c:	ab e7       	ldi	r26, 0x7B	; 123
     76e:	b4 e1       	ldi	r27, 0x14	; 20
     770:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <__umulhisi3>
     774:	96 95       	lsr	r25
     776:	87 95       	ror	r24
     778:	88 83       	st	Y, r24
     77a:	99 83       	std	Y+1, r25	; 0x01
			*(&gt_ctrlA->CCA + pin2) = 0;
     77c:	20 85       	ldd	r18, Z+8	; 0x08
     77e:	31 85       	ldd	r19, Z+9	; 0x09
     780:	28 5d       	subi	r18, 0xD8	; 216
     782:	3f 4f       	sbci	r19, 0xFF	; 255
     784:	81 81       	ldd	r24, Z+1	; 0x01
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	88 0f       	add	r24, r24
     78a:	99 1f       	adc	r25, r25
     78c:	f9 01       	movw	r30, r18
     78e:	e8 0f       	add	r30, r24
     790:	f9 1f       	adc	r31, r25
     792:	10 82       	st	Z, r1
     794:	11 82       	std	Z+1, r1	; 0x01
     796:	42 c0       	rjmp	.+132    	; 0x81c <_ZN12Motor_Driver14set_duty_cycleEa+0x11e>
		}
	}
	else
	{
		if (duty_cycle<=-100)
     798:	6d 39       	cpi	r22, 0x9D	; 157
     79a:	cc f4       	brge	.+50     	; 0x7ce <_ZN12Motor_Driver14set_duty_cycleEa+0xd0>
		{
			*(&gt_ctrlA->CCA + pin1) = 0;
     79c:	a0 85       	ldd	r26, Z+8	; 0x08
     79e:	b1 85       	ldd	r27, Z+9	; 0x09
     7a0:	98 96       	adiw	r26, 0x28	; 40
     7a2:	80 81       	ld	r24, Z
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	88 0f       	add	r24, r24
     7a8:	99 1f       	adc	r25, r25
     7aa:	a8 0f       	add	r26, r24
     7ac:	b9 1f       	adc	r27, r25
     7ae:	1d 92       	st	X+, r1
     7b0:	1c 92       	st	X, r1
			*(&gt_ctrlA->CCA + pin2) = period;
     7b2:	a0 85       	ldd	r26, Z+8	; 0x08
     7b4:	b1 85       	ldd	r27, Z+9	; 0x09
     7b6:	98 96       	adiw	r26, 0x28	; 40
     7b8:	81 81       	ldd	r24, Z+1	; 0x01
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	88 0f       	add	r24, r24
     7be:	99 1f       	adc	r25, r25
     7c0:	a8 0f       	add	r26, r24
     7c2:	b9 1f       	adc	r27, r25
     7c4:	84 85       	ldd	r24, Z+12	; 0x0c
     7c6:	95 85       	ldd	r25, Z+13	; 0x0d
     7c8:	8d 93       	st	X+, r24
     7ca:	9c 93       	st	X, r25
     7cc:	27 c0       	rjmp	.+78     	; 0x81c <_ZN12Motor_Driver14set_duty_cycleEa+0x11e>
		}
		else
		{
			*(&gt_ctrlA->CCA + pin1) = 0;
     7ce:	a0 85       	ldd	r26, Z+8	; 0x08
     7d0:	b1 85       	ldd	r27, Z+9	; 0x09
     7d2:	98 96       	adiw	r26, 0x28	; 40
     7d4:	80 81       	ld	r24, Z
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	a8 0f       	add	r26, r24
     7de:	b9 1f       	adc	r27, r25
     7e0:	1d 92       	st	X+, r1
     7e2:	1c 92       	st	X, r1
			*(&gt_ctrlA->CCA + pin2) = period*(duty_cycle)/100;
     7e4:	c0 85       	ldd	r28, Z+8	; 0x08
     7e6:	d1 85       	ldd	r29, Z+9	; 0x09
     7e8:	a8 96       	adiw	r28, 0x28	; 40
     7ea:	81 81       	ldd	r24, Z+1	; 0x01
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	88 0f       	add	r24, r24
     7f0:	99 1f       	adc	r25, r25
     7f2:	c8 0f       	add	r28, r24
     7f4:	d9 1f       	adc	r29, r25
     7f6:	44 85       	ldd	r20, Z+12	; 0x0c
     7f8:	55 85       	ldd	r21, Z+13	; 0x0d
     7fa:	64 03       	mulsu	r22, r20
     7fc:	90 01       	movw	r18, r0
     7fe:	65 9f       	mul	r22, r21
     800:	30 0d       	add	r19, r0
     802:	11 24       	eor	r1, r1
     804:	36 95       	lsr	r19
     806:	27 95       	ror	r18
     808:	36 95       	lsr	r19
     80a:	27 95       	ror	r18
     80c:	ab e7       	ldi	r26, 0x7B	; 123
     80e:	b4 e1       	ldi	r27, 0x14	; 20
     810:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <__umulhisi3>
     814:	96 95       	lsr	r25
     816:	87 95       	ror	r24
     818:	88 83       	st	Y, r24
     81a:	99 83       	std	Y+1, r25	; 0x01
		}
	}
	
	
}
     81c:	df 91       	pop	r29
     81e:	cf 91       	pop	r28
     820:	08 95       	ret

00000822 <_ZN14task_EdgeSense3runEv>:
//-------------------------------------------------------------------------------------
/** This task blinks an LED attached to PORTA Pin 1
 */

void task_EdgeSense::run (void)
{
     822:	cf 93       	push	r28
     824:	df 93       	push	r29
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	2d 97       	sbiw	r28, 0x0d	; 13
     82c:	cd bf       	out	0x3d, r28	; 61
     82e:	de bf       	out	0x3e, r29	; 62
     830:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     832:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskGetTickCount>
     836:	69 83       	std	Y+1, r22	; 0x01
     838:	7a 83       	std	Y+2, r23	; 0x02
     83a:	8b 83       	std	Y+3, r24	; 0x03
     83c:	9c 83       	std	Y+4, r25	; 0x04
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     83e:	6a e0       	ldi	r22, 0x0A	; 10
     840:	70 e0       	ldi	r23, 0x00	; 0
     842:	80 e0       	ldi	r24, 0x00	; 0
     844:	90 e0       	ldi	r25, 0x00	; 0
     846:	0e 94 33 11 	call	0x2266	; 0x2266 <vTaskDelay>

	// Wait a little while for user interface task to finish up
	delay_ms(10);
	IR_sensor edgesensor1(&PORTF,6);
     84a:	46 e0       	ldi	r20, 0x06	; 6
     84c:	60 ea       	ldi	r22, 0xA0	; 160
     84e:	76 e0       	ldi	r23, 0x06	; 6
     850:	ce 01       	movw	r24, r28
     852:	05 96       	adiw	r24, 0x05	; 5
     854:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <_ZN9IR_sensorC1EP11PORT_structh>
	IR_sensor edgesensor2(&PORTF,7);
     858:	47 e0       	ldi	r20, 0x07	; 7
     85a:	60 ea       	ldi	r22, 0xA0	; 160
     85c:	76 e0       	ldi	r23, 0x06	; 6
     85e:	ce 01       	movw	r24, r28
     860:	08 96       	adiw	r24, 0x08	; 8
     862:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <_ZN9IR_sensorC1EP11PORT_structh>
	IR_sensor edgesensor3(&PORTF,2);
     866:	42 e0       	ldi	r20, 0x02	; 2
     868:	60 ea       	ldi	r22, 0xA0	; 160
     86a:	76 e0       	ldi	r23, 0x06	; 6
     86c:	ce 01       	movw	r24, r28
     86e:	0b 96       	adiw	r24, 0x0b	; 11
     870:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <_ZN9IR_sensorC1EP11PORT_structh>
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     874:	ff 24       	eor	r15, r15
     876:	f3 94       	inc	r15
	
	while(1)
	{
		if(!edgesensor1.read() || !edgesensor2.read() || !edgesensor3.read()) //   
     878:	ce 01       	movw	r24, r28
     87a:	05 96       	adiw	r24, 0x05	; 5
     87c:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <_ZN9IR_sensor4readEv>
     880:	88 23       	and	r24, r24
     882:	61 f0       	breq	.+24     	; 0x89c <_ZN14task_EdgeSense3runEv+0x7a>
     884:	ce 01       	movw	r24, r28
     886:	08 96       	adiw	r24, 0x08	; 8
     888:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <_ZN9IR_sensor4readEv>
     88c:	88 23       	and	r24, r24
     88e:	31 f0       	breq	.+12     	; 0x89c <_ZN14task_EdgeSense3runEv+0x7a>
     890:	ce 01       	movw	r24, r28
     892:	0b 96       	adiw	r24, 0x0b	; 11
     894:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <_ZN9IR_sensor4readEv>
     898:	81 11       	cpse	r24, r1
     89a:	0b c0       	rjmp	.+22     	; 0x8b2 <_ZN14task_EdgeSense3runEv+0x90>
		{
			IR_flg->put(true);
     89c:	e0 91 30 41 	lds	r30, 0x4130	; 0x804130 <IR_flg>
     8a0:	f0 91 31 41 	lds	r31, 0x4131	; 0x804131 <IR_flg+0x1>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8a4:	0f b6       	in	r0, 0x3f	; 63
     8a6:	f8 94       	cli
     8a8:	0f 92       	push	r0
			the_data = new_data;
     8aa:	f0 82       	st	Z, r15
			portEXIT_CRITICAL ();
     8ac:	0f 90       	pop	r0
     8ae:	0f be       	out	0x3f, r0	; 63
     8b0:	0a c0       	rjmp	.+20     	; 0x8c6 <_ZN14task_EdgeSense3runEv+0xa4>
		}
		else
		{
			IR_flg->put(false);
     8b2:	e0 91 30 41 	lds	r30, 0x4130	; 0x804130 <IR_flg>
     8b6:	f0 91 31 41 	lds	r31, 0x4131	; 0x804131 <IR_flg+0x1>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8ba:	0f b6       	in	r0, 0x3f	; 63
     8bc:	f8 94       	cli
     8be:	0f 92       	push	r0
			the_data = new_data;
     8c0:	10 82       	st	Z, r1
			portEXIT_CRITICAL ();
     8c2:	0f 90       	pop	r0
     8c4:	0f be       	out	0x3f, r0	; 63
		}
		
		runs++;
     8c6:	f8 01       	movw	r30, r16
     8c8:	86 85       	ldd	r24, Z+14	; 0x0e
     8ca:	97 85       	ldd	r25, Z+15	; 0x0f
     8cc:	a0 89       	ldd	r26, Z+16	; 0x10
     8ce:	b1 89       	ldd	r27, Z+17	; 0x11
     8d0:	01 96       	adiw	r24, 0x01	; 1
     8d2:	a1 1d       	adc	r26, r1
     8d4:	b1 1d       	adc	r27, r1
     8d6:	86 87       	std	Z+14, r24	; 0x0e
     8d8:	97 87       	std	Z+15, r25	; 0x0f
     8da:	a0 8b       	std	Z+16, r26	; 0x10
     8dc:	b1 8b       	std	Z+17, r27	; 0x11
		 *  @param milliseconds The duration of the delay interval in milliseconds
		 */
		void delay_from_to_ms (portTickType& from_ticks, portTickType milliseconds)
		{
			portTickType interval = configMS_TO_TICKS (milliseconds);
			vTaskDelayUntil (&from_ticks, interval);
     8de:	4a e0       	ldi	r20, 0x0A	; 10
     8e0:	50 e0       	ldi	r21, 0x00	; 0
     8e2:	60 e0       	ldi	r22, 0x00	; 0
     8e4:	70 e0       	ldi	r23, 0x00	; 0
     8e6:	ce 01       	movw	r24, r28
     8e8:	01 96       	adiw	r24, 0x01	; 1
     8ea:	0e 94 c6 10 	call	0x218c	; 0x218c <vTaskDelayUntil>
     8ee:	c4 cf       	rjmp	.-120    	; 0x878 <_ZN14task_EdgeSense3runEv+0x56>

000008f0 <_ZN14task_EdgeSenseC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_EdgeSense::task_EdgeSense (const char* a_name, 
     8f0:	0f 93       	push	r16
     8f2:	1f 93       	push	r17
     8f4:	cf 93       	push	r28
     8f6:	df 93       	push	r29
     8f8:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8fa:	0e 94 63 13 	call	0x26c6	; 0x26c6 <_ZN8frt_taskC1EPKchjP8emstream>
     8fe:	8a e0       	ldi	r24, 0x0A	; 10
     900:	90 e2       	ldi	r25, 0x20	; 32
     902:	88 83       	st	Y, r24
     904:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     906:	df 91       	pop	r29
     908:	cf 91       	pop	r28
     90a:	1f 91       	pop	r17
     90c:	0f 91       	pop	r16
     90e:	08 95       	ret

00000910 <_ZN10task_MOTOR3runEv>:
//-------------------------------------------------------------------------------------
/** This task cycles through motor functions
 */

void task_MOTOR::run (void)
{
     910:	cf 93       	push	r28
     912:	df 93       	push	r29
     914:	cd b7       	in	r28, 0x3d	; 61
     916:	de b7       	in	r29, 0x3e	; 62
     918:	a0 97       	sbiw	r28, 0x20	; 32
     91a:	cd bf       	out	0x3d, r28	; 61
     91c:	de bf       	out	0x3e, r29	; 62
     91e:	4c 01       	movw	r8, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     920:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskGetTickCount>
     924:	69 83       	std	Y+1, r22	; 0x01
     926:	7a 83       	std	Y+2, r23	; 0x02
     928:	8b 83       	std	Y+3, r24	; 0x03
     92a:	9c 83       	std	Y+4, r25	; 0x04
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     92c:	6a e0       	ldi	r22, 0x0A	; 10
     92e:	70 e0       	ldi	r23, 0x00	; 0
     930:	80 e0       	ldi	r24, 0x00	; 0
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	0e 94 33 11 	call	0x2266	; 0x2266 <vTaskDelay>

	// Wait a little while for user interface task to finish up
	delay_ms(10);
	
	Motor_Driver motor1(&PORTD,3,2,4,5,&TCD0,&TCD0);
     938:	0f 2e       	mov	r0, r31
     93a:	a1 2c       	mov	r10, r1
     93c:	f9 e0       	ldi	r31, 0x09	; 9
     93e:	bf 2e       	mov	r11, r31
     940:	f0 2d       	mov	r31, r0
     942:	0f 2e       	mov	r0, r31
     944:	c1 2c       	mov	r12, r1
     946:	f9 e0       	ldi	r31, 0x09	; 9
     948:	df 2e       	mov	r13, r31
     94a:	f0 2d       	mov	r31, r0
     94c:	0f 2e       	mov	r0, r31
     94e:	f5 e0       	ldi	r31, 0x05	; 5
     950:	ef 2e       	mov	r14, r31
     952:	f0 2d       	mov	r31, r0
     954:	04 e0       	ldi	r16, 0x04	; 4
     956:	22 e0       	ldi	r18, 0x02	; 2
     958:	43 e0       	ldi	r20, 0x03	; 3
     95a:	60 e6       	ldi	r22, 0x60	; 96
     95c:	76 e0       	ldi	r23, 0x06	; 6
     95e:	ce 01       	movw	r24, r28
     960:	05 96       	adiw	r24, 0x05	; 5
     962:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_>
	Motor_Driver motor2(&PORTC,1,3,5,6,&TCC0,&TCC0);
     966:	a1 2c       	mov	r10, r1
     968:	68 94       	set
     96a:	bb 24       	eor	r11, r11
     96c:	b3 f8       	bld	r11, 3
     96e:	c1 2c       	mov	r12, r1
     970:	68 94       	set
     972:	dd 24       	eor	r13, r13
     974:	d3 f8       	bld	r13, 3
     976:	0f 2e       	mov	r0, r31
     978:	f6 e0       	ldi	r31, 0x06	; 6
     97a:	ef 2e       	mov	r14, r31
     97c:	f0 2d       	mov	r31, r0
     97e:	05 e0       	ldi	r16, 0x05	; 5
     980:	23 e0       	ldi	r18, 0x03	; 3
     982:	41 e0       	ldi	r20, 0x01	; 1
     984:	60 e4       	ldi	r22, 0x40	; 64
     986:	76 e0       	ldi	r23, 0x06	; 6
     988:	ce 01       	movw	r24, r28
     98a:	43 96       	adiw	r24, 0x13	; 19
     98c:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <_ZN12Motor_DriverC1EP11PORT_structhhhhP10TC0_structS3_>
	
	
	while(1)
	{
		switch (state)
     990:	f4 01       	movw	r30, r8
     992:	84 85       	ldd	r24, Z+12	; 0x0c
     994:	81 30       	cpi	r24, 0x01	; 1
     996:	19 f1       	breq	.+70     	; 0x9de <_ZN10task_MOTOR3runEv+0xce>
     998:	30 f0       	brcs	.+12     	; 0x9a6 <_ZN10task_MOTOR3runEv+0x96>
     99a:	82 30       	cpi	r24, 0x02	; 2
     99c:	79 f1       	breq	.+94     	; 0x9fc <_ZN10task_MOTOR3runEv+0xec>
     99e:	83 30       	cpi	r24, 0x03	; 3
     9a0:	09 f4       	brne	.+2      	; 0x9a4 <_ZN10task_MOTOR3runEv+0x94>
     9a2:	3b c0       	rjmp	.+118    	; 0xa1a <_ZN10task_MOTOR3runEv+0x10a>
     9a4:	55 c0       	rjmp	.+170    	; 0xa50 <_ZN10task_MOTOR3runEv+0x140>
		{
			case MOTOR_SLOW:
			{
				motor1.set_duty_cycle(50);
     9a6:	62 e3       	ldi	r22, 0x32	; 50
     9a8:	ce 01       	movw	r24, r28
     9aa:	05 96       	adiw	r24, 0x05	; 5
     9ac:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				motor2.set_duty_cycle(50);
     9b0:	62 e3       	ldi	r22, 0x32	; 50
     9b2:	ce 01       	movw	r24, r28
     9b4:	43 96       	adiw	r24, 0x13	; 19
     9b6:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9ba:	0f b6       	in	r0, 0x3f	; 63
     9bc:	f8 94       	cli
     9be:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
			temporary_copy = the_data;
     9c4:	e0 91 30 41 	lds	r30, 0x4130	; 0x804130 <IR_flg>
     9c8:	f0 91 31 41 	lds	r31, 0x4131	; 0x804131 <IR_flg+0x1>
				if (IR_flg->get())
     9cc:	80 81       	ld	r24, Z
     9ce:	88 23       	and	r24, r24
     9d0:	09 f4       	brne	.+2      	; 0x9d4 <_ZN10task_MOTOR3runEv+0xc4>
     9d2:	43 c0       	rjmp	.+134    	; 0xa5a <_ZN10task_MOTOR3runEv+0x14a>
				{
					
					transition_to (MOTOR_TURN_IN_PLACE);
     9d4:	63 e0       	ldi	r22, 0x03	; 3
     9d6:	c4 01       	movw	r24, r8
     9d8:	0e 94 5f 13 	call	0x26be	; 0x26be <_ZN8frt_task13transition_toEh>
     9dc:	3e c0       	rjmp	.+124    	; 0xa5a <_ZN10task_MOTOR3runEv+0x14a>
				}
				break;
			}
			case MOTOR_FAST:
			{
				motor1.set_duty_cycle(100);
     9de:	64 e6       	ldi	r22, 0x64	; 100
     9e0:	ce 01       	movw	r24, r28
     9e2:	05 96       	adiw	r24, 0x05	; 5
     9e4:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				motor2.set_duty_cycle(100);
     9e8:	64 e6       	ldi	r22, 0x64	; 100
     9ea:	ce 01       	movw	r24, r28
     9ec:	43 96       	adiw	r24, 0x13	; 19
     9ee:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				transition_to (MOTOR_STOP);
     9f2:	62 e0       	ldi	r22, 0x02	; 2
     9f4:	c4 01       	movw	r24, r8
     9f6:	0e 94 5f 13 	call	0x26be	; 0x26be <_ZN8frt_task13transition_toEh>
				break;
     9fa:	2f c0       	rjmp	.+94     	; 0xa5a <_ZN10task_MOTOR3runEv+0x14a>
			}
			case MOTOR_STOP:
			{
				motor1.set_duty_cycle(0);
     9fc:	60 e0       	ldi	r22, 0x00	; 0
     9fe:	ce 01       	movw	r24, r28
     a00:	05 96       	adiw	r24, 0x05	; 5
     a02:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				motor2.set_duty_cycle(0);
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	43 96       	adiw	r24, 0x13	; 19
     a0c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				transition_to(MOTOR_TURN_IN_PLACE);	
     a10:	63 e0       	ldi	r22, 0x03	; 3
     a12:	c4 01       	movw	r24, r8
     a14:	0e 94 5f 13 	call	0x26be	; 0x26be <_ZN8frt_task13transition_toEh>
				break;
     a18:	20 c0       	rjmp	.+64     	; 0xa5a <_ZN10task_MOTOR3runEv+0x14a>
			}
			case MOTOR_TURN_IN_PLACE:
			{
				motor1.set_duty_cycle(50);
     a1a:	62 e3       	ldi	r22, 0x32	; 50
     a1c:	ce 01       	movw	r24, r28
     a1e:	05 96       	adiw	r24, 0x05	; 5
     a20:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				motor2.set_duty_cycle(-70);
     a24:	6a eb       	ldi	r22, 0xBA	; 186
     a26:	ce 01       	movw	r24, r28
     a28:	43 96       	adiw	r24, 0x13	; 19
     a2a:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a2e:	0f b6       	in	r0, 0x3f	; 63
     a30:	f8 94       	cli
     a32:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     a34:	0f 90       	pop	r0
     a36:	0f be       	out	0x3f, r0	; 63
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
			temporary_copy = the_data;
     a38:	e0 91 30 41 	lds	r30, 0x4130	; 0x804130 <IR_flg>
     a3c:	f0 91 31 41 	lds	r31, 0x4131	; 0x804131 <IR_flg+0x1>
				if (!IR_flg->get())
     a40:	80 81       	ld	r24, Z
     a42:	81 11       	cpse	r24, r1
     a44:	0a c0       	rjmp	.+20     	; 0xa5a <_ZN10task_MOTOR3runEv+0x14a>
				{
					transition_to(MOTOR_SLOW);
     a46:	60 e0       	ldi	r22, 0x00	; 0
     a48:	c4 01       	movw	r24, r8
     a4a:	0e 94 5f 13 	call	0x26be	; 0x26be <_ZN8frt_task13transition_toEh>
     a4e:	05 c0       	rjmp	.+10     	; 0xa5a <_ZN10task_MOTOR3runEv+0x14a>
				}
				break;
			}
			default:
			{
				motor2.set_duty_cycle(100);
     a50:	64 e6       	ldi	r22, 0x64	; 100
     a52:	ce 01       	movw	r24, r28
     a54:	43 96       	adiw	r24, 0x13	; 19
     a56:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN12Motor_Driver14set_duty_cycleEa>
				break;
			}
		}
		runs++;
     a5a:	f4 01       	movw	r30, r8
     a5c:	86 85       	ldd	r24, Z+14	; 0x0e
     a5e:	97 85       	ldd	r25, Z+15	; 0x0f
     a60:	a0 89       	ldd	r26, Z+16	; 0x10
     a62:	b1 89       	ldd	r27, Z+17	; 0x11
     a64:	01 96       	adiw	r24, 0x01	; 1
     a66:	a1 1d       	adc	r26, r1
     a68:	b1 1d       	adc	r27, r1
     a6a:	86 87       	std	Z+14, r24	; 0x0e
     a6c:	97 87       	std	Z+15, r25	; 0x0f
     a6e:	a0 8b       	std	Z+16, r26	; 0x10
     a70:	b1 8b       	std	Z+17, r27	; 0x11
		 *  @param milliseconds The duration of the delay interval in milliseconds
		 */
		void delay_from_to_ms (portTickType& from_ticks, portTickType milliseconds)
		{
			portTickType interval = configMS_TO_TICKS (milliseconds);
			vTaskDelayUntil (&from_ticks, interval);
     a72:	4a e0       	ldi	r20, 0x0A	; 10
     a74:	50 e0       	ldi	r21, 0x00	; 0
     a76:	60 e0       	ldi	r22, 0x00	; 0
     a78:	70 e0       	ldi	r23, 0x00	; 0
     a7a:	ce 01       	movw	r24, r28
     a7c:	01 96       	adiw	r24, 0x01	; 1
     a7e:	0e 94 c6 10 	call	0x218c	; 0x218c <vTaskDelayUntil>
     a82:	86 cf       	rjmp	.-244    	; 0x990 <_ZN10task_MOTOR3runEv+0x80>

00000a84 <_ZN10task_MOTORC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_MOTOR::task_MOTOR (const char* a_name, 
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a8e:	0e 94 63 13 	call	0x26c6	; 0x26c6 <_ZN8frt_taskC1EPKchjP8emstream>
     a92:	82 e1       	ldi	r24, 0x12	; 18
     a94:	90 e2       	ldi	r25, 0x20	; 32
     a96:	88 83       	st	Y, r24
     a98:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	1f 91       	pop	r17
     aa0:	0f 91       	pop	r16
     aa2:	08 95       	ret

00000aa4 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     aa4:	0f 93       	push	r16
     aa6:	1f 93       	push	r17
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     aae:	0e 94 63 13 	call	0x26c6	; 0x26c6 <_ZN8frt_taskC1EPKchjP8emstream>
     ab2:	8a e1       	ldi	r24, 0x1A	; 26
     ab4:	90 e2       	ldi	r25, 0x20	; 32
     ab6:	88 83       	st	Y, r24
     ab8:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     aba:	df 91       	pop	r29
     abc:	cf 91       	pop	r28
     abe:	1f 91       	pop	r17
     ac0:	0f 91       	pop	r16
     ac2:	08 95       	ret

00000ac4 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     ac4:	0f 93       	push	r16
     ac6:	1f 93       	push	r17
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     ace:	6a e0       	ldi	r22, 0x0A	; 10
     ad0:	8e 81       	ldd	r24, Y+6	; 0x06
     ad2:	9f 81       	ldd	r25, Y+7	; 0x07
     ad4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     ad8:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ada:	69 ed       	ldi	r22, 0xD9	; 217
     adc:	73 e0       	ldi	r23, 0x03	; 3
     ade:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     ae2:	6a e0       	ldi	r22, 0x0A	; 10
     ae4:	c8 01       	movw	r24, r16
     ae6:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     aea:	8c 01       	movw	r16, r24
     aec:	63 ed       	ldi	r22, 0xD3	; 211
     aee:	73 e0       	ldi	r23, 0x03	; 3
     af0:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     af4:	67 e0       	ldi	r22, 0x07	; 7
     af6:	c8 01       	movw	r24, r16
     af8:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     afc:	6a e0       	ldi	r22, 0x0A	; 10
     afe:	8e 81       	ldd	r24, Y+6	; 0x06
     b00:	9f 81       	ldd	r25, Y+7	; 0x07
     b02:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     b06:	8c 01       	movw	r16, r24
     b08:	68 eb       	ldi	r22, 0xB8	; 184
     b0a:	73 e0       	ldi	r23, 0x03	; 3
     b0c:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     b10:	6a e0       	ldi	r22, 0x0A	; 10
     b12:	c8 01       	movw	r24, r16
     b14:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     b18:	8c 01       	movw	r16, r24
     b1a:	62 eb       	ldi	r22, 0xB2	; 178
     b1c:	73 e0       	ldi	r23, 0x03	; 3
     b1e:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     b22:	66 e0       	ldi	r22, 0x06	; 6
     b24:	c8 01       	movw	r24, r16
     b26:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     b2a:	6a e0       	ldi	r22, 0x0A	; 10
     b2c:	8e 81       	ldd	r24, Y+6	; 0x06
     b2e:	9f 81       	ldd	r25, Y+7	; 0x07
     b30:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     b34:	8c 01       	movw	r16, r24
     b36:	6b e9       	ldi	r22, 0x9B	; 155
     b38:	73 e0       	ldi	r23, 0x03	; 3
     b3a:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     b3e:	66 e0       	ldi	r22, 0x06	; 6
     b40:	c8 01       	movw	r24, r16
     b42:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     b46:	6a e0       	ldi	r22, 0x0A	; 10
     b48:	8e 81       	ldd	r24, Y+6	; 0x06
     b4a:	9f 81       	ldd	r25, Y+7	; 0x07
     b4c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     b50:	8c 01       	movw	r16, r24
     b52:	6f e7       	ldi	r22, 0x7F	; 127
     b54:	73 e0       	ldi	r23, 0x03	; 3
     b56:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     b5a:	66 e0       	ldi	r22, 0x06	; 6
     b5c:	c8 01       	movw	r24, r16
     b5e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     b62:	6a e0       	ldi	r22, 0x0A	; 10
     b64:	8e 81       	ldd	r24, Y+6	; 0x06
     b66:	9f 81       	ldd	r25, Y+7	; 0x07
     b68:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     b6c:	8c 01       	movw	r16, r24
     b6e:	67 e6       	ldi	r22, 0x67	; 103
     b70:	73 e0       	ldi	r23, 0x03	; 3
     b72:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     b76:	66 e0       	ldi	r22, 0x06	; 6
     b78:	c8 01       	movw	r24, r16
     b7a:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     b7e:	6a e0       	ldi	r22, 0x0A	; 10
     b80:	8e 81       	ldd	r24, Y+6	; 0x06
     b82:	9f 81       	ldd	r25, Y+7	; 0x07
     b84:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     b88:	8c 01       	movw	r16, r24
     b8a:	66 e4       	ldi	r22, 0x46	; 70
     b8c:	73 e0       	ldi	r23, 0x03	; 3
     b8e:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     b92:	66 e0       	ldi	r22, 0x06	; 6
     b94:	c8 01       	movw	r24, r16
     b96:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     b9a:	6a e0       	ldi	r22, 0x0A	; 10
     b9c:	8e 81       	ldd	r24, Y+6	; 0x06
     b9e:	9f 81       	ldd	r25, Y+7	; 0x07
     ba0:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     ba4:	8c 01       	movw	r16, r24
     ba6:	6f e1       	ldi	r22, 0x1F	; 31
     ba8:	73 e0       	ldi	r23, 0x03	; 3
     baa:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     bae:	66 e0       	ldi	r22, 0x06	; 6
     bb0:	c8 01       	movw	r24, r16
     bb2:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     bb6:	6a e0       	ldi	r22, 0x0A	; 10
     bb8:	8e 81       	ldd	r24, Y+6	; 0x06
     bba:	9f 81       	ldd	r25, Y+7	; 0x07
     bbc:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     bc0:	8c 01       	movw	r16, r24
     bc2:	61 e0       	ldi	r22, 0x01	; 1
     bc4:	73 e0       	ldi	r23, 0x03	; 3
     bc6:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     bca:	66 e0       	ldi	r22, 0x06	; 6
     bcc:	c8 01       	movw	r24, r16
     bce:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     bd2:	6a e0       	ldi	r22, 0x0A	; 10
     bd4:	8e 81       	ldd	r24, Y+6	; 0x06
     bd6:	9f 81       	ldd	r25, Y+7	; 0x07
     bd8:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     bdc:	8c 01       	movw	r16, r24
     bde:	66 ee       	ldi	r22, 0xE6	; 230
     be0:	72 e0       	ldi	r23, 0x02	; 2
     be2:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     be6:	66 e0       	ldi	r22, 0x06	; 6
     be8:	c8 01       	movw	r24, r16
     bea:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     bee:	6a e0       	ldi	r22, 0x0A	; 10
     bf0:	8e 81       	ldd	r24, Y+6	; 0x06
     bf2:	9f 81       	ldd	r25, Y+7	; 0x07
     bf4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     bf8:	ec 01       	movw	r28, r24
     bfa:	67 ed       	ldi	r22, 0xD7	; 215
     bfc:	72 e0       	ldi	r23, 0x02	; 2
     bfe:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     c02:	66 e0       	ldi	r22, 0x06	; 6
     c04:	ce 01       	movw	r24, r28
     c06:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	08 95       	ret

00000c14 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     c14:	af 92       	push	r10
     c16:	bf 92       	push	r11
     c18:	cf 92       	push	r12
     c1a:	df 92       	push	r13
     c1c:	ef 92       	push	r14
     c1e:	ff 92       	push	r15
     c20:	0f 93       	push	r16
     c22:	1f 93       	push	r17
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	00 d0       	rcall	.+0      	; 0xc2a <_ZN9task_user11show_statusEv+0x16>
     c2a:	00 d0       	rcall	.+0      	; 0xc2c <_ZN9task_user11show_statusEv+0x18>
     c2c:	cd b7       	in	r28, 0x3d	; 61
     c2e:	de b7       	in	r29, 0x3e	; 62
     c30:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     c32:	19 82       	std	Y+1, r1	; 0x01
     c34:	1a 82       	std	Y+2, r1	; 0x02
     c36:	1b 82       	std	Y+3, r1	; 0x03
     c38:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     c3a:	1d 82       	std	Y+5, r1	; 0x05
     c3c:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     c3e:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <xPortGetFreeHeapSize>
     c42:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     c44:	ce 01       	movw	r24, r28
     c46:	01 96       	adiw	r24, 0x01	; 1
     c48:	0e 94 14 17 	call	0x2e28	; 0x2e28 <_ZN10time_stamp10set_to_nowEv>
     c4c:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     c4e:	66 e0       	ldi	r22, 0x06	; 6
     c50:	f8 01       	movw	r30, r16
     c52:	86 81       	ldd	r24, Z+6	; 0x06
     c54:	97 81       	ldd	r25, Z+7	; 0x07
     c56:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     c5a:	6a e0       	ldi	r22, 0x0A	; 10
     c5c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     c60:	7c 01       	movw	r14, r24
     c62:	6c eb       	ldi	r22, 0xBC	; 188
     c64:	72 e0       	ldi	r23, 0x02	; 2
     c66:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     c6a:	6a e0       	ldi	r22, 0x0A	; 10
     c6c:	c7 01       	movw	r24, r14
     c6e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     c72:	7c 01       	movw	r14, r24
     c74:	60 eb       	ldi	r22, 0xB0	; 176
     c76:	72 e0       	ldi	r23, 0x02	; 2
     c78:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     c7c:	66 e0       	ldi	r22, 0x06	; 6
     c7e:	c7 01       	movw	r24, r14
     c80:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     c84:	6a e0       	ldi	r22, 0x0A	; 10
     c86:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     c8a:	7c 01       	movw	r14, r24
     c8c:	69 ea       	ldi	r22, 0xA9	; 169
     c8e:	72 e0       	ldi	r23, 0x02	; 2
     c90:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     c94:	b5 01       	movw	r22, r10
     c96:	c7 01       	movw	r24, r14
     c98:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     c9c:	6a e0       	ldi	r22, 0x0A	; 10
     c9e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     ca2:	7c 01       	movw	r14, r24
     ca4:	6b e9       	ldi	r22, 0x9B	; 155
     ca6:	72 e0       	ldi	r23, 0x02	; 2
     ca8:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     cac:	b6 01       	movw	r22, r12
     cae:	c7 01       	movw	r24, r14
     cb0:	0e 94 29 19 	call	0x3252	; 0x3252 <_ZN8emstreamlsEj>
     cb4:	6a e0       	ldi	r22, 0x0A	; 10
     cb6:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     cba:	7c 01       	movw	r14, r24
     cbc:	69 e9       	ldi	r22, 0x99	; 153
     cbe:	72 e0       	ldi	r23, 0x02	; 2
     cc0:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     cc4:	4f ef       	ldi	r20, 0xFF	; 255
     cc6:	5f e1       	ldi	r21, 0x1F	; 31
     cc8:	60 e0       	ldi	r22, 0x00	; 0
     cca:	70 e0       	ldi	r23, 0x00	; 0
     ccc:	c7 01       	movw	r24, r14
     cce:	0e 94 5d 19 	call	0x32ba	; 0x32ba <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     cd2:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     cd6:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     cda:	6a e0       	ldi	r22, 0x0A	; 10
     cdc:	f8 01       	movw	r30, r16
     cde:	86 81       	ldd	r24, Z+6	; 0x06
     ce0:	97 81       	ldd	r25, Z+7	; 0x07
     ce2:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     ce6:	7c 01       	movw	r14, r24
     ce8:	6e e8       	ldi	r22, 0x8E	; 142
     cea:	72 e0       	ldi	r23, 0x02	; 2
     cec:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     cf0:	b6 01       	movw	r22, r12
     cf2:	c7 01       	movw	r24, r14
     cf4:	0e 94 29 19 	call	0x3252	; 0x3252 <_ZN8emstreamlsEj>
     cf8:	66 e0       	ldi	r22, 0x06	; 6
     cfa:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     cfe:	66 e0       	ldi	r22, 0x06	; 6
     d00:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     d04:	f8 01       	movw	r30, r16
     d06:	86 81       	ldd	r24, Z+6	; 0x06
     d08:	97 81       	ldd	r25, Z+7	; 0x07
     d0a:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <_Z15print_task_listP8emstream>
}
     d0e:	26 96       	adiw	r28, 0x06	; 6
     d10:	cd bf       	out	0x3d, r28	; 61
     d12:	de bf       	out	0x3e, r29	; 62
     d14:	df 91       	pop	r29
     d16:	cf 91       	pop	r28
     d18:	1f 91       	pop	r17
     d1a:	0f 91       	pop	r16
     d1c:	ff 90       	pop	r15
     d1e:	ef 90       	pop	r14
     d20:	df 90       	pop	r13
     d22:	cf 90       	pop	r12
     d24:	bf 90       	pop	r11
     d26:	af 90       	pop	r10
     d28:	08 95       	ret

00000d2a <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	00 d0       	rcall	.+0      	; 0xd30 <_ZN9task_user3runEv+0x6>
     d30:	00 d0       	rcall	.+0      	; 0xd32 <_ZN9task_user3runEv+0x8>
     d32:	cd b7       	in	r28, 0x3d	; 61
     d34:	de b7       	in	r29, 0x3e	; 62
     d36:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     d38:	19 82       	std	Y+1, r1	; 0x01
     d3a:	1a 82       	std	Y+2, r1	; 0x02
     d3c:	1b 82       	std	Y+3, r1	; 0x03
     d3e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     d40:	1d 82       	std	Y+5, r1	; 0x05
     d42:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     d44:	6a e0       	ldi	r22, 0x0A	; 10
     d46:	dc 01       	movw	r26, r24
     d48:	16 96       	adiw	r26, 0x06	; 6
     d4a:	8d 91       	ld	r24, X+
     d4c:	9c 91       	ld	r25, X
     d4e:	17 97       	sbiw	r26, 0x07	; 7
     d50:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     d54:	7c 01       	movw	r14, r24
     d56:	62 e2       	ldi	r22, 0x22	; 34
     d58:	74 e0       	ldi	r23, 0x04	; 4
     d5a:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     d5e:	66 e0       	ldi	r22, 0x06	; 6
     d60:	c7 01       	movw	r24, r14
     d62:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     d66:	f8 01       	movw	r30, r16
     d68:	84 85       	ldd	r24, Z+12	; 0x0c
     d6a:	88 23       	and	r24, r24
     d6c:	21 f0       	breq	.+8      	; 0xd76 <_ZN9task_user3runEv+0x4c>
     d6e:	81 30       	cpi	r24, 0x01	; 1
     d70:	09 f4       	brne	.+2      	; 0xd74 <_ZN9task_user3runEv+0x4a>
     d72:	5d c0       	rjmp	.+186    	; 0xe2e <_ZN9task_user3runEv+0x104>
     d74:	d8 c0       	rjmp	.+432    	; 0xf26 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     d76:	86 81       	ldd	r24, Z+6	; 0x06
     d78:	97 81       	ldd	r25, Z+7	; 0x07
     d7a:	dc 01       	movw	r26, r24
     d7c:	ed 91       	ld	r30, X+
     d7e:	fc 91       	ld	r31, X
     d80:	04 80       	ldd	r0, Z+4	; 0x04
     d82:	f5 81       	ldd	r31, Z+5	; 0x05
     d84:	e0 2d       	mov	r30, r0
     d86:	19 95       	eicall
     d88:	88 23       	and	r24, r24
     d8a:	a9 f1       	breq	.+106    	; 0xdf6 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     d8c:	f8 01       	movw	r30, r16
     d8e:	86 81       	ldd	r24, Z+6	; 0x06
     d90:	97 81       	ldd	r25, Z+7	; 0x07
     d92:	dc 01       	movw	r26, r24
     d94:	ed 91       	ld	r30, X+
     d96:	fc 91       	ld	r31, X
     d98:	06 80       	ldd	r0, Z+6	; 0x06
     d9a:	f7 81       	ldd	r31, Z+7	; 0x07
     d9c:	e0 2d       	mov	r30, r0
     d9e:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     da0:	99 27       	eor	r25, r25
     da2:	81 30       	cpi	r24, 0x01	; 1
     da4:	91 05       	cpc	r25, r1
     da6:	f9 f0       	breq	.+62     	; 0xde6 <_ZN9task_user3runEv+0xbc>
     da8:	03 97       	sbiw	r24, 0x03	; 3
     daa:	09 f0       	breq	.+2      	; 0xdae <_ZN9task_user3runEv+0x84>
     dac:	d8 c0       	rjmp	.+432    	; 0xf5e <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     dae:	6a e0       	ldi	r22, 0x0A	; 10
     db0:	f8 01       	movw	r30, r16
     db2:	86 81       	ldd	r24, Z+6	; 0x06
     db4:	97 81       	ldd	r25, Z+7	; 0x07
     db6:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     dba:	8c 01       	movw	r16, r24
     dbc:	64 e1       	ldi	r22, 0x14	; 20
     dbe:	74 e0       	ldi	r23, 0x04	; 4
     dc0:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     dc4:	66 e0       	ldi	r22, 0x06	; 6
     dc6:	c8 01       	movw	r24, r16
     dc8:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     dcc:	93 e0       	ldi	r25, 0x03	; 3
     dce:	88 ed       	ldi	r24, 0xD8	; 216
     dd0:	08 b6       	in	r0, 0x38	; 56
     dd2:	18 be       	out	0x38, r1	; 56
     dd4:	84 bf       	out	0x34, r24	; 52
     dd6:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     dda:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     dde:	81 fd       	sbrc	r24, 1
     de0:	fc cf       	rjmp	.-8      	; 0xdda <_ZN9task_user3runEv+0xb0>
     de2:	08 be       	out	0x38, r0	; 56
     de4:	ff cf       	rjmp	.-2      	; 0xde4 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     de6:	c8 01       	movw	r24, r16
     de8:	0e 94 62 05 	call	0xac4	; 0xac4 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     dec:	61 e0       	ldi	r22, 0x01	; 1
     dee:	c8 01       	movw	r24, r16
     df0:	0e 94 5f 13 	call	0x26be	; 0x26be <_ZN8frt_task13transition_toEh>
							break;
     df4:	b4 c0       	rjmp	.+360    	; 0xf5e <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     df6:	82 e3       	ldi	r24, 0x32	; 50
     df8:	91 e4       	ldi	r25, 0x41	; 65
     dfa:	0e 94 20 16 	call	0x2c40	; 0x2c40 <_ZN14frt_text_queue14check_for_charEv>
     dfe:	88 23       	and	r24, r24
     e00:	09 f4       	brne	.+2      	; 0xe04 <_ZN9task_user3runEv+0xda>
     e02:	ad c0       	rjmp	.+346    	; 0xf5e <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     e04:	d8 01       	movw	r26, r16
     e06:	16 96       	adiw	r26, 0x06	; 6
     e08:	ed 91       	ld	r30, X+
     e0a:	fc 91       	ld	r31, X
     e0c:	17 97       	sbiw	r26, 0x07	; 7
     e0e:	01 90       	ld	r0, Z+
     e10:	f0 81       	ld	r31, Z
     e12:	e0 2d       	mov	r30, r0
     e14:	e2 80       	ldd	r14, Z+2	; 0x02
     e16:	f3 80       	ldd	r15, Z+3	; 0x03
     e18:	82 e3       	ldi	r24, 0x32	; 50
     e1a:	91 e4       	ldi	r25, 0x41	; 65
     e1c:	0e 94 02 16 	call	0x2c04	; 0x2c04 <_ZN14frt_text_queue7getcharEv>
     e20:	68 2f       	mov	r22, r24
     e22:	f8 01       	movw	r30, r16
     e24:	86 81       	ldd	r24, Z+6	; 0x06
     e26:	97 81       	ldd	r25, Z+7	; 0x07
     e28:	f7 01       	movw	r30, r14
     e2a:	19 95       	eicall
     e2c:	98 c0       	rjmp	.+304    	; 0xf5e <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     e2e:	86 81       	ldd	r24, Z+6	; 0x06
     e30:	97 81       	ldd	r25, Z+7	; 0x07
     e32:	dc 01       	movw	r26, r24
     e34:	ed 91       	ld	r30, X+
     e36:	fc 91       	ld	r31, X
     e38:	04 80       	ldd	r0, Z+4	; 0x04
     e3a:	f5 81       	ldd	r31, Z+5	; 0x05
     e3c:	e0 2d       	mov	r30, r0
     e3e:	19 95       	eicall
     e40:	88 23       	and	r24, r24
     e42:	09 f4       	brne	.+2      	; 0xe46 <_ZN9task_user3runEv+0x11c>
     e44:	8c c0       	rjmp	.+280    	; 0xf5e <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     e46:	f8 01       	movw	r30, r16
     e48:	86 81       	ldd	r24, Z+6	; 0x06
     e4a:	97 81       	ldd	r25, Z+7	; 0x07
     e4c:	dc 01       	movw	r26, r24
     e4e:	ed 91       	ld	r30, X+
     e50:	fc 91       	ld	r31, X
     e52:	06 80       	ldd	r0, Z+6	; 0x06
     e54:	f7 81       	ldd	r31, Z+7	; 0x07
     e56:	e0 2d       	mov	r30, r0
     e58:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     e5a:	9c 01       	movw	r18, r24
     e5c:	33 27       	eor	r19, r19
     e5e:	28 36       	cpi	r18, 0x68	; 104
     e60:	31 05       	cpc	r19, r1
     e62:	59 f1       	breq	.+86     	; 0xeba <_ZN9task_user3runEv+0x190>
     e64:	3c f4       	brge	.+14     	; 0xe74 <_ZN9task_user3runEv+0x14a>
     e66:	2b 31       	cpi	r18, 0x1B	; 27
     e68:	31 05       	cpc	r19, r1
     e6a:	59 f1       	breq	.+86     	; 0xec2 <_ZN9task_user3runEv+0x198>
     e6c:	25 36       	cpi	r18, 0x65	; 101
     e6e:	31 05       	cpc	r19, r1
     e70:	41 f1       	breq	.+80     	; 0xec2 <_ZN9task_user3runEv+0x198>
     e72:	3b c0       	rjmp	.+118    	; 0xeea <_ZN9task_user3runEv+0x1c0>
     e74:	23 37       	cpi	r18, 0x73	; 115
     e76:	31 05       	cpc	r19, r1
     e78:	c1 f0       	breq	.+48     	; 0xeaa <_ZN9task_user3runEv+0x180>
     e7a:	26 37       	cpi	r18, 0x76	; 118
     e7c:	31 05       	cpc	r19, r1
     e7e:	89 f0       	breq	.+34     	; 0xea2 <_ZN9task_user3runEv+0x178>
     e80:	2e 36       	cpi	r18, 0x6E	; 110
     e82:	31 05       	cpc	r19, r1
     e84:	91 f5       	brne	.+100    	; 0xeea <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     e86:	ce 01       	movw	r24, r28
     e88:	01 96       	adiw	r24, 0x01	; 1
     e8a:	0e 94 14 17 	call	0x2e28	; 0x2e28 <_ZN10time_stamp10set_to_nowEv>
     e8e:	bc 01       	movw	r22, r24
     e90:	f8 01       	movw	r30, r16
     e92:	86 81       	ldd	r24, Z+6	; 0x06
     e94:	97 81       	ldd	r25, Z+7	; 0x07
     e96:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <_ZlsR8emstreamR10time_stamp>
     e9a:	66 e0       	ldi	r22, 0x06	; 6
     e9c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
							break;
     ea0:	5e c0       	rjmp	.+188    	; 0xf5e <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     ea2:	c8 01       	movw	r24, r16
     ea4:	0e 94 0a 06 	call	0xc14	; 0xc14 <_ZN9task_user11show_statusEv>
							break;
     ea8:	5a c0       	rjmp	.+180    	; 0xf5e <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     eaa:	d8 01       	movw	r26, r16
     eac:	16 96       	adiw	r26, 0x06	; 6
     eae:	8d 91       	ld	r24, X+
     eb0:	9c 91       	ld	r25, X
     eb2:	17 97       	sbiw	r26, 0x07	; 7
     eb4:	0e 94 78 14 	call	0x28f0	; 0x28f0 <_Z17print_task_stacksP8emstream>
							break;
     eb8:	52 c0       	rjmp	.+164    	; 0xf5e <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     eba:	c8 01       	movw	r24, r16
     ebc:	0e 94 62 05 	call	0xac4	; 0xac4 <_ZN9task_user18print_help_messageEv>
							break;
     ec0:	4e c0       	rjmp	.+156    	; 0xf5e <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     ec2:	6a e0       	ldi	r22, 0x0A	; 10
     ec4:	f8 01       	movw	r30, r16
     ec6:	86 81       	ldd	r24, Z+6	; 0x06
     ec8:	97 81       	ldd	r25, Z+7	; 0x07
     eca:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     ece:	7c 01       	movw	r14, r24
     ed0:	62 e0       	ldi	r22, 0x02	; 2
     ed2:	74 e0       	ldi	r23, 0x04	; 4
     ed4:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     ed8:	66 e0       	ldi	r22, 0x06	; 6
     eda:	c7 01       	movw	r24, r14
     edc:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     ee0:	60 e0       	ldi	r22, 0x00	; 0
     ee2:	c8 01       	movw	r24, r16
     ee4:	0e 94 5f 13 	call	0x26be	; 0x26be <_ZN8frt_task13transition_toEh>
							break;
     ee8:	3a c0       	rjmp	.+116    	; 0xf5e <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     eea:	f8 01       	movw	r30, r16
     eec:	a6 81       	ldd	r26, Z+6	; 0x06
     eee:	b7 81       	ldd	r27, Z+7	; 0x07
     ef0:	ed 91       	ld	r30, X+
     ef2:	fc 91       	ld	r31, X
     ef4:	11 97       	sbiw	r26, 0x01	; 1
     ef6:	02 80       	ldd	r0, Z+2	; 0x02
     ef8:	f3 81       	ldd	r31, Z+3	; 0x03
     efa:	e0 2d       	mov	r30, r0
     efc:	68 2f       	mov	r22, r24
     efe:	cd 01       	movw	r24, r26
     f00:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     f02:	6a e0       	ldi	r22, 0x0A	; 10
     f04:	d8 01       	movw	r26, r16
     f06:	16 96       	adiw	r26, 0x06	; 6
     f08:	8d 91       	ld	r24, X+
     f0a:	9c 91       	ld	r25, X
     f0c:	17 97       	sbiw	r26, 0x07	; 7
     f0e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     f12:	7c 01       	movw	r14, r24
     f14:	6c ef       	ldi	r22, 0xFC	; 252
     f16:	73 e0       	ldi	r23, 0x03	; 3
     f18:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     f1c:	66 e0       	ldi	r22, 0x06	; 6
     f1e:	c7 01       	movw	r24, r14
     f20:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
							break;
     f24:	1c c0       	rjmp	.+56     	; 0xf5e <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     f26:	6a e0       	ldi	r22, 0x0A	; 10
     f28:	f8 01       	movw	r30, r16
     f2a:	86 81       	ldd	r24, Z+6	; 0x06
     f2c:	97 81       	ldd	r25, Z+7	; 0x07
     f2e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
     f32:	8c 01       	movw	r16, r24
     f34:	6f ed       	ldi	r22, 0xDF	; 223
     f36:	73 e0       	ldi	r23, 0x03	; 3
     f38:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
     f3c:	66 e0       	ldi	r22, 0x06	; 6
     f3e:	c8 01       	movw	r24, r16
     f40:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     f44:	93 e0       	ldi	r25, 0x03	; 3
     f46:	88 ed       	ldi	r24, 0xD8	; 216
     f48:	08 b6       	in	r0, 0x38	; 56
     f4a:	18 be       	out	0x38, r1	; 56
     f4c:	84 bf       	out	0x34, r24	; 52
     f4e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     f52:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     f56:	81 fd       	sbrc	r24, 1
     f58:	fc cf       	rjmp	.-8      	; 0xf52 <_ZN9task_user3runEv+0x228>
     f5a:	08 be       	out	0x38, r0	; 56
     f5c:	ff cf       	rjmp	.-2      	; 0xf5c <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     f5e:	f8 01       	movw	r30, r16
     f60:	86 85       	ldd	r24, Z+14	; 0x0e
     f62:	97 85       	ldd	r25, Z+15	; 0x0f
     f64:	a0 89       	ldd	r26, Z+16	; 0x10
     f66:	b1 89       	ldd	r27, Z+17	; 0x11
     f68:	01 96       	adiw	r24, 0x01	; 1
     f6a:	a1 1d       	adc	r26, r1
     f6c:	b1 1d       	adc	r27, r1
     f6e:	86 87       	std	Z+14, r24	; 0x0e
     f70:	97 87       	std	Z+15, r25	; 0x0f
     f72:	a0 8b       	std	Z+16, r26	; 0x10
     f74:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     f76:	61 e0       	ldi	r22, 0x01	; 1
     f78:	70 e0       	ldi	r23, 0x00	; 0
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	0e 94 33 11 	call	0x2266	; 0x2266 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     f82:	f1 ce       	rjmp	.-542    	; 0xd66 <_ZN9task_user3runEv+0x3c>

00000f84 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     f84:	0f 93       	push	r16
     f86:	cf 93       	push	r28
     f88:	df 93       	push	r29
     f8a:	1f 92       	push	r1
     f8c:	cd b7       	in	r28, 0x3d	; 61
     f8e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
     f90:	2f b7       	in	r18, 0x3f	; 63
     f92:	29 83       	std	Y+1, r18	; 0x01
	cli();
     f94:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
     f96:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
     f98:	fc 01       	movw	r30, r24
     f9a:	08 ed       	ldi	r16, 0xD8	; 216
     f9c:	04 bf       	out	0x34, r16	; 52
     f9e:	60 83       	st	Z, r22

	SREG = saved_sreg;
     fa0:	89 81       	ldd	r24, Y+1	; 0x01
     fa2:	8f bf       	out	0x3f, r24	; 63
	#endif
}
     fa4:	0f 90       	pop	r0
     fa6:	df 91       	pop	r29
     fa8:	cf 91       	pop	r28
     faa:	0f 91       	pop	r16
     fac:	08 95       	ret

00000fae <_Z15config_SYSCLOCKv>:


// Configure the system clock
void config_SYSCLOCK()
{
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	1f 92       	push	r1
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
	uint8_t volatile saved_sreg = SREG;
     fb8:	8f b7       	in	r24, 0x3f	; 63
     fba:	89 83       	std	Y+1, r24	; 0x01
	cli();
     fbc:	f8 94       	cli
	OSC.XOSCCTRL = OSC_FRQRANGE_12TO16_gc | OSC_XOSCSEL_XTAL_16KCLK_gc;				// Configure the external clock frequency and configure startup time
     fbe:	e0 e5       	ldi	r30, 0x50	; 80
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
     fc2:	8b ec       	ldi	r24, 0xCB	; 203
     fc4:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL |= OSC_XOSCEN_bm;														// Enable the external clock
     fc6:	80 81       	ld	r24, Z
     fc8:	88 60       	ori	r24, 0x08	; 8
     fca:	80 83       	st	Z, r24
	do {} while((OSC.STATUS & (OSC_XOSCRDY_bm)) != (OSC_XOSCRDY_bm));				// Wait for a stable clock
     fcc:	81 81       	ldd	r24, Z+1	; 0x01
     fce:	83 ff       	sbrs	r24, 3
     fd0:	fd cf       	rjmp	.-6      	; 0xfcc <_Z15config_SYSCLOCKv+0x1e>
	OSC.PLLCTRL = OSC_PLLSRC_XOSC_gc | OSC_PLLFAC1_bm;								// Configure the PLL factor and divider and select external clock as source
     fd2:	e0 e5       	ldi	r30, 0x50	; 80
     fd4:	f0 e0       	ldi	r31, 0x00	; 0
     fd6:	82 ec       	ldi	r24, 0xC2	; 194
     fd8:	85 83       	std	Z+5, r24	; 0x05
	OSC.CTRL |= OSC_PLLEN_bm;														// Enable the PLL
     fda:	80 81       	ld	r24, Z
     fdc:	80 61       	ori	r24, 0x10	; 16
     fde:	80 83       	st	Z, r24
	do {} while((OSC.STATUS & (OSC_PLLRDY_bm)) != (OSC_PLLRDY_bm));				// Wait for a stable PLL clock
     fe0:	81 81       	ldd	r24, Z+1	; 0x01
     fe2:	84 ff       	sbrs	r24, 4
     fe4:	fd cf       	rjmp	.-6      	; 0xfe0 <_Z15config_SYSCLOCKv+0x32>

//	OSC.CTRL |= OSC_RC32MEN_bm;														// Enable the external clock
//	do {} while((OSC.STATUS & (OSC_RC32MRDY_bm)) != (OSC_RC32MRDY_bm));				// Wait for a stable clock
	
	
	uint8_t CLK_CTRL_TEMP = (CLK.CTRL & ~CLK_SCLKSEL_gm) | (CLK_SCLKSEL_PLL_gc);
     fe6:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	//CCP = 0xD8;
	//CLK.CTRL = CLK_CTRL_TEMP;
	CCPWrite(&(CLK.CTRL),CLK_CTRL_TEMP);
     fea:	68 7f       	andi	r22, 0xF8	; 248
     fec:	64 60       	ori	r22, 0x04	; 4
     fee:	80 e4       	ldi	r24, 0x40	; 64
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	0e 94 c2 07 	call	0xf84	; 0xf84 <_Z8CCPWritePVhh>
	OSC.CTRL &= ~(OSC_RC2MEN_bm);
     ff6:	e0 e5       	ldi	r30, 0x50	; 80
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	80 81       	ld	r24, Z
     ffc:	8e 7f       	andi	r24, 0xFE	; 254
     ffe:	80 83       	st	Z, r24
	SREG = saved_sreg;
    1000:	89 81       	ldd	r24, Y+1	; 0x01
    1002:	8f bf       	out	0x3f, r24	; 63
}
    1004:	0f 90       	pop	r0
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	08 95       	ret

0000100c <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1016:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    101a:	80 91 9a 20 	lds	r24, 0x209A	; 0x80209a <__data_end>
    101e:	81 11       	cpse	r24, r1
    1020:	1d c0       	rjmp	.+58     	; 0x105c <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1022:	af e9       	ldi	r26, 0x9F	; 159
    1024:	b0 e2       	ldi	r27, 0x20	; 32
    1026:	e3 ea       	ldi	r30, 0xA3	; 163
    1028:	f0 e2       	ldi	r31, 0x20	; 32
    102a:	ed 93       	st	X+, r30
    102c:	fc 93       	st	X, r31
    102e:	11 97       	sbiw	r26, 0x01	; 1
    1030:	12 96       	adiw	r26, 0x02	; 2
    1032:	1d 92       	st	X+, r1
    1034:	1c 92       	st	X, r1
    1036:	13 97       	sbiw	r26, 0x03	; 3
    1038:	ab e9       	ldi	r26, 0x9B	; 155
    103a:	b0 e2       	ldi	r27, 0x20	; 32
    103c:	8f ef       	ldi	r24, 0xFF	; 255
    103e:	9f e1       	ldi	r25, 0x1F	; 31
    1040:	12 96       	adiw	r26, 0x02	; 2
    1042:	8d 93       	st	X+, r24
    1044:	9c 93       	st	X, r25
    1046:	13 97       	sbiw	r26, 0x03	; 3
    1048:	1d 92       	st	X+, r1
    104a:	1c 92       	st	X, r1
    104c:	11 97       	sbiw	r26, 0x01	; 1
    104e:	82 83       	std	Z+2, r24	; 0x02
    1050:	93 83       	std	Z+3, r25	; 0x03
    1052:	a0 83       	st	Z, r26
    1054:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	80 93 9a 20 	sts	0x209A, r24	; 0x80209a <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    105c:	20 97       	sbiw	r28, 0x00	; 0
    105e:	09 f4       	brne	.+2      	; 0x1062 <pvPortMalloc+0x56>
    1060:	5f c0       	rjmp	.+190    	; 0x1120 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1062:	9e 01       	movw	r18, r28
    1064:	2b 5f       	subi	r18, 0xFB	; 251
    1066:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1068:	24 96       	adiw	r28, 0x04	; 4
    106a:	ce 3f       	cpi	r28, 0xFE	; 254
    106c:	df 41       	sbci	r29, 0x1F	; 31
    106e:	08 f0       	brcs	.+2      	; 0x1072 <pvPortMalloc+0x66>
    1070:	5a c0       	rjmp	.+180    	; 0x1126 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1072:	e0 91 9f 20 	lds	r30, 0x209F	; 0x80209f <xStart>
    1076:	f0 91 a0 20 	lds	r31, 0x20A0	; 0x8020a0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    107a:	af e9       	ldi	r26, 0x9F	; 159
    107c:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    107e:	02 c0       	rjmp	.+4      	; 0x1084 <pvPortMalloc+0x78>
    1080:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1082:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1084:	82 81       	ldd	r24, Z+2	; 0x02
    1086:	93 81       	ldd	r25, Z+3	; 0x03
    1088:	82 17       	cp	r24, r18
    108a:	93 07       	cpc	r25, r19
    108c:	20 f4       	brcc	.+8      	; 0x1096 <pvPortMalloc+0x8a>
    108e:	80 81       	ld	r24, Z
    1090:	91 81       	ldd	r25, Z+1	; 0x01
    1092:	00 97       	sbiw	r24, 0x00	; 0
    1094:	a9 f7       	brne	.-22     	; 0x1080 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1096:	c0 e2       	ldi	r28, 0x20	; 32
    1098:	eb 39       	cpi	r30, 0x9B	; 155
    109a:	fc 07       	cpc	r31, r28
    109c:	09 f4       	brne	.+2      	; 0x10a0 <pvPortMalloc+0x94>
    109e:	46 c0       	rjmp	.+140    	; 0x112c <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    10a0:	cd 91       	ld	r28, X+
    10a2:	dc 91       	ld	r29, X
    10a4:	11 97       	sbiw	r26, 0x01	; 1
    10a6:	8e 01       	movw	r16, r28
    10a8:	0b 5f       	subi	r16, 0xFB	; 251
    10aa:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    10ac:	80 81       	ld	r24, Z
    10ae:	91 81       	ldd	r25, Z+1	; 0x01
    10b0:	8d 93       	st	X+, r24
    10b2:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    10b4:	82 81       	ldd	r24, Z+2	; 0x02
    10b6:	93 81       	ldd	r25, Z+3	; 0x03
    10b8:	82 1b       	sub	r24, r18
    10ba:	93 0b       	sbc	r25, r19
    10bc:	8b 30       	cpi	r24, 0x0B	; 11
    10be:	91 05       	cpc	r25, r1
    10c0:	10 f1       	brcs	.+68     	; 0x1106 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    10c2:	bf 01       	movw	r22, r30
    10c4:	62 0f       	add	r22, r18
    10c6:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    10c8:	db 01       	movw	r26, r22
    10ca:	12 96       	adiw	r26, 0x02	; 2
    10cc:	8d 93       	st	X+, r24
    10ce:	9c 93       	st	X, r25
    10d0:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    10d2:	22 83       	std	Z+2, r18	; 0x02
    10d4:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    10d6:	12 96       	adiw	r26, 0x02	; 2
    10d8:	4d 91       	ld	r20, X+
    10da:	5c 91       	ld	r21, X
    10dc:	13 97       	sbiw	r26, 0x03	; 3
    10de:	8f e9       	ldi	r24, 0x9F	; 159
    10e0:	90 e2       	ldi	r25, 0x20	; 32
    10e2:	01 c0       	rjmp	.+2      	; 0x10e6 <pvPortMalloc+0xda>
    10e4:	cd 01       	movw	r24, r26
    10e6:	ec 01       	movw	r28, r24
    10e8:	a8 81       	ld	r26, Y
    10ea:	b9 81       	ldd	r27, Y+1	; 0x01
    10ec:	12 96       	adiw	r26, 0x02	; 2
    10ee:	2d 91       	ld	r18, X+
    10f0:	3c 91       	ld	r19, X
    10f2:	13 97       	sbiw	r26, 0x03	; 3
    10f4:	24 17       	cp	r18, r20
    10f6:	35 07       	cpc	r19, r21
    10f8:	a8 f3       	brcs	.-22     	; 0x10e4 <pvPortMalloc+0xd8>
    10fa:	eb 01       	movw	r28, r22
    10fc:	a8 83       	st	Y, r26
    10fe:	b9 83       	std	Y+1, r27	; 0x01
    1100:	dc 01       	movw	r26, r24
    1102:	6d 93       	st	X+, r22
    1104:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1106:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    110a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    110e:	22 81       	ldd	r18, Z+2	; 0x02
    1110:	33 81       	ldd	r19, Z+3	; 0x03
    1112:	82 1b       	sub	r24, r18
    1114:	93 0b       	sbc	r25, r19
    1116:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__DATA_REGION_ORIGIN__>
    111a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    111e:	08 c0       	rjmp	.+16     	; 0x1130 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1120:	00 e0       	ldi	r16, 0x00	; 0
    1122:	10 e0       	ldi	r17, 0x00	; 0
    1124:	05 c0       	rjmp	.+10     	; 0x1130 <pvPortMalloc+0x124>
    1126:	00 e0       	ldi	r16, 0x00	; 0
    1128:	10 e0       	ldi	r17, 0x00	; 0
    112a:	02 c0       	rjmp	.+4      	; 0x1130 <pvPortMalloc+0x124>
    112c:	00 e0       	ldi	r16, 0x00	; 0
    112e:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1130:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1134:	c8 01       	movw	r24, r16
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	08 95       	ret

00001140 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1140:	0f 93       	push	r16
    1142:	1f 93       	push	r17
    1144:	cf 93       	push	r28
    1146:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1148:	00 97       	sbiw	r24, 0x00	; 0
    114a:	41 f1       	breq	.+80     	; 0x119c <vPortFree+0x5c>
    114c:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    114e:	8c 01       	movw	r16, r24
    1150:	05 50       	subi	r16, 0x05	; 5
    1152:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1154:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1158:	f8 01       	movw	r30, r16
    115a:	42 81       	ldd	r20, Z+2	; 0x02
    115c:	53 81       	ldd	r21, Z+3	; 0x03
    115e:	af e9       	ldi	r26, 0x9F	; 159
    1160:	b0 e2       	ldi	r27, 0x20	; 32
    1162:	01 c0       	rjmp	.+2      	; 0x1166 <vPortFree+0x26>
    1164:	df 01       	movw	r26, r30
    1166:	ed 91       	ld	r30, X+
    1168:	fc 91       	ld	r31, X
    116a:	11 97       	sbiw	r26, 0x01	; 1
    116c:	22 81       	ldd	r18, Z+2	; 0x02
    116e:	33 81       	ldd	r19, Z+3	; 0x03
    1170:	24 17       	cp	r18, r20
    1172:	35 07       	cpc	r19, r21
    1174:	b8 f3       	brcs	.-18     	; 0x1164 <vPortFree+0x24>
    1176:	25 97       	sbiw	r28, 0x05	; 5
    1178:	e8 83       	st	Y, r30
    117a:	f9 83       	std	Y+1, r31	; 0x01
    117c:	0d 93       	st	X+, r16
    117e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1180:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    1184:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    1188:	8a 81       	ldd	r24, Y+2	; 0x02
    118a:	9b 81       	ldd	r25, Y+3	; 0x03
    118c:	82 0f       	add	r24, r18
    118e:	93 1f       	adc	r25, r19
    1190:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__DATA_REGION_ORIGIN__>
    1194:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
		}
		xTaskResumeAll();
    1198:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
	}
}
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	1f 91       	pop	r17
    11a2:	0f 91       	pop	r16
    11a4:	08 95       	ret

000011a6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    11a6:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    11aa:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    11ae:	08 95       	ret

000011b0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    11b0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    11b2:	03 96       	adiw	r24, 0x03	; 3
    11b4:	81 83       	std	Z+1, r24	; 0x01
    11b6:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    11b8:	4f ef       	ldi	r20, 0xFF	; 255
    11ba:	5f ef       	ldi	r21, 0xFF	; 255
    11bc:	ba 01       	movw	r22, r20
    11be:	43 83       	std	Z+3, r20	; 0x03
    11c0:	54 83       	std	Z+4, r21	; 0x04
    11c2:	65 83       	std	Z+5, r22	; 0x05
    11c4:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11c6:	87 83       	std	Z+7, r24	; 0x07
    11c8:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    11ca:	81 87       	std	Z+9, r24	; 0x09
    11cc:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    11ce:	10 82       	st	Z, r1
    11d0:	08 95       	ret

000011d2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    11d2:	fc 01       	movw	r30, r24
    11d4:	12 86       	std	Z+10, r1	; 0x0a
    11d6:	13 86       	std	Z+11, r1	; 0x0b
    11d8:	08 95       	ret

000011da <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	fc 01       	movw	r30, r24
    11e0:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    11e2:	21 81       	ldd	r18, Z+1	; 0x01
    11e4:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    11e6:	e9 01       	movw	r28, r18
    11e8:	8c 81       	ldd	r24, Y+4	; 0x04
    11ea:	9d 81       	ldd	r25, Y+5	; 0x05
    11ec:	14 96       	adiw	r26, 0x04	; 4
    11ee:	8d 93       	st	X+, r24
    11f0:	9c 93       	st	X, r25
    11f2:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    11f4:	81 81       	ldd	r24, Z+1	; 0x01
    11f6:	92 81       	ldd	r25, Z+2	; 0x02
    11f8:	16 96       	adiw	r26, 0x06	; 6
    11fa:	8d 93       	st	X+, r24
    11fc:	9c 93       	st	X, r25
    11fe:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1200:	8c 81       	ldd	r24, Y+4	; 0x04
    1202:	9d 81       	ldd	r25, Y+5	; 0x05
    1204:	ec 01       	movw	r28, r24
    1206:	6e 83       	std	Y+6, r22	; 0x06
    1208:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    120a:	e9 01       	movw	r28, r18
    120c:	6c 83       	std	Y+4, r22	; 0x04
    120e:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1210:	61 83       	std	Z+1, r22	; 0x01
    1212:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1214:	1a 96       	adiw	r26, 0x0a	; 10
    1216:	ed 93       	st	X+, r30
    1218:	fc 93       	st	X, r31
    121a:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    121c:	80 81       	ld	r24, Z
    121e:	8f 5f       	subi	r24, 0xFF	; 255
    1220:	80 83       	st	Z, r24
}
    1222:	df 91       	pop	r29
    1224:	cf 91       	pop	r28
    1226:	08 95       	ret

00001228 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1232:	08 81       	ld	r16, Y
    1234:	19 81       	ldd	r17, Y+1	; 0x01
    1236:	2a 81       	ldd	r18, Y+2	; 0x02
    1238:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    123a:	0f 3f       	cpi	r16, 0xFF	; 255
    123c:	4f ef       	ldi	r20, 0xFF	; 255
    123e:	14 07       	cpc	r17, r20
    1240:	24 07       	cpc	r18, r20
    1242:	34 07       	cpc	r19, r20
    1244:	31 f4       	brne	.+12     	; 0x1252 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1246:	dc 01       	movw	r26, r24
    1248:	19 96       	adiw	r26, 0x09	; 9
    124a:	ed 91       	ld	r30, X+
    124c:	fc 91       	ld	r31, X
    124e:	1a 97       	sbiw	r26, 0x0a	; 10
    1250:	1f c0       	rjmp	.+62     	; 0x1290 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1252:	fc 01       	movw	r30, r24
    1254:	33 96       	adiw	r30, 0x03	; 3
    1256:	dc 01       	movw	r26, r24
    1258:	17 96       	adiw	r26, 0x07	; 7
    125a:	4d 91       	ld	r20, X+
    125c:	5c 91       	ld	r21, X
    125e:	18 97       	sbiw	r26, 0x08	; 8
    1260:	da 01       	movw	r26, r20
    1262:	4d 91       	ld	r20, X+
    1264:	5d 91       	ld	r21, X+
    1266:	6d 91       	ld	r22, X+
    1268:	7c 91       	ld	r23, X
    126a:	04 17       	cp	r16, r20
    126c:	15 07       	cpc	r17, r21
    126e:	26 07       	cpc	r18, r22
    1270:	37 07       	cpc	r19, r23
    1272:	70 f0       	brcs	.+28     	; 0x1290 <vListInsert+0x68>
    1274:	04 80       	ldd	r0, Z+4	; 0x04
    1276:	f5 81       	ldd	r31, Z+5	; 0x05
    1278:	e0 2d       	mov	r30, r0
    127a:	a4 81       	ldd	r26, Z+4	; 0x04
    127c:	b5 81       	ldd	r27, Z+5	; 0x05
    127e:	4d 91       	ld	r20, X+
    1280:	5d 91       	ld	r21, X+
    1282:	6d 91       	ld	r22, X+
    1284:	7c 91       	ld	r23, X
    1286:	04 17       	cp	r16, r20
    1288:	15 07       	cpc	r17, r21
    128a:	26 07       	cpc	r18, r22
    128c:	37 07       	cpc	r19, r23
    128e:	90 f7       	brcc	.-28     	; 0x1274 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1290:	a4 81       	ldd	r26, Z+4	; 0x04
    1292:	b5 81       	ldd	r27, Z+5	; 0x05
    1294:	ac 83       	std	Y+4, r26	; 0x04
    1296:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1298:	16 96       	adiw	r26, 0x06	; 6
    129a:	cd 93       	st	X+, r28
    129c:	dc 93       	st	X, r29
    129e:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    12a0:	ee 83       	std	Y+6, r30	; 0x06
    12a2:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    12a4:	c4 83       	std	Z+4, r28	; 0x04
    12a6:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12a8:	8a 87       	std	Y+10, r24	; 0x0a
    12aa:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    12ac:	fc 01       	movw	r30, r24
    12ae:	20 81       	ld	r18, Z
    12b0:	2f 5f       	subi	r18, 0xFF	; 255
    12b2:	20 83       	st	Z, r18
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	08 95       	ret

000012be <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    12be:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    12c0:	a4 81       	ldd	r26, Z+4	; 0x04
    12c2:	b5 81       	ldd	r27, Z+5	; 0x05
    12c4:	86 81       	ldd	r24, Z+6	; 0x06
    12c6:	97 81       	ldd	r25, Z+7	; 0x07
    12c8:	16 96       	adiw	r26, 0x06	; 6
    12ca:	8d 93       	st	X+, r24
    12cc:	9c 93       	st	X, r25
    12ce:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    12d0:	a6 81       	ldd	r26, Z+6	; 0x06
    12d2:	b7 81       	ldd	r27, Z+7	; 0x07
    12d4:	84 81       	ldd	r24, Z+4	; 0x04
    12d6:	95 81       	ldd	r25, Z+5	; 0x05
    12d8:	14 96       	adiw	r26, 0x04	; 4
    12da:	8d 93       	st	X+, r24
    12dc:	9c 93       	st	X, r25
    12de:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    12e0:	a2 85       	ldd	r26, Z+10	; 0x0a
    12e2:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    12e4:	11 96       	adiw	r26, 0x01	; 1
    12e6:	8d 91       	ld	r24, X+
    12e8:	9c 91       	ld	r25, X
    12ea:	12 97       	sbiw	r26, 0x02	; 2
    12ec:	e8 17       	cp	r30, r24
    12ee:	f9 07       	cpc	r31, r25
    12f0:	31 f4       	brne	.+12     	; 0x12fe <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    12f2:	86 81       	ldd	r24, Z+6	; 0x06
    12f4:	97 81       	ldd	r25, Z+7	; 0x07
    12f6:	11 96       	adiw	r26, 0x01	; 1
    12f8:	8d 93       	st	X+, r24
    12fa:	9c 93       	st	X, r25
    12fc:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    12fe:	12 86       	std	Z+10, r1	; 0x0a
    1300:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1302:	8c 91       	ld	r24, X
    1304:	81 50       	subi	r24, 0x01	; 1
    1306:	8c 93       	st	X, r24
    1308:	08 95       	ret

0000130a <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    130a:	80 93 42 41 	sts	0x4142, r24	; 0x804142 <portStackTopForTask>
    130e:	90 93 43 41 	sts	0x4143, r25	; 0x804143 <portStackTopForTask+0x1>
    1312:	31 e1       	ldi	r19, 0x11	; 17
    1314:	fc 01       	movw	r30, r24
    1316:	30 83       	st	Z, r19
    1318:	31 97       	sbiw	r30, 0x01	; 1
    131a:	22 e2       	ldi	r18, 0x22	; 34
    131c:	20 83       	st	Z, r18
    131e:	31 97       	sbiw	r30, 0x01	; 1
    1320:	a3 e3       	ldi	r26, 0x33	; 51
    1322:	a0 83       	st	Z, r26
    1324:	31 97       	sbiw	r30, 0x01	; 1
    1326:	60 83       	st	Z, r22
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	70 83       	st	Z, r23
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	10 82       	st	Z, r1
    1330:	31 97       	sbiw	r30, 0x01	; 1
    1332:	10 82       	st	Z, r1
    1334:	31 97       	sbiw	r30, 0x01	; 1
    1336:	60 e8       	ldi	r22, 0x80	; 128
    1338:	60 83       	st	Z, r22
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	10 82       	st	Z, r1
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	10 82       	st	Z, r1
    1342:	31 97       	sbiw	r30, 0x01	; 1
    1344:	10 82       	st	Z, r1
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	62 e0       	ldi	r22, 0x02	; 2
    134a:	60 83       	st	Z, r22
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	63 e0       	ldi	r22, 0x03	; 3
    1350:	60 83       	st	Z, r22
    1352:	31 97       	sbiw	r30, 0x01	; 1
    1354:	64 e0       	ldi	r22, 0x04	; 4
    1356:	60 83       	st	Z, r22
    1358:	31 97       	sbiw	r30, 0x01	; 1
    135a:	65 e0       	ldi	r22, 0x05	; 5
    135c:	60 83       	st	Z, r22
    135e:	31 97       	sbiw	r30, 0x01	; 1
    1360:	66 e0       	ldi	r22, 0x06	; 6
    1362:	60 83       	st	Z, r22
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	67 e0       	ldi	r22, 0x07	; 7
    1368:	60 83       	st	Z, r22
    136a:	31 97       	sbiw	r30, 0x01	; 1
    136c:	68 e0       	ldi	r22, 0x08	; 8
    136e:	60 83       	st	Z, r22
    1370:	31 97       	sbiw	r30, 0x01	; 1
    1372:	69 e0       	ldi	r22, 0x09	; 9
    1374:	60 83       	st	Z, r22
    1376:	31 97       	sbiw	r30, 0x01	; 1
    1378:	60 e1       	ldi	r22, 0x10	; 16
    137a:	60 83       	st	Z, r22
    137c:	31 97       	sbiw	r30, 0x01	; 1
    137e:	30 83       	st	Z, r19
    1380:	31 97       	sbiw	r30, 0x01	; 1
    1382:	32 e1       	ldi	r19, 0x12	; 18
    1384:	30 83       	st	Z, r19
    1386:	31 97       	sbiw	r30, 0x01	; 1
    1388:	33 e1       	ldi	r19, 0x13	; 19
    138a:	30 83       	st	Z, r19
    138c:	31 97       	sbiw	r30, 0x01	; 1
    138e:	34 e1       	ldi	r19, 0x14	; 20
    1390:	30 83       	st	Z, r19
    1392:	31 97       	sbiw	r30, 0x01	; 1
    1394:	35 e1       	ldi	r19, 0x15	; 21
    1396:	30 83       	st	Z, r19
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	36 e1       	ldi	r19, 0x16	; 22
    139c:	30 83       	st	Z, r19
    139e:	31 97       	sbiw	r30, 0x01	; 1
    13a0:	37 e1       	ldi	r19, 0x17	; 23
    13a2:	30 83       	st	Z, r19
    13a4:	31 97       	sbiw	r30, 0x01	; 1
    13a6:	38 e1       	ldi	r19, 0x18	; 24
    13a8:	30 83       	st	Z, r19
    13aa:	31 97       	sbiw	r30, 0x01	; 1
    13ac:	39 e1       	ldi	r19, 0x19	; 25
    13ae:	30 83       	st	Z, r19
    13b0:	31 97       	sbiw	r30, 0x01	; 1
    13b2:	30 e2       	ldi	r19, 0x20	; 32
    13b4:	30 83       	st	Z, r19
    13b6:	31 97       	sbiw	r30, 0x01	; 1
    13b8:	31 e2       	ldi	r19, 0x21	; 33
    13ba:	30 83       	st	Z, r19
    13bc:	31 97       	sbiw	r30, 0x01	; 1
    13be:	20 83       	st	Z, r18
    13c0:	31 97       	sbiw	r30, 0x01	; 1
    13c2:	23 e2       	ldi	r18, 0x23	; 35
    13c4:	20 83       	st	Z, r18
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	40 83       	st	Z, r20
    13ca:	31 97       	sbiw	r30, 0x01	; 1
    13cc:	50 83       	st	Z, r21
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	26 e2       	ldi	r18, 0x26	; 38
    13d2:	20 83       	st	Z, r18
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	27 e2       	ldi	r18, 0x27	; 39
    13d8:	20 83       	st	Z, r18
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	28 e2       	ldi	r18, 0x28	; 40
    13de:	20 83       	st	Z, r18
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	29 e2       	ldi	r18, 0x29	; 41
    13e4:	20 83       	st	Z, r18
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	20 e3       	ldi	r18, 0x30	; 48
    13ea:	20 83       	st	Z, r18
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	21 e3       	ldi	r18, 0x31	; 49
    13f0:	20 83       	st	Z, r18
    13f2:	89 97       	sbiw	r24, 0x29	; 41
    13f4:	08 95       	ret

000013f6 <xPortStartScheduler>:
    13f6:	8c e7       	ldi	r24, 0x7C	; 124
    13f8:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    13fc:	8f ef       	ldi	r24, 0xFF	; 255
    13fe:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    1408:	90 e1       	ldi	r25, 0x10	; 16
    140a:	90 93 41 0a 	sts	0x0A41, r25	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    140e:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    1412:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    1416:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    141a:	cd 91       	ld	r28, X+
    141c:	cd bf       	out	0x3d, r28	; 61
    141e:	dd 91       	ld	r29, X+
    1420:	de bf       	out	0x3e, r29	; 62
    1422:	ff 91       	pop	r31
    1424:	ef 91       	pop	r30
    1426:	df 91       	pop	r29
    1428:	cf 91       	pop	r28
    142a:	bf 91       	pop	r27
    142c:	af 91       	pop	r26
    142e:	9f 91       	pop	r25
    1430:	8f 91       	pop	r24
    1432:	7f 91       	pop	r23
    1434:	6f 91       	pop	r22
    1436:	5f 91       	pop	r21
    1438:	4f 91       	pop	r20
    143a:	3f 91       	pop	r19
    143c:	2f 91       	pop	r18
    143e:	1f 91       	pop	r17
    1440:	0f 91       	pop	r16
    1442:	ff 90       	pop	r15
    1444:	ef 90       	pop	r14
    1446:	df 90       	pop	r13
    1448:	cf 90       	pop	r12
    144a:	bf 90       	pop	r11
    144c:	af 90       	pop	r10
    144e:	9f 90       	pop	r9
    1450:	8f 90       	pop	r8
    1452:	7f 90       	pop	r7
    1454:	6f 90       	pop	r6
    1456:	5f 90       	pop	r5
    1458:	4f 90       	pop	r4
    145a:	3f 90       	pop	r3
    145c:	2f 90       	pop	r2
    145e:	1f 90       	pop	r1
    1460:	0f 90       	pop	r0
    1462:	0c be       	out	0x3c, r0	; 60
    1464:	0f 90       	pop	r0
    1466:	0b be       	out	0x3b, r0	; 59
    1468:	0f 90       	pop	r0
    146a:	0f be       	out	0x3f, r0	; 63
    146c:	0f 90       	pop	r0
    146e:	08 95       	ret
    1470:	08 95       	ret

00001472 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1472:	0f 92       	push	r0
    1474:	0f b6       	in	r0, 0x3f	; 63
    1476:	f8 94       	cli
    1478:	0f 92       	push	r0
    147a:	0b b6       	in	r0, 0x3b	; 59
    147c:	0f 92       	push	r0
    147e:	0c b6       	in	r0, 0x3c	; 60
    1480:	0f 92       	push	r0
    1482:	1f 92       	push	r1
    1484:	11 24       	eor	r1, r1
    1486:	2f 92       	push	r2
    1488:	3f 92       	push	r3
    148a:	4f 92       	push	r4
    148c:	5f 92       	push	r5
    148e:	6f 92       	push	r6
    1490:	7f 92       	push	r7
    1492:	8f 92       	push	r8
    1494:	9f 92       	push	r9
    1496:	af 92       	push	r10
    1498:	bf 92       	push	r11
    149a:	cf 92       	push	r12
    149c:	df 92       	push	r13
    149e:	ef 92       	push	r14
    14a0:	ff 92       	push	r15
    14a2:	0f 93       	push	r16
    14a4:	1f 93       	push	r17
    14a6:	2f 93       	push	r18
    14a8:	3f 93       	push	r19
    14aa:	4f 93       	push	r20
    14ac:	5f 93       	push	r21
    14ae:	6f 93       	push	r22
    14b0:	7f 93       	push	r23
    14b2:	8f 93       	push	r24
    14b4:	9f 93       	push	r25
    14b6:	af 93       	push	r26
    14b8:	bf 93       	push	r27
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	ef 93       	push	r30
    14c0:	ff 93       	push	r31
    14c2:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    14c6:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    14ca:	0d b6       	in	r0, 0x3d	; 61
    14cc:	0d 92       	st	X+, r0
    14ce:	0e b6       	in	r0, 0x3e	; 62
    14d0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14d2:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14d6:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    14da:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    14de:	cd 91       	ld	r28, X+
    14e0:	cd bf       	out	0x3d, r28	; 61
    14e2:	dd 91       	ld	r29, X+
    14e4:	de bf       	out	0x3e, r29	; 62
    14e6:	ff 91       	pop	r31
    14e8:	ef 91       	pop	r30
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	bf 91       	pop	r27
    14f0:	af 91       	pop	r26
    14f2:	9f 91       	pop	r25
    14f4:	8f 91       	pop	r24
    14f6:	7f 91       	pop	r23
    14f8:	6f 91       	pop	r22
    14fa:	5f 91       	pop	r21
    14fc:	4f 91       	pop	r20
    14fe:	3f 91       	pop	r19
    1500:	2f 91       	pop	r18
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	ff 90       	pop	r15
    1508:	ef 90       	pop	r14
    150a:	df 90       	pop	r13
    150c:	cf 90       	pop	r12
    150e:	bf 90       	pop	r11
    1510:	af 90       	pop	r10
    1512:	9f 90       	pop	r9
    1514:	8f 90       	pop	r8
    1516:	7f 90       	pop	r7
    1518:	6f 90       	pop	r6
    151a:	5f 90       	pop	r5
    151c:	4f 90       	pop	r4
    151e:	3f 90       	pop	r3
    1520:	2f 90       	pop	r2
    1522:	1f 90       	pop	r1
    1524:	0f 90       	pop	r0
    1526:	0c be       	out	0x3c, r0	; 60
    1528:	0f 90       	pop	r0
    152a:	0b be       	out	0x3b, r0	; 59
    152c:	0f 90       	pop	r0
    152e:	0f be       	out	0x3f, r0	; 63
    1530:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1532:	08 95       	ret

00001534 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1534:	0f 92       	push	r0
    1536:	0f b6       	in	r0, 0x3f	; 63
    1538:	f8 94       	cli
    153a:	0f 92       	push	r0
    153c:	0b b6       	in	r0, 0x3b	; 59
    153e:	0f 92       	push	r0
    1540:	0c b6       	in	r0, 0x3c	; 60
    1542:	0f 92       	push	r0
    1544:	1f 92       	push	r1
    1546:	11 24       	eor	r1, r1
    1548:	2f 92       	push	r2
    154a:	3f 92       	push	r3
    154c:	4f 92       	push	r4
    154e:	5f 92       	push	r5
    1550:	6f 92       	push	r6
    1552:	7f 92       	push	r7
    1554:	8f 92       	push	r8
    1556:	9f 92       	push	r9
    1558:	af 92       	push	r10
    155a:	bf 92       	push	r11
    155c:	cf 92       	push	r12
    155e:	df 92       	push	r13
    1560:	ef 92       	push	r14
    1562:	ff 92       	push	r15
    1564:	0f 93       	push	r16
    1566:	1f 93       	push	r17
    1568:	2f 93       	push	r18
    156a:	3f 93       	push	r19
    156c:	4f 93       	push	r20
    156e:	5f 93       	push	r21
    1570:	6f 93       	push	r22
    1572:	7f 93       	push	r23
    1574:	8f 93       	push	r24
    1576:	9f 93       	push	r25
    1578:	af 93       	push	r26
    157a:	bf 93       	push	r27
    157c:	cf 93       	push	r28
    157e:	df 93       	push	r29
    1580:	ef 93       	push	r30
    1582:	ff 93       	push	r31
    1584:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    1588:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    158c:	0d b6       	in	r0, 0x3d	; 61
    158e:	0d 92       	st	X+, r0
    1590:	0e b6       	in	r0, 0x3e	; 62
    1592:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1594:	0e 94 43 0f 	call	0x1e86	; 0x1e86 <vTaskIncrementTick>
	vTaskSwitchContext();
    1598:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    159c:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    15a0:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    15a4:	cd 91       	ld	r28, X+
    15a6:	cd bf       	out	0x3d, r28	; 61
    15a8:	dd 91       	ld	r29, X+
    15aa:	de bf       	out	0x3e, r29	; 62
    15ac:	ff 91       	pop	r31
    15ae:	ef 91       	pop	r30
    15b0:	df 91       	pop	r29
    15b2:	cf 91       	pop	r28
    15b4:	bf 91       	pop	r27
    15b6:	af 91       	pop	r26
    15b8:	9f 91       	pop	r25
    15ba:	8f 91       	pop	r24
    15bc:	7f 91       	pop	r23
    15be:	6f 91       	pop	r22
    15c0:	5f 91       	pop	r21
    15c2:	4f 91       	pop	r20
    15c4:	3f 91       	pop	r19
    15c6:	2f 91       	pop	r18
    15c8:	1f 91       	pop	r17
    15ca:	0f 91       	pop	r16
    15cc:	ff 90       	pop	r15
    15ce:	ef 90       	pop	r14
    15d0:	df 90       	pop	r13
    15d2:	cf 90       	pop	r12
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	9f 90       	pop	r9
    15da:	8f 90       	pop	r8
    15dc:	7f 90       	pop	r7
    15de:	6f 90       	pop	r6
    15e0:	5f 90       	pop	r5
    15e2:	4f 90       	pop	r4
    15e4:	3f 90       	pop	r3
    15e6:	2f 90       	pop	r2
    15e8:	1f 90       	pop	r1
    15ea:	0f 90       	pop	r0
    15ec:	0c be       	out	0x3c, r0	; 60
    15ee:	0f 90       	pop	r0
    15f0:	0b be       	out	0x3b, r0	; 59
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15f8:	08 95       	ret

000015fa <__vector_55>:
void RT_VECT (void)
{
	#if (RT_VECT == TCD0_CCA_vect)
		static uint16_t compare_interval = (uint16_t)(configCPU_CLOCK_HZ / (configTICK_RATE_HZ 
						 * portCLOCK_PRESCALER)) - 1;
		TCD0.CCA += compare_interval;
    15fa:	e0 e0       	ldi	r30, 0x00	; 0
    15fc:	f9 e0       	ldi	r31, 0x09	; 9
    15fe:	80 a5       	ldd	r24, Z+40	; 0x28
    1600:	91 a5       	ldd	r25, Z+41	; 0x29
    1602:	81 50       	subi	r24, 0x01	; 1
    1604:	93 48       	sbci	r25, 0x83	; 131
    1606:	80 a7       	std	Z+40, r24	; 0x28
    1608:	91 a7       	std	Z+41, r25	; 0x29
	#endif
	
	
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    160a:	0e 94 9a 0a 	call	0x1534	; 0x1534 <vPortYieldFromTick>
		asm volatile ( "reti" );
    160e:	18 95       	reti

00001610 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
    1614:	ec 01       	movw	r28, r24
    1616:	88 a1       	ldd	r24, Y+32	; 0x20
    1618:	81 11       	cpse	r24, r1
    161a:	0b c0       	rjmp	.+22     	; 0x1632 <prvCopyDataToQueue+0x22>
    161c:	88 81       	ld	r24, Y
    161e:	99 81       	ldd	r25, Y+1	; 0x01
    1620:	89 2b       	or	r24, r25
    1622:	e1 f5       	brne	.+120    	; 0x169c <prvCopyDataToQueue+0x8c>
    1624:	8a 81       	ldd	r24, Y+2	; 0x02
    1626:	9b 81       	ldd	r25, Y+3	; 0x03
    1628:	0e 94 1c 13 	call	0x2638	; 0x2638 <vTaskPriorityDisinherit>
    162c:	1a 82       	std	Y+2, r1	; 0x02
    162e:	1b 82       	std	Y+3, r1	; 0x03
    1630:	35 c0       	rjmp	.+106    	; 0x169c <prvCopyDataToQueue+0x8c>
    1632:	41 11       	cpse	r20, r1
    1634:	17 c0       	rjmp	.+46     	; 0x1664 <prvCopyDataToQueue+0x54>
    1636:	48 2f       	mov	r20, r24
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	8c 81       	ldd	r24, Y+4	; 0x04
    163c:	9d 81       	ldd	r25, Y+5	; 0x05
    163e:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <memcpy>
    1642:	28 a1       	ldd	r18, Y+32	; 0x20
    1644:	8c 81       	ldd	r24, Y+4	; 0x04
    1646:	9d 81       	ldd	r25, Y+5	; 0x05
    1648:	82 0f       	add	r24, r18
    164a:	91 1d       	adc	r25, r1
    164c:	8c 83       	std	Y+4, r24	; 0x04
    164e:	9d 83       	std	Y+5, r25	; 0x05
    1650:	2a 81       	ldd	r18, Y+2	; 0x02
    1652:	3b 81       	ldd	r19, Y+3	; 0x03
    1654:	82 17       	cp	r24, r18
    1656:	93 07       	cpc	r25, r19
    1658:	08 f1       	brcs	.+66     	; 0x169c <prvCopyDataToQueue+0x8c>
    165a:	88 81       	ld	r24, Y
    165c:	99 81       	ldd	r25, Y+1	; 0x01
    165e:	8c 83       	std	Y+4, r24	; 0x04
    1660:	9d 83       	std	Y+5, r25	; 0x05
    1662:	1c c0       	rjmp	.+56     	; 0x169c <prvCopyDataToQueue+0x8c>
    1664:	48 2f       	mov	r20, r24
    1666:	50 e0       	ldi	r21, 0x00	; 0
    1668:	8e 81       	ldd	r24, Y+6	; 0x06
    166a:	9f 81       	ldd	r25, Y+7	; 0x07
    166c:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <memcpy>
    1670:	88 a1       	ldd	r24, Y+32	; 0x20
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	91 95       	neg	r25
    1676:	81 95       	neg	r24
    1678:	91 09       	sbc	r25, r1
    167a:	2e 81       	ldd	r18, Y+6	; 0x06
    167c:	3f 81       	ldd	r19, Y+7	; 0x07
    167e:	28 0f       	add	r18, r24
    1680:	39 1f       	adc	r19, r25
    1682:	2e 83       	std	Y+6, r18	; 0x06
    1684:	3f 83       	std	Y+7, r19	; 0x07
    1686:	48 81       	ld	r20, Y
    1688:	59 81       	ldd	r21, Y+1	; 0x01
    168a:	24 17       	cp	r18, r20
    168c:	35 07       	cpc	r19, r21
    168e:	30 f4       	brcc	.+12     	; 0x169c <prvCopyDataToQueue+0x8c>
    1690:	2a 81       	ldd	r18, Y+2	; 0x02
    1692:	3b 81       	ldd	r19, Y+3	; 0x03
    1694:	82 0f       	add	r24, r18
    1696:	93 1f       	adc	r25, r19
    1698:	8e 83       	std	Y+6, r24	; 0x06
    169a:	9f 83       	std	Y+7, r25	; 0x07
    169c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    169e:	8f 5f       	subi	r24, 0xFF	; 255
    16a0:	8e 8f       	std	Y+30, r24	; 0x1e
    16a2:	df 91       	pop	r29
    16a4:	cf 91       	pop	r28
    16a6:	08 95       	ret

000016a8 <prvCopyDataFromQueue>:
    16a8:	fc 01       	movw	r30, r24
    16aa:	80 81       	ld	r24, Z
    16ac:	91 81       	ldd	r25, Z+1	; 0x01
    16ae:	00 97       	sbiw	r24, 0x00	; 0
    16b0:	a1 f0       	breq	.+40     	; 0x16da <prvCopyDataFromQueue+0x32>
    16b2:	40 a1       	ldd	r20, Z+32	; 0x20
    16b4:	50 e0       	ldi	r21, 0x00	; 0
    16b6:	26 81       	ldd	r18, Z+6	; 0x06
    16b8:	37 81       	ldd	r19, Z+7	; 0x07
    16ba:	24 0f       	add	r18, r20
    16bc:	35 1f       	adc	r19, r21
    16be:	26 83       	std	Z+6, r18	; 0x06
    16c0:	37 83       	std	Z+7, r19	; 0x07
    16c2:	a2 81       	ldd	r26, Z+2	; 0x02
    16c4:	b3 81       	ldd	r27, Z+3	; 0x03
    16c6:	2a 17       	cp	r18, r26
    16c8:	3b 07       	cpc	r19, r27
    16ca:	10 f0       	brcs	.+4      	; 0x16d0 <prvCopyDataFromQueue+0x28>
    16cc:	86 83       	std	Z+6, r24	; 0x06
    16ce:	97 83       	std	Z+7, r25	; 0x07
    16d0:	cb 01       	movw	r24, r22
    16d2:	66 81       	ldd	r22, Z+6	; 0x06
    16d4:	77 81       	ldd	r23, Z+7	; 0x07
    16d6:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <memcpy>
    16da:	08 95       	ret

000016dc <prvUnlockQueue>:
    16dc:	0f 93       	push	r16
    16de:	1f 93       	push	r17
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	ec 01       	movw	r28, r24
    16e6:	0f b6       	in	r0, 0x3f	; 63
    16e8:	f8 94       	cli
    16ea:	0f 92       	push	r0
    16ec:	8a a1       	ldd	r24, Y+34	; 0x22
    16ee:	18 16       	cp	r1, r24
    16f0:	b4 f4       	brge	.+44     	; 0x171e <prvUnlockQueue+0x42>
    16f2:	8b 89       	ldd	r24, Y+19	; 0x13
    16f4:	81 11       	cpse	r24, r1
    16f6:	05 c0       	rjmp	.+10     	; 0x1702 <prvUnlockQueue+0x26>
    16f8:	12 c0       	rjmp	.+36     	; 0x171e <prvUnlockQueue+0x42>
    16fa:	8b 89       	ldd	r24, Y+19	; 0x13
    16fc:	81 11       	cpse	r24, r1
    16fe:	04 c0       	rjmp	.+8      	; 0x1708 <prvUnlockQueue+0x2c>
    1700:	0e c0       	rjmp	.+28     	; 0x171e <prvUnlockQueue+0x42>
    1702:	8e 01       	movw	r16, r28
    1704:	0d 5e       	subi	r16, 0xED	; 237
    1706:	1f 4f       	sbci	r17, 0xFF	; 255
    1708:	c8 01       	movw	r24, r16
    170a:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <xTaskRemoveFromEventList>
    170e:	81 11       	cpse	r24, r1
    1710:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskMissedYield>
    1714:	8a a1       	ldd	r24, Y+34	; 0x22
    1716:	81 50       	subi	r24, 0x01	; 1
    1718:	8a a3       	std	Y+34, r24	; 0x22
    171a:	18 16       	cp	r1, r24
    171c:	74 f3       	brlt	.-36     	; 0x16fa <prvUnlockQueue+0x1e>
    171e:	8f ef       	ldi	r24, 0xFF	; 255
    1720:	8a a3       	std	Y+34, r24	; 0x22
    1722:	0f 90       	pop	r0
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
    172c:	89 a1       	ldd	r24, Y+33	; 0x21
    172e:	18 16       	cp	r1, r24
    1730:	b4 f4       	brge	.+44     	; 0x175e <prvUnlockQueue+0x82>
    1732:	88 85       	ldd	r24, Y+8	; 0x08
    1734:	81 11       	cpse	r24, r1
    1736:	05 c0       	rjmp	.+10     	; 0x1742 <prvUnlockQueue+0x66>
    1738:	12 c0       	rjmp	.+36     	; 0x175e <prvUnlockQueue+0x82>
    173a:	88 85       	ldd	r24, Y+8	; 0x08
    173c:	81 11       	cpse	r24, r1
    173e:	04 c0       	rjmp	.+8      	; 0x1748 <prvUnlockQueue+0x6c>
    1740:	0e c0       	rjmp	.+28     	; 0x175e <prvUnlockQueue+0x82>
    1742:	8e 01       	movw	r16, r28
    1744:	08 5f       	subi	r16, 0xF8	; 248
    1746:	1f 4f       	sbci	r17, 0xFF	; 255
    1748:	c8 01       	movw	r24, r16
    174a:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <xTaskRemoveFromEventList>
    174e:	81 11       	cpse	r24, r1
    1750:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskMissedYield>
    1754:	89 a1       	ldd	r24, Y+33	; 0x21
    1756:	81 50       	subi	r24, 0x01	; 1
    1758:	89 a3       	std	Y+33, r24	; 0x21
    175a:	18 16       	cp	r1, r24
    175c:	74 f3       	brlt	.-36     	; 0x173a <prvUnlockQueue+0x5e>
    175e:	8f ef       	ldi	r24, 0xFF	; 255
    1760:	89 a3       	std	Y+33, r24	; 0x21
    1762:	0f 90       	pop	r0
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	08 95       	ret

00001770 <xQueueGenericReset>:
    1770:	1f 93       	push	r17
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
    1776:	61 30       	cpi	r22, 0x01	; 1
    1778:	59 f0       	breq	.+22     	; 0x1790 <xQueueGenericReset+0x20>
    177a:	fc 01       	movw	r30, r24
    177c:	23 89       	ldd	r18, Z+19	; 0x13
    177e:	30 85       	ldd	r19, Z+8	; 0x08
    1780:	31 11       	cpse	r19, r1
    1782:	2c c0       	rjmp	.+88     	; 0x17dc <xQueueGenericReset+0x6c>
    1784:	11 e0       	ldi	r17, 0x01	; 1
    1786:	21 11       	cpse	r18, r1
    1788:	10 e0       	ldi	r17, 0x00	; 0
    178a:	21 11       	cpse	r18, r1
    178c:	28 c0       	rjmp	.+80     	; 0x17de <xQueueGenericReset+0x6e>
    178e:	01 c0       	rjmp	.+2      	; 0x1792 <xQueueGenericReset+0x22>
    1790:	11 e0       	ldi	r17, 0x01	; 1
    1792:	ec 01       	movw	r28, r24
    1794:	48 81       	ld	r20, Y
    1796:	59 81       	ldd	r21, Y+1	; 0x01
    1798:	28 a1       	ldd	r18, Y+32	; 0x20
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    179e:	62 9f       	mul	r22, r18
    17a0:	c0 01       	movw	r24, r0
    17a2:	63 9f       	mul	r22, r19
    17a4:	90 0d       	add	r25, r0
    17a6:	11 24       	eor	r1, r1
    17a8:	ba 01       	movw	r22, r20
    17aa:	68 0f       	add	r22, r24
    17ac:	79 1f       	adc	r23, r25
    17ae:	6a 83       	std	Y+2, r22	; 0x02
    17b0:	7b 83       	std	Y+3, r23	; 0x03
    17b2:	1e 8e       	std	Y+30, r1	; 0x1e
    17b4:	4c 83       	std	Y+4, r20	; 0x04
    17b6:	5d 83       	std	Y+5, r21	; 0x05
    17b8:	82 1b       	sub	r24, r18
    17ba:	93 0b       	sbc	r25, r19
    17bc:	84 0f       	add	r24, r20
    17be:	95 1f       	adc	r25, r21
    17c0:	8e 83       	std	Y+6, r24	; 0x06
    17c2:	9f 83       	std	Y+7, r25	; 0x07
    17c4:	8f ef       	ldi	r24, 0xFF	; 255
    17c6:	89 a3       	std	Y+33, r24	; 0x21
    17c8:	8a a3       	std	Y+34, r24	; 0x22
    17ca:	ce 01       	movw	r24, r28
    17cc:	08 96       	adiw	r24, 0x08	; 8
    17ce:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    17d2:	ce 01       	movw	r24, r28
    17d4:	43 96       	adiw	r24, 0x13	; 19
    17d6:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    17da:	01 c0       	rjmp	.+2      	; 0x17de <xQueueGenericReset+0x6e>
    17dc:	10 e0       	ldi	r17, 0x00	; 0
    17de:	81 2f       	mov	r24, r17
    17e0:	df 91       	pop	r29
    17e2:	cf 91       	pop	r28
    17e4:	1f 91       	pop	r17
    17e6:	08 95       	ret

000017e8 <xQueueGenericCreate>:
    17e8:	0f 93       	push	r16
    17ea:	1f 93       	push	r17
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	88 23       	and	r24, r24
    17f2:	01 f1       	breq	.+64     	; 0x1834 <xQueueGenericCreate+0x4c>
    17f4:	06 2f       	mov	r16, r22
    17f6:	18 2f       	mov	r17, r24
    17f8:	83 e2       	ldi	r24, 0x23	; 35
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	0e 94 06 08 	call	0x100c	; 0x100c <pvPortMalloc>
    1800:	ec 01       	movw	r28, r24
    1802:	89 2b       	or	r24, r25
    1804:	c9 f0       	breq	.+50     	; 0x1838 <xQueueGenericCreate+0x50>
    1806:	10 9f       	mul	r17, r16
    1808:	c0 01       	movw	r24, r0
    180a:	11 24       	eor	r1, r1
    180c:	01 96       	adiw	r24, 0x01	; 1
    180e:	0e 94 06 08 	call	0x100c	; 0x100c <pvPortMalloc>
    1812:	88 83       	st	Y, r24
    1814:	99 83       	std	Y+1, r25	; 0x01
    1816:	89 2b       	or	r24, r25
    1818:	39 f0       	breq	.+14     	; 0x1828 <xQueueGenericCreate+0x40>
    181a:	1f 8f       	std	Y+31, r17	; 0x1f
    181c:	08 a3       	std	Y+32, r16	; 0x20
    181e:	61 e0       	ldi	r22, 0x01	; 1
    1820:	ce 01       	movw	r24, r28
    1822:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xQueueGenericReset>
    1826:	08 c0       	rjmp	.+16     	; 0x1838 <xQueueGenericCreate+0x50>
    1828:	ce 01       	movw	r24, r28
    182a:	0e 94 a0 08 	call	0x1140	; 0x1140 <vPortFree>
    182e:	c0 e0       	ldi	r28, 0x00	; 0
    1830:	d0 e0       	ldi	r29, 0x00	; 0
    1832:	02 c0       	rjmp	.+4      	; 0x1838 <xQueueGenericCreate+0x50>
    1834:	c0 e0       	ldi	r28, 0x00	; 0
    1836:	d0 e0       	ldi	r29, 0x00	; 0
    1838:	ce 01       	movw	r24, r28
    183a:	df 91       	pop	r29
    183c:	cf 91       	pop	r28
    183e:	1f 91       	pop	r17
    1840:	0f 91       	pop	r16
    1842:	08 95       	ret

00001844 <xQueueGenericSend>:
    1844:	af 92       	push	r10
    1846:	bf 92       	push	r11
    1848:	cf 92       	push	r12
    184a:	df 92       	push	r13
    184c:	ef 92       	push	r14
    184e:	ff 92       	push	r15
    1850:	0f 93       	push	r16
    1852:	1f 93       	push	r17
    1854:	cf 93       	push	r28
    1856:	df 93       	push	r29
    1858:	cd b7       	in	r28, 0x3d	; 61
    185a:	de b7       	in	r29, 0x3e	; 62
    185c:	29 97       	sbiw	r28, 0x09	; 9
    185e:	cd bf       	out	0x3d, r28	; 61
    1860:	de bf       	out	0x3e, r29	; 62
    1862:	7c 01       	movw	r14, r24
    1864:	5b 01       	movw	r10, r22
    1866:	2e 83       	std	Y+6, r18	; 0x06
    1868:	3f 83       	std	Y+7, r19	; 0x07
    186a:	48 87       	std	Y+8, r20	; 0x08
    186c:	59 87       	std	Y+9, r21	; 0x09
    186e:	10 e0       	ldi	r17, 0x00	; 0
    1870:	6c 01       	movw	r12, r24
    1872:	88 e0       	ldi	r24, 0x08	; 8
    1874:	c8 0e       	add	r12, r24
    1876:	d1 1c       	adc	r13, r1
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
    187e:	f7 01       	movw	r30, r14
    1880:	96 8d       	ldd	r25, Z+30	; 0x1e
    1882:	87 8d       	ldd	r24, Z+31	; 0x1f
    1884:	98 17       	cp	r25, r24
    1886:	a8 f4       	brcc	.+42     	; 0x18b2 <xQueueGenericSend+0x6e>
    1888:	40 2f       	mov	r20, r16
    188a:	b5 01       	movw	r22, r10
    188c:	c7 01       	movw	r24, r14
    188e:	0e 94 08 0b 	call	0x1610	; 0x1610 <prvCopyDataToQueue>
    1892:	f7 01       	movw	r30, r14
    1894:	83 89       	ldd	r24, Z+19	; 0x13
    1896:	88 23       	and	r24, r24
    1898:	41 f0       	breq	.+16     	; 0x18aa <xQueueGenericSend+0x66>
    189a:	c7 01       	movw	r24, r14
    189c:	43 96       	adiw	r24, 0x13	; 19
    189e:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <xTaskRemoveFromEventList>
    18a2:	81 30       	cpi	r24, 0x01	; 1
    18a4:	11 f4       	brne	.+4      	; 0x18aa <xQueueGenericSend+0x66>
    18a6:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    18aa:	0f 90       	pop	r0
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	56 c0       	rjmp	.+172    	; 0x195e <xQueueGenericSend+0x11a>
    18b2:	8e 81       	ldd	r24, Y+6	; 0x06
    18b4:	9f 81       	ldd	r25, Y+7	; 0x07
    18b6:	a8 85       	ldd	r26, Y+8	; 0x08
    18b8:	b9 85       	ldd	r27, Y+9	; 0x09
    18ba:	89 2b       	or	r24, r25
    18bc:	8a 2b       	or	r24, r26
    18be:	8b 2b       	or	r24, r27
    18c0:	21 f4       	brne	.+8      	; 0x18ca <xQueueGenericSend+0x86>
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63
    18c6:	80 e0       	ldi	r24, 0x00	; 0
    18c8:	4a c0       	rjmp	.+148    	; 0x195e <xQueueGenericSend+0x11a>
    18ca:	11 11       	cpse	r17, r1
    18cc:	05 c0       	rjmp	.+10     	; 0x18d8 <xQueueGenericSend+0x94>
    18ce:	ce 01       	movw	r24, r28
    18d0:	01 96       	adiw	r24, 0x01	; 1
    18d2:	0e 94 27 12 	call	0x244e	; 0x244e <vTaskSetTimeOutState>
    18d6:	11 e0       	ldi	r17, 0x01	; 1
    18d8:	0f 90       	pop	r0
    18da:	0f be       	out	0x3f, r0	; 63
    18dc:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskSuspendAll>
    18e0:	0f b6       	in	r0, 0x3f	; 63
    18e2:	f8 94       	cli
    18e4:	0f 92       	push	r0
    18e6:	f7 01       	movw	r30, r14
    18e8:	81 a1       	ldd	r24, Z+33	; 0x21
    18ea:	8f 3f       	cpi	r24, 0xFF	; 255
    18ec:	09 f4       	brne	.+2      	; 0x18f0 <xQueueGenericSend+0xac>
    18ee:	11 a2       	std	Z+33, r1	; 0x21
    18f0:	f7 01       	movw	r30, r14
    18f2:	82 a1       	ldd	r24, Z+34	; 0x22
    18f4:	8f 3f       	cpi	r24, 0xFF	; 255
    18f6:	09 f4       	brne	.+2      	; 0x18fa <xQueueGenericSend+0xb6>
    18f8:	12 a2       	std	Z+34, r1	; 0x22
    18fa:	0f 90       	pop	r0
    18fc:	0f be       	out	0x3f, r0	; 63
    18fe:	be 01       	movw	r22, r28
    1900:	6a 5f       	subi	r22, 0xFA	; 250
    1902:	7f 4f       	sbci	r23, 0xFF	; 255
    1904:	ce 01       	movw	r24, r28
    1906:	01 96       	adiw	r24, 0x01	; 1
    1908:	0e 94 38 12 	call	0x2470	; 0x2470 <xTaskCheckForTimeOut>
    190c:	81 11       	cpse	r24, r1
    190e:	21 c0       	rjmp	.+66     	; 0x1952 <xQueueGenericSend+0x10e>
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
    1916:	f7 01       	movw	r30, r14
    1918:	96 8d       	ldd	r25, Z+30	; 0x1e
    191a:	0f 90       	pop	r0
    191c:	0f be       	out	0x3f, r0	; 63
    191e:	87 8d       	ldd	r24, Z+31	; 0x1f
    1920:	98 13       	cpse	r25, r24
    1922:	11 c0       	rjmp	.+34     	; 0x1946 <xQueueGenericSend+0x102>
    1924:	4e 81       	ldd	r20, Y+6	; 0x06
    1926:	5f 81       	ldd	r21, Y+7	; 0x07
    1928:	68 85       	ldd	r22, Y+8	; 0x08
    192a:	79 85       	ldd	r23, Y+9	; 0x09
    192c:	c6 01       	movw	r24, r12
    192e:	0e 94 be 11 	call	0x237c	; 0x237c <vTaskPlaceOnEventList>
    1932:	c7 01       	movw	r24, r14
    1934:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <prvUnlockQueue>
    1938:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    193c:	81 11       	cpse	r24, r1
    193e:	9c cf       	rjmp	.-200    	; 0x1878 <xQueueGenericSend+0x34>
    1940:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    1944:	99 cf       	rjmp	.-206    	; 0x1878 <xQueueGenericSend+0x34>
    1946:	c7 01       	movw	r24, r14
    1948:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <prvUnlockQueue>
    194c:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1950:	93 cf       	rjmp	.-218    	; 0x1878 <xQueueGenericSend+0x34>
    1952:	c7 01       	movw	r24, r14
    1954:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <prvUnlockQueue>
    1958:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    195c:	80 e0       	ldi	r24, 0x00	; 0
    195e:	29 96       	adiw	r28, 0x09	; 9
    1960:	cd bf       	out	0x3d, r28	; 61
    1962:	de bf       	out	0x3e, r29	; 62
    1964:	df 91       	pop	r29
    1966:	cf 91       	pop	r28
    1968:	1f 91       	pop	r17
    196a:	0f 91       	pop	r16
    196c:	ff 90       	pop	r15
    196e:	ef 90       	pop	r14
    1970:	df 90       	pop	r13
    1972:	cf 90       	pop	r12
    1974:	bf 90       	pop	r11
    1976:	af 90       	pop	r10
    1978:	08 95       	ret

0000197a <xQueueGenericReceive>:
    197a:	af 92       	push	r10
    197c:	bf 92       	push	r11
    197e:	cf 92       	push	r12
    1980:	df 92       	push	r13
    1982:	ef 92       	push	r14
    1984:	ff 92       	push	r15
    1986:	0f 93       	push	r16
    1988:	1f 93       	push	r17
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
    1992:	29 97       	sbiw	r28, 0x09	; 9
    1994:	cd bf       	out	0x3d, r28	; 61
    1996:	de bf       	out	0x3e, r29	; 62
    1998:	7c 01       	movw	r14, r24
    199a:	5b 01       	movw	r10, r22
    199c:	2e 83       	std	Y+6, r18	; 0x06
    199e:	3f 83       	std	Y+7, r19	; 0x07
    19a0:	48 87       	std	Y+8, r20	; 0x08
    19a2:	59 87       	std	Y+9, r21	; 0x09
    19a4:	10 e0       	ldi	r17, 0x00	; 0
    19a6:	6c 01       	movw	r12, r24
    19a8:	83 e1       	ldi	r24, 0x13	; 19
    19aa:	c8 0e       	add	r12, r24
    19ac:	d1 1c       	adc	r13, r1
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	0f 92       	push	r0
    19b4:	f7 01       	movw	r30, r14
    19b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    19b8:	88 23       	and	r24, r24
    19ba:	99 f1       	breq	.+102    	; 0x1a22 <xQueueGenericReceive+0xa8>
    19bc:	c6 80       	ldd	r12, Z+6	; 0x06
    19be:	d7 80       	ldd	r13, Z+7	; 0x07
    19c0:	b5 01       	movw	r22, r10
    19c2:	c7 01       	movw	r24, r14
    19c4:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <prvCopyDataFromQueue>
    19c8:	01 11       	cpse	r16, r1
    19ca:	1a c0       	rjmp	.+52     	; 0x1a00 <xQueueGenericReceive+0x86>
    19cc:	f7 01       	movw	r30, r14
    19ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    19d0:	81 50       	subi	r24, 0x01	; 1
    19d2:	86 8f       	std	Z+30, r24	; 0x1e
    19d4:	80 81       	ld	r24, Z
    19d6:	91 81       	ldd	r25, Z+1	; 0x01
    19d8:	89 2b       	or	r24, r25
    19da:	29 f4       	brne	.+10     	; 0x19e6 <xQueueGenericReceive+0x6c>
    19dc:	0e 94 c2 12 	call	0x2584	; 0x2584 <xTaskGetCurrentTaskHandle>
    19e0:	f7 01       	movw	r30, r14
    19e2:	82 83       	std	Z+2, r24	; 0x02
    19e4:	93 83       	std	Z+3, r25	; 0x03
    19e6:	f7 01       	movw	r30, r14
    19e8:	80 85       	ldd	r24, Z+8	; 0x08
    19ea:	88 23       	and	r24, r24
    19ec:	b1 f0       	breq	.+44     	; 0x1a1a <xQueueGenericReceive+0xa0>
    19ee:	c7 01       	movw	r24, r14
    19f0:	08 96       	adiw	r24, 0x08	; 8
    19f2:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <xTaskRemoveFromEventList>
    19f6:	81 30       	cpi	r24, 0x01	; 1
    19f8:	81 f4       	brne	.+32     	; 0x1a1a <xQueueGenericReceive+0xa0>
    19fa:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    19fe:	0d c0       	rjmp	.+26     	; 0x1a1a <xQueueGenericReceive+0xa0>
    1a00:	f7 01       	movw	r30, r14
    1a02:	c6 82       	std	Z+6, r12	; 0x06
    1a04:	d7 82       	std	Z+7, r13	; 0x07
    1a06:	83 89       	ldd	r24, Z+19	; 0x13
    1a08:	88 23       	and	r24, r24
    1a0a:	39 f0       	breq	.+14     	; 0x1a1a <xQueueGenericReceive+0xa0>
    1a0c:	c7 01       	movw	r24, r14
    1a0e:	43 96       	adiw	r24, 0x13	; 19
    1a10:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <xTaskRemoveFromEventList>
    1a14:	81 11       	cpse	r24, r1
    1a16:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    1a1a:	0f 90       	pop	r0
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	81 e0       	ldi	r24, 0x01	; 1
    1a20:	62 c0       	rjmp	.+196    	; 0x1ae6 <xQueueGenericReceive+0x16c>
    1a22:	8e 81       	ldd	r24, Y+6	; 0x06
    1a24:	9f 81       	ldd	r25, Y+7	; 0x07
    1a26:	a8 85       	ldd	r26, Y+8	; 0x08
    1a28:	b9 85       	ldd	r27, Y+9	; 0x09
    1a2a:	89 2b       	or	r24, r25
    1a2c:	8a 2b       	or	r24, r26
    1a2e:	8b 2b       	or	r24, r27
    1a30:	21 f4       	brne	.+8      	; 0x1a3a <xQueueGenericReceive+0xc0>
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	80 e0       	ldi	r24, 0x00	; 0
    1a38:	56 c0       	rjmp	.+172    	; 0x1ae6 <xQueueGenericReceive+0x16c>
    1a3a:	11 11       	cpse	r17, r1
    1a3c:	05 c0       	rjmp	.+10     	; 0x1a48 <xQueueGenericReceive+0xce>
    1a3e:	ce 01       	movw	r24, r28
    1a40:	01 96       	adiw	r24, 0x01	; 1
    1a42:	0e 94 27 12 	call	0x244e	; 0x244e <vTaskSetTimeOutState>
    1a46:	11 e0       	ldi	r17, 0x01	; 1
    1a48:	0f 90       	pop	r0
    1a4a:	0f be       	out	0x3f, r0	; 63
    1a4c:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskSuspendAll>
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	0f 92       	push	r0
    1a56:	f7 01       	movw	r30, r14
    1a58:	81 a1       	ldd	r24, Z+33	; 0x21
    1a5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5c:	09 f4       	brne	.+2      	; 0x1a60 <xQueueGenericReceive+0xe6>
    1a5e:	11 a2       	std	Z+33, r1	; 0x21
    1a60:	f7 01       	movw	r30, r14
    1a62:	82 a1       	ldd	r24, Z+34	; 0x22
    1a64:	8f 3f       	cpi	r24, 0xFF	; 255
    1a66:	09 f4       	brne	.+2      	; 0x1a6a <xQueueGenericReceive+0xf0>
    1a68:	12 a2       	std	Z+34, r1	; 0x22
    1a6a:	0f 90       	pop	r0
    1a6c:	0f be       	out	0x3f, r0	; 63
    1a6e:	be 01       	movw	r22, r28
    1a70:	6a 5f       	subi	r22, 0xFA	; 250
    1a72:	7f 4f       	sbci	r23, 0xFF	; 255
    1a74:	ce 01       	movw	r24, r28
    1a76:	01 96       	adiw	r24, 0x01	; 1
    1a78:	0e 94 38 12 	call	0x2470	; 0x2470 <xTaskCheckForTimeOut>
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	2d c0       	rjmp	.+90     	; 0x1ada <xQueueGenericReceive+0x160>
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	f8 94       	cli
    1a84:	0f 92       	push	r0
    1a86:	f7 01       	movw	r30, r14
    1a88:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a8a:	0f 90       	pop	r0
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	81 11       	cpse	r24, r1
    1a90:	1e c0       	rjmp	.+60     	; 0x1ace <xQueueGenericReceive+0x154>
    1a92:	80 81       	ld	r24, Z
    1a94:	91 81       	ldd	r25, Z+1	; 0x01
    1a96:	89 2b       	or	r24, r25
    1a98:	49 f4       	brne	.+18     	; 0x1aac <xQueueGenericReceive+0x132>
    1a9a:	0f b6       	in	r0, 0x3f	; 63
    1a9c:	f8 94       	cli
    1a9e:	0f 92       	push	r0
    1aa0:	82 81       	ldd	r24, Z+2	; 0x02
    1aa2:	93 81       	ldd	r25, Z+3	; 0x03
    1aa4:	0e 94 c7 12 	call	0x258e	; 0x258e <vTaskPriorityInherit>
    1aa8:	0f 90       	pop	r0
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	4e 81       	ldd	r20, Y+6	; 0x06
    1aae:	5f 81       	ldd	r21, Y+7	; 0x07
    1ab0:	68 85       	ldd	r22, Y+8	; 0x08
    1ab2:	79 85       	ldd	r23, Y+9	; 0x09
    1ab4:	c6 01       	movw	r24, r12
    1ab6:	0e 94 be 11 	call	0x237c	; 0x237c <vTaskPlaceOnEventList>
    1aba:	c7 01       	movw	r24, r14
    1abc:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <prvUnlockQueue>
    1ac0:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1ac4:	81 11       	cpse	r24, r1
    1ac6:	73 cf       	rjmp	.-282    	; 0x19ae <xQueueGenericReceive+0x34>
    1ac8:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    1acc:	70 cf       	rjmp	.-288    	; 0x19ae <xQueueGenericReceive+0x34>
    1ace:	c7 01       	movw	r24, r14
    1ad0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <prvUnlockQueue>
    1ad4:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1ad8:	6a cf       	rjmp	.-300    	; 0x19ae <xQueueGenericReceive+0x34>
    1ada:	c7 01       	movw	r24, r14
    1adc:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <prvUnlockQueue>
    1ae0:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	29 96       	adiw	r28, 0x09	; 9
    1ae8:	cd bf       	out	0x3d, r28	; 61
    1aea:	de bf       	out	0x3e, r29	; 62
    1aec:	df 91       	pop	r29
    1aee:	cf 91       	pop	r28
    1af0:	1f 91       	pop	r17
    1af2:	0f 91       	pop	r16
    1af4:	ff 90       	pop	r15
    1af6:	ef 90       	pop	r14
    1af8:	df 90       	pop	r13
    1afa:	cf 90       	pop	r12
    1afc:	bf 90       	pop	r11
    1afe:	af 90       	pop	r10
    1b00:	08 95       	ret

00001b02 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1b08:	fc 01       	movw	r30, r24
    1b0a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1b0c:	0f 90       	pop	r0
    1b0e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1b10:	08 95       	ret

00001b12 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1b12:	c6 ed       	ldi	r28, 0xD6	; 214
    1b14:	d0 e4       	ldi	r29, 0x40	; 64
    1b16:	88 81       	ld	r24, Y
    1b18:	82 30       	cpi	r24, 0x02	; 2
    1b1a:	e8 f3       	brcs	.-6      	; 0x1b16 <prvIdleTask+0x4>
    1b1c:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    1b20:	fa cf       	rjmp	.-12     	; 0x1b16 <prvIdleTask+0x4>

00001b22 <prvAddCurrentTaskToDelayedList>:
    1b22:	cf 92       	push	r12
    1b24:	df 92       	push	r13
    1b26:	ef 92       	push	r14
    1b28:	ff 92       	push	r15
    1b2a:	6b 01       	movw	r12, r22
    1b2c:	7c 01       	movw	r14, r24
    1b2e:	e0 91 02 41 	lds	r30, 0x4102	; 0x804102 <pxCurrentTCB>
    1b32:	f0 91 03 41 	lds	r31, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1b36:	62 83       	std	Z+2, r22	; 0x02
    1b38:	73 83       	std	Z+3, r23	; 0x03
    1b3a:	84 83       	std	Z+4, r24	; 0x04
    1b3c:	95 83       	std	Z+5, r25	; 0x05
    1b3e:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    1b42:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    1b46:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    1b4a:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    1b4e:	c8 16       	cp	r12, r24
    1b50:	d9 06       	cpc	r13, r25
    1b52:	ea 06       	cpc	r14, r26
    1b54:	fb 06       	cpc	r15, r27
    1b56:	68 f4       	brcc	.+26     	; 0x1b72 <prvAddCurrentTaskToDelayedList+0x50>
    1b58:	60 91 02 41 	lds	r22, 0x4102	; 0x804102 <pxCurrentTCB>
    1b5c:	70 91 03 41 	lds	r23, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1b60:	80 91 bc 40 	lds	r24, 0x40BC	; 0x8040bc <pxOverflowDelayedTaskList>
    1b64:	90 91 bd 40 	lds	r25, 0x40BD	; 0x8040bd <pxOverflowDelayedTaskList+0x1>
    1b68:	6e 5f       	subi	r22, 0xFE	; 254
    1b6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b6c:	0e 94 14 09 	call	0x1228	; 0x1228 <vListInsert>
    1b70:	21 c0       	rjmp	.+66     	; 0x1bb4 <prvAddCurrentTaskToDelayedList+0x92>
    1b72:	60 91 02 41 	lds	r22, 0x4102	; 0x804102 <pxCurrentTCB>
    1b76:	70 91 03 41 	lds	r23, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1b7a:	80 91 be 40 	lds	r24, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1b7e:	90 91 bf 40 	lds	r25, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    1b82:	6e 5f       	subi	r22, 0xFE	; 254
    1b84:	7f 4f       	sbci	r23, 0xFF	; 255
    1b86:	0e 94 14 09 	call	0x1228	; 0x1228 <vListInsert>
    1b8a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1b8e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1b92:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1b96:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1b9a:	c8 16       	cp	r12, r24
    1b9c:	d9 06       	cpc	r13, r25
    1b9e:	ea 06       	cpc	r14, r26
    1ba0:	fb 06       	cpc	r15, r27
    1ba2:	40 f4       	brcc	.+16     	; 0x1bb4 <prvAddCurrentTaskToDelayedList+0x92>
    1ba4:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1ba8:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1bac:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1bb0:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1bb4:	ff 90       	pop	r15
    1bb6:	ef 90       	pop	r14
    1bb8:	df 90       	pop	r13
    1bba:	cf 90       	pop	r12
    1bbc:	08 95       	ret

00001bbe <xTaskGenericCreate>:
    1bbe:	4f 92       	push	r4
    1bc0:	5f 92       	push	r5
    1bc2:	6f 92       	push	r6
    1bc4:	7f 92       	push	r7
    1bc6:	8f 92       	push	r8
    1bc8:	9f 92       	push	r9
    1bca:	af 92       	push	r10
    1bcc:	bf 92       	push	r11
    1bce:	cf 92       	push	r12
    1bd0:	df 92       	push	r13
    1bd2:	ef 92       	push	r14
    1bd4:	ff 92       	push	r15
    1bd6:	0f 93       	push	r16
    1bd8:	1f 93       	push	r17
    1bda:	cf 93       	push	r28
    1bdc:	df 93       	push	r29
    1bde:	5c 01       	movw	r10, r24
    1be0:	4b 01       	movw	r8, r22
    1be2:	3a 01       	movw	r6, r20
    1be4:	29 01       	movw	r4, r18
    1be6:	88 e2       	ldi	r24, 0x28	; 40
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	0e 94 06 08 	call	0x100c	; 0x100c <pvPortMalloc>
    1bee:	ec 01       	movw	r28, r24
    1bf0:	89 2b       	or	r24, r25
    1bf2:	09 f4       	brne	.+2      	; 0x1bf6 <xTaskGenericCreate+0x38>
    1bf4:	d4 c0       	rjmp	.+424    	; 0x1d9e <xTaskGenericCreate+0x1e0>
    1bf6:	c1 14       	cp	r12, r1
    1bf8:	d1 04       	cpc	r13, r1
    1bfa:	09 f0       	breq	.+2      	; 0x1bfe <xTaskGenericCreate+0x40>
    1bfc:	cc c0       	rjmp	.+408    	; 0x1d96 <xTaskGenericCreate+0x1d8>
    1bfe:	c3 01       	movw	r24, r6
    1c00:	0e 94 06 08 	call	0x100c	; 0x100c <pvPortMalloc>
    1c04:	8b 8f       	std	Y+27, r24	; 0x1b
    1c06:	9c 8f       	std	Y+28, r25	; 0x1c
    1c08:	00 97       	sbiw	r24, 0x00	; 0
    1c0a:	21 f4       	brne	.+8      	; 0x1c14 <xTaskGenericCreate+0x56>
    1c0c:	ce 01       	movw	r24, r28
    1c0e:	0e 94 a0 08 	call	0x1140	; 0x1140 <vPortFree>
    1c12:	c5 c0       	rjmp	.+394    	; 0x1d9e <xTaskGenericCreate+0x1e0>
    1c14:	a3 01       	movw	r20, r6
    1c16:	61 e1       	ldi	r22, 0x11	; 17
    1c18:	70 e0       	ldi	r23, 0x00	; 0
    1c1a:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <memset>
    1c1e:	93 01       	movw	r18, r6
    1c20:	21 50       	subi	r18, 0x01	; 1
    1c22:	31 09       	sbc	r19, r1
    1c24:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c26:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c28:	3c 01       	movw	r6, r24
    1c2a:	62 0e       	add	r6, r18
    1c2c:	73 1e       	adc	r7, r19
    1c2e:	4a e0       	ldi	r20, 0x0A	; 10
    1c30:	50 e0       	ldi	r21, 0x00	; 0
    1c32:	b4 01       	movw	r22, r8
    1c34:	ce 01       	movw	r24, r28
    1c36:	4d 96       	adiw	r24, 0x1d	; 29
    1c38:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <strncpy>
    1c3c:	1e a2       	std	Y+38, r1	; 0x26
    1c3e:	10 2f       	mov	r17, r16
    1c40:	04 30       	cpi	r16, 0x04	; 4
    1c42:	08 f0       	brcs	.+2      	; 0x1c46 <xTaskGenericCreate+0x88>
    1c44:	13 e0       	ldi	r17, 0x03	; 3
    1c46:	1a 8f       	std	Y+26, r17	; 0x1a
    1c48:	1f a3       	std	Y+39, r17	; 0x27
    1c4a:	6e 01       	movw	r12, r28
    1c4c:	22 e0       	ldi	r18, 0x02	; 2
    1c4e:	c2 0e       	add	r12, r18
    1c50:	d1 1c       	adc	r13, r1
    1c52:	c6 01       	movw	r24, r12
    1c54:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <vListInitialiseItem>
    1c58:	ce 01       	movw	r24, r28
    1c5a:	0e 96       	adiw	r24, 0x0e	; 14
    1c5c:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <vListInitialiseItem>
    1c60:	ca 87       	std	Y+10, r28	; 0x0a
    1c62:	db 87       	std	Y+11, r29	; 0x0b
    1c64:	84 e0       	ldi	r24, 0x04	; 4
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	a0 e0       	ldi	r26, 0x00	; 0
    1c6a:	b0 e0       	ldi	r27, 0x00	; 0
    1c6c:	81 1b       	sub	r24, r17
    1c6e:	91 09       	sbc	r25, r1
    1c70:	a1 09       	sbc	r26, r1
    1c72:	b1 09       	sbc	r27, r1
    1c74:	8e 87       	std	Y+14, r24	; 0x0e
    1c76:	9f 87       	std	Y+15, r25	; 0x0f
    1c78:	a8 8b       	std	Y+16, r26	; 0x10
    1c7a:	b9 8b       	std	Y+17, r27	; 0x11
    1c7c:	ce 8b       	std	Y+22, r28	; 0x16
    1c7e:	df 8b       	std	Y+23, r29	; 0x17
    1c80:	a2 01       	movw	r20, r4
    1c82:	b5 01       	movw	r22, r10
    1c84:	c3 01       	movw	r24, r6
    1c86:	0e 94 85 09 	call	0x130a	; 0x130a <pxPortInitialiseStack>
    1c8a:	88 83       	st	Y, r24
    1c8c:	99 83       	std	Y+1, r25	; 0x01
    1c8e:	e1 14       	cp	r14, r1
    1c90:	f1 04       	cpc	r15, r1
    1c92:	19 f0       	breq	.+6      	; 0x1c9a <xTaskGenericCreate+0xdc>
    1c94:	f7 01       	movw	r30, r14
    1c96:	c0 83       	st	Z, r28
    1c98:	d1 83       	std	Z+1, r29	; 0x01
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	f8 94       	cli
    1c9e:	0f 92       	push	r0
    1ca0:	80 91 ae 40 	lds	r24, 0x40AE	; 0x8040ae <uxCurrentNumberOfTasks>
    1ca4:	8f 5f       	subi	r24, 0xFF	; 255
    1ca6:	80 93 ae 40 	sts	0x40AE, r24	; 0x8040ae <uxCurrentNumberOfTasks>
    1caa:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    1cae:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1cb2:	89 2b       	or	r24, r25
    1cb4:	89 f5       	brne	.+98     	; 0x1d18 <xTaskGenericCreate+0x15a>
    1cb6:	c0 93 02 41 	sts	0x4102, r28	; 0x804102 <pxCurrentTCB>
    1cba:	d0 93 03 41 	sts	0x4103, r29	; 0x804103 <pxCurrentTCB+0x1>
    1cbe:	80 91 ae 40 	lds	r24, 0x40AE	; 0x8040ae <uxCurrentNumberOfTasks>
    1cc2:	81 30       	cpi	r24, 0x01	; 1
    1cc4:	c1 f5       	brne	.+112    	; 0x1d36 <xTaskGenericCreate+0x178>
    1cc6:	86 ed       	ldi	r24, 0xD6	; 214
    1cc8:	90 e4       	ldi	r25, 0x40	; 64
    1cca:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1cce:	81 ee       	ldi	r24, 0xE1	; 225
    1cd0:	90 e4       	ldi	r25, 0x40	; 64
    1cd2:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1cd6:	8c ee       	ldi	r24, 0xEC	; 236
    1cd8:	90 e4       	ldi	r25, 0x40	; 64
    1cda:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1cde:	87 ef       	ldi	r24, 0xF7	; 247
    1ce0:	90 e4       	ldi	r25, 0x40	; 64
    1ce2:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1ce6:	8b ec       	ldi	r24, 0xCB	; 203
    1ce8:	90 e4       	ldi	r25, 0x40	; 64
    1cea:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1cee:	80 ec       	ldi	r24, 0xC0	; 192
    1cf0:	90 e4       	ldi	r25, 0x40	; 64
    1cf2:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1cf6:	81 eb       	ldi	r24, 0xB1	; 177
    1cf8:	90 e4       	ldi	r25, 0x40	; 64
    1cfa:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vListInitialise>
    1cfe:	8b ec       	ldi	r24, 0xCB	; 203
    1d00:	90 e4       	ldi	r25, 0x40	; 64
    1d02:	80 93 be 40 	sts	0x40BE, r24	; 0x8040be <pxDelayedTaskList>
    1d06:	90 93 bf 40 	sts	0x40BF, r25	; 0x8040bf <pxDelayedTaskList+0x1>
    1d0a:	80 ec       	ldi	r24, 0xC0	; 192
    1d0c:	90 e4       	ldi	r25, 0x40	; 64
    1d0e:	80 93 bc 40 	sts	0x40BC, r24	; 0x8040bc <pxOverflowDelayedTaskList>
    1d12:	90 93 bd 40 	sts	0x40BD, r25	; 0x8040bd <pxOverflowDelayedTaskList+0x1>
    1d16:	0f c0       	rjmp	.+30     	; 0x1d36 <xTaskGenericCreate+0x178>
    1d18:	80 91 a7 40 	lds	r24, 0x40A7	; 0x8040a7 <xSchedulerRunning>
    1d1c:	81 11       	cpse	r24, r1
    1d1e:	0b c0       	rjmp	.+22     	; 0x1d36 <xTaskGenericCreate+0x178>
    1d20:	e0 91 02 41 	lds	r30, 0x4102	; 0x804102 <pxCurrentTCB>
    1d24:	f0 91 03 41 	lds	r31, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1d28:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d2a:	08 17       	cp	r16, r24
    1d2c:	20 f0       	brcs	.+8      	; 0x1d36 <xTaskGenericCreate+0x178>
    1d2e:	c0 93 02 41 	sts	0x4102, r28	; 0x804102 <pxCurrentTCB>
    1d32:	d0 93 03 41 	sts	0x4103, r29	; 0x804103 <pxCurrentTCB+0x1>
    1d36:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d38:	90 91 a9 40 	lds	r25, 0x40A9	; 0x8040a9 <uxTopUsedPriority>
    1d3c:	98 17       	cp	r25, r24
    1d3e:	10 f4       	brcc	.+4      	; 0x1d44 <xTaskGenericCreate+0x186>
    1d40:	80 93 a9 40 	sts	0x40A9, r24	; 0x8040a9 <uxTopUsedPriority>
    1d44:	90 91 a2 40 	lds	r25, 0x40A2	; 0x8040a2 <uxTaskNumber>
    1d48:	9f 5f       	subi	r25, 0xFF	; 255
    1d4a:	90 93 a2 40 	sts	0x40A2, r25	; 0x8040a2 <uxTaskNumber>
    1d4e:	90 91 a8 40 	lds	r25, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    1d52:	98 17       	cp	r25, r24
    1d54:	10 f4       	brcc	.+4      	; 0x1d5a <xTaskGenericCreate+0x19c>
    1d56:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
    1d5a:	fb e0       	ldi	r31, 0x0B	; 11
    1d5c:	8f 9f       	mul	r24, r31
    1d5e:	c0 01       	movw	r24, r0
    1d60:	11 24       	eor	r1, r1
    1d62:	b6 01       	movw	r22, r12
    1d64:	8a 52       	subi	r24, 0x2A	; 42
    1d66:	9f 4b       	sbci	r25, 0xBF	; 191
    1d68:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    1d6c:	0f 90       	pop	r0
    1d6e:	0f be       	out	0x3f, r0	; 63
    1d70:	80 91 a7 40 	lds	r24, 0x40A7	; 0x8040a7 <xSchedulerRunning>
    1d74:	88 23       	and	r24, r24
    1d76:	59 f0       	breq	.+22     	; 0x1d8e <xTaskGenericCreate+0x1d0>
    1d78:	e0 91 02 41 	lds	r30, 0x4102	; 0x804102 <pxCurrentTCB>
    1d7c:	f0 91 03 41 	lds	r31, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1d80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d82:	80 17       	cp	r24, r16
    1d84:	30 f4       	brcc	.+12     	; 0x1d92 <xTaskGenericCreate+0x1d4>
    1d86:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	09 c0       	rjmp	.+18     	; 0x1da0 <xTaskGenericCreate+0x1e2>
    1d8e:	81 e0       	ldi	r24, 0x01	; 1
    1d90:	07 c0       	rjmp	.+14     	; 0x1da0 <xTaskGenericCreate+0x1e2>
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	05 c0       	rjmp	.+10     	; 0x1da0 <xTaskGenericCreate+0x1e2>
    1d96:	cb 8e       	std	Y+27, r12	; 0x1b
    1d98:	dc 8e       	std	Y+28, r13	; 0x1c
    1d9a:	c6 01       	movw	r24, r12
    1d9c:	3b cf       	rjmp	.-394    	; 0x1c14 <xTaskGenericCreate+0x56>
    1d9e:	8f ef       	ldi	r24, 0xFF	; 255
    1da0:	df 91       	pop	r29
    1da2:	cf 91       	pop	r28
    1da4:	1f 91       	pop	r17
    1da6:	0f 91       	pop	r16
    1da8:	ff 90       	pop	r15
    1daa:	ef 90       	pop	r14
    1dac:	df 90       	pop	r13
    1dae:	cf 90       	pop	r12
    1db0:	bf 90       	pop	r11
    1db2:	af 90       	pop	r10
    1db4:	9f 90       	pop	r9
    1db6:	8f 90       	pop	r8
    1db8:	7f 90       	pop	r7
    1dba:	6f 90       	pop	r6
    1dbc:	5f 90       	pop	r5
    1dbe:	4f 90       	pop	r4
    1dc0:	08 95       	ret

00001dc2 <uxTaskPriorityGet>:
    1dc2:	0f b6       	in	r0, 0x3f	; 63
    1dc4:	f8 94       	cli
    1dc6:	0f 92       	push	r0
    1dc8:	00 97       	sbiw	r24, 0x00	; 0
    1dca:	21 f4       	brne	.+8      	; 0x1dd4 <uxTaskPriorityGet+0x12>
    1dcc:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    1dd0:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    1dd4:	0f 90       	pop	r0
    1dd6:	0f be       	out	0x3f, r0	; 63
    1dd8:	fc 01       	movw	r30, r24
    1dda:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ddc:	08 95       	ret

00001dde <vTaskStartScheduler>:
    1dde:	af 92       	push	r10
    1de0:	bf 92       	push	r11
    1de2:	cf 92       	push	r12
    1de4:	df 92       	push	r13
    1de6:	ef 92       	push	r14
    1de8:	ff 92       	push	r15
    1dea:	0f 93       	push	r16
    1dec:	a1 2c       	mov	r10, r1
    1dee:	b1 2c       	mov	r11, r1
    1df0:	c1 2c       	mov	r12, r1
    1df2:	d1 2c       	mov	r13, r1
    1df4:	0f 2e       	mov	r0, r31
    1df6:	ff ea       	ldi	r31, 0xAF	; 175
    1df8:	ef 2e       	mov	r14, r31
    1dfa:	f0 e4       	ldi	r31, 0x40	; 64
    1dfc:	ff 2e       	mov	r15, r31
    1dfe:	f0 2d       	mov	r31, r0
    1e00:	00 e0       	ldi	r16, 0x00	; 0
    1e02:	20 e0       	ldi	r18, 0x00	; 0
    1e04:	30 e0       	ldi	r19, 0x00	; 0
    1e06:	44 e6       	ldi	r20, 0x64	; 100
    1e08:	50 e0       	ldi	r21, 0x00	; 0
    1e0a:	6e e1       	ldi	r22, 0x1E	; 30
    1e0c:	70 e2       	ldi	r23, 0x20	; 32
    1e0e:	89 e8       	ldi	r24, 0x89	; 137
    1e10:	9d e0       	ldi	r25, 0x0D	; 13
    1e12:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <xTaskGenericCreate>
    1e16:	81 30       	cpi	r24, 0x01	; 1
    1e18:	69 f4       	brne	.+26     	; 0x1e34 <vTaskStartScheduler+0x56>
    1e1a:	f8 94       	cli
    1e1c:	80 93 a7 40 	sts	0x40A7, r24	; 0x8040a7 <xSchedulerRunning>
    1e20:	10 92 aa 40 	sts	0x40AA, r1	; 0x8040aa <xTickCount>
    1e24:	10 92 ab 40 	sts	0x40AB, r1	; 0x8040ab <xTickCount+0x1>
    1e28:	10 92 ac 40 	sts	0x40AC, r1	; 0x8040ac <xTickCount+0x2>
    1e2c:	10 92 ad 40 	sts	0x40AD, r1	; 0x8040ad <xTickCount+0x3>
    1e30:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <xPortStartScheduler>
    1e34:	0f 91       	pop	r16
    1e36:	ff 90       	pop	r15
    1e38:	ef 90       	pop	r14
    1e3a:	df 90       	pop	r13
    1e3c:	cf 90       	pop	r12
    1e3e:	bf 90       	pop	r11
    1e40:	af 90       	pop	r10
    1e42:	08 95       	ret

00001e44 <vTaskSuspendAll>:
    1e44:	80 91 a6 40 	lds	r24, 0x40A6	; 0x8040a6 <uxSchedulerSuspended>
    1e48:	8f 5f       	subi	r24, 0xFF	; 255
    1e4a:	80 93 a6 40 	sts	0x40A6, r24	; 0x8040a6 <uxSchedulerSuspended>
    1e4e:	08 95       	ret

00001e50 <xTaskGetTickCount>:
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	0f 92       	push	r0
    1e56:	60 91 aa 40 	lds	r22, 0x40AA	; 0x8040aa <xTickCount>
    1e5a:	70 91 ab 40 	lds	r23, 0x40AB	; 0x8040ab <xTickCount+0x1>
    1e5e:	80 91 ac 40 	lds	r24, 0x40AC	; 0x8040ac <xTickCount+0x2>
    1e62:	90 91 ad 40 	lds	r25, 0x40AD	; 0x8040ad <xTickCount+0x3>
    1e66:	0f 90       	pop	r0
    1e68:	0f be       	out	0x3f, r0	; 63
    1e6a:	08 95       	ret

00001e6c <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1e6c:	00 97       	sbiw	r24, 0x00	; 0
    1e6e:	21 f4       	brne	.+8      	; 0x1e78 <pcTaskGetTaskName+0xc>
    1e70:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    1e74:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1e78:	4d 96       	adiw	r24, 0x1d	; 29
    1e7a:	08 95       	ret

00001e7c <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1e7c:	80 91 af 40 	lds	r24, 0x40AF	; 0x8040af <xIdleTaskHandle>
    1e80:	90 91 b0 40 	lds	r25, 0x40B0	; 0x8040b0 <xIdleTaskHandle+0x1>
    1e84:	08 95       	ret

00001e86 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1e86:	ff 92       	push	r15
    1e88:	0f 93       	push	r16
    1e8a:	1f 93       	push	r17
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e90:	80 91 a6 40 	lds	r24, 0x40A6	; 0x8040a6 <uxSchedulerSuspended>
    1e94:	81 11       	cpse	r24, r1
    1e96:	ed c0       	rjmp	.+474    	; 0x2072 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1e98:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    1e9c:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    1ea0:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    1ea4:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    1ea8:	01 96       	adiw	r24, 0x01	; 1
    1eaa:	a1 1d       	adc	r26, r1
    1eac:	b1 1d       	adc	r27, r1
    1eae:	80 93 aa 40 	sts	0x40AA, r24	; 0x8040aa <xTickCount>
    1eb2:	90 93 ab 40 	sts	0x40AB, r25	; 0x8040ab <xTickCount+0x1>
    1eb6:	a0 93 ac 40 	sts	0x40AC, r26	; 0x8040ac <xTickCount+0x2>
    1eba:	b0 93 ad 40 	sts	0x40AD, r27	; 0x8040ad <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1ebe:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    1ec2:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    1ec6:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    1eca:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    1ece:	89 2b       	or	r24, r25
    1ed0:	8a 2b       	or	r24, r26
    1ed2:	8b 2b       	or	r24, r27
    1ed4:	f1 f5       	brne	.+124    	; 0x1f52 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1ed6:	80 91 be 40 	lds	r24, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1eda:	90 91 bf 40 	lds	r25, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1ede:	20 91 bc 40 	lds	r18, 0x40BC	; 0x8040bc <pxOverflowDelayedTaskList>
    1ee2:	30 91 bd 40 	lds	r19, 0x40BD	; 0x8040bd <pxOverflowDelayedTaskList+0x1>
    1ee6:	20 93 be 40 	sts	0x40BE, r18	; 0x8040be <pxDelayedTaskList>
    1eea:	30 93 bf 40 	sts	0x40BF, r19	; 0x8040bf <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1eee:	80 93 bc 40 	sts	0x40BC, r24	; 0x8040bc <pxOverflowDelayedTaskList>
    1ef2:	90 93 bd 40 	sts	0x40BD, r25	; 0x8040bd <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1ef6:	80 91 a3 40 	lds	r24, 0x40A3	; 0x8040a3 <xNumOfOverflows>
    1efa:	8f 5f       	subi	r24, 0xFF	; 255
    1efc:	80 93 a3 40 	sts	0x40A3, r24	; 0x8040a3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f00:	e0 91 be 40 	lds	r30, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1f04:	f0 91 bf 40 	lds	r31, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    1f08:	80 81       	ld	r24, Z
    1f0a:	81 11       	cpse	r24, r1
    1f0c:	0c c0       	rjmp	.+24     	; 0x1f26 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1f0e:	8f ef       	ldi	r24, 0xFF	; 255
    1f10:	9f ef       	ldi	r25, 0xFF	; 255
    1f12:	dc 01       	movw	r26, r24
    1f14:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1f18:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f1c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f20:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f24:	16 c0       	rjmp	.+44     	; 0x1f52 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f26:	e0 91 be 40 	lds	r30, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1f2a:	f0 91 bf 40 	lds	r31, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    1f2e:	07 80       	ldd	r0, Z+7	; 0x07
    1f30:	f0 85       	ldd	r31, Z+8	; 0x08
    1f32:	e0 2d       	mov	r30, r0
    1f34:	00 84       	ldd	r0, Z+8	; 0x08
    1f36:	f1 85       	ldd	r31, Z+9	; 0x09
    1f38:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1f3a:	82 81       	ldd	r24, Z+2	; 0x02
    1f3c:	93 81       	ldd	r25, Z+3	; 0x03
    1f3e:	a4 81       	ldd	r26, Z+4	; 0x04
    1f40:	b5 81       	ldd	r27, Z+5	; 0x05
    1f42:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1f46:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f4a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f4e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1f52:	40 91 aa 40 	lds	r20, 0x40AA	; 0x8040aa <xTickCount>
    1f56:	50 91 ab 40 	lds	r21, 0x40AB	; 0x8040ab <xTickCount+0x1>
    1f5a:	60 91 ac 40 	lds	r22, 0x40AC	; 0x8040ac <xTickCount+0x2>
    1f5e:	70 91 ad 40 	lds	r23, 0x40AD	; 0x8040ad <xTickCount+0x3>
    1f62:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1f66:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f6a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f6e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f72:	48 17       	cp	r20, r24
    1f74:	59 07       	cpc	r21, r25
    1f76:	6a 07       	cpc	r22, r26
    1f78:	7b 07       	cpc	r23, r27
    1f7a:	08 f4       	brcc	.+2      	; 0x1f7e <vTaskIncrementTick+0xf8>
    1f7c:	7f c0       	rjmp	.+254    	; 0x207c <vTaskIncrementTick+0x1f6>
    1f7e:	e0 91 be 40 	lds	r30, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1f82:	f0 91 bf 40 	lds	r31, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    1f86:	80 81       	ld	r24, Z
    1f88:	88 23       	and	r24, r24
    1f8a:	f9 f0       	breq	.+62     	; 0x1fca <vTaskIncrementTick+0x144>
    1f8c:	e0 91 be 40 	lds	r30, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1f90:	f0 91 bf 40 	lds	r31, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    1f94:	07 80       	ldd	r0, Z+7	; 0x07
    1f96:	f0 85       	ldd	r31, Z+8	; 0x08
    1f98:	e0 2d       	mov	r30, r0
    1f9a:	c0 85       	ldd	r28, Z+8	; 0x08
    1f9c:	d1 85       	ldd	r29, Z+9	; 0x09
    1f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa2:	ac 81       	ldd	r26, Y+4	; 0x04
    1fa4:	bd 81       	ldd	r27, Y+5	; 0x05
    1fa6:	40 91 aa 40 	lds	r20, 0x40AA	; 0x8040aa <xTickCount>
    1faa:	50 91 ab 40 	lds	r21, 0x40AB	; 0x8040ab <xTickCount+0x1>
    1fae:	60 91 ac 40 	lds	r22, 0x40AC	; 0x8040ac <xTickCount+0x2>
    1fb2:	70 91 ad 40 	lds	r23, 0x40AD	; 0x8040ad <xTickCount+0x3>
    1fb6:	48 17       	cp	r20, r24
    1fb8:	59 07       	cpc	r21, r25
    1fba:	6a 07       	cpc	r22, r26
    1fbc:	7b 07       	cpc	r23, r27
    1fbe:	58 f1       	brcs	.+86     	; 0x2016 <vTaskIncrementTick+0x190>
    1fc0:	0f 2e       	mov	r0, r31
    1fc2:	fb e0       	ldi	r31, 0x0B	; 11
    1fc4:	ff 2e       	mov	r15, r31
    1fc6:	f0 2d       	mov	r31, r0
    1fc8:	2f c0       	rjmp	.+94     	; 0x2028 <vTaskIncrementTick+0x1a2>
    1fca:	8f ef       	ldi	r24, 0xFF	; 255
    1fcc:	9f ef       	ldi	r25, 0xFF	; 255
    1fce:	dc 01       	movw	r26, r24
    1fd0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1fd4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1fd8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1fdc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1fe0:	4d c0       	rjmp	.+154    	; 0x207c <vTaskIncrementTick+0x1f6>
    1fe2:	e0 91 be 40 	lds	r30, 0x40BE	; 0x8040be <pxDelayedTaskList>
    1fe6:	f0 91 bf 40 	lds	r31, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    1fea:	07 80       	ldd	r0, Z+7	; 0x07
    1fec:	f0 85       	ldd	r31, Z+8	; 0x08
    1fee:	e0 2d       	mov	r30, r0
    1ff0:	c0 85       	ldd	r28, Z+8	; 0x08
    1ff2:	d1 85       	ldd	r29, Z+9	; 0x09
    1ff4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ff8:	ac 81       	ldd	r26, Y+4	; 0x04
    1ffa:	bd 81       	ldd	r27, Y+5	; 0x05
    1ffc:	40 91 aa 40 	lds	r20, 0x40AA	; 0x8040aa <xTickCount>
    2000:	50 91 ab 40 	lds	r21, 0x40AB	; 0x8040ab <xTickCount+0x1>
    2004:	60 91 ac 40 	lds	r22, 0x40AC	; 0x8040ac <xTickCount+0x2>
    2008:	70 91 ad 40 	lds	r23, 0x40AD	; 0x8040ad <xTickCount+0x3>
    200c:	48 17       	cp	r20, r24
    200e:	59 07       	cpc	r21, r25
    2010:	6a 07       	cpc	r22, r26
    2012:	7b 07       	cpc	r23, r27
    2014:	48 f4       	brcc	.+18     	; 0x2028 <vTaskIncrementTick+0x1a2>
    2016:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    201a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    201e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2022:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2026:	2a c0       	rjmp	.+84     	; 0x207c <vTaskIncrementTick+0x1f6>
    2028:	8e 01       	movw	r16, r28
    202a:	0e 5f       	subi	r16, 0xFE	; 254
    202c:	1f 4f       	sbci	r17, 0xFF	; 255
    202e:	c8 01       	movw	r24, r16
    2030:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
    2034:	88 8d       	ldd	r24, Y+24	; 0x18
    2036:	99 8d       	ldd	r25, Y+25	; 0x19
    2038:	89 2b       	or	r24, r25
    203a:	21 f0       	breq	.+8      	; 0x2044 <vTaskIncrementTick+0x1be>
    203c:	ce 01       	movw	r24, r28
    203e:	0e 96       	adiw	r24, 0x0e	; 14
    2040:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
    2044:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2046:	90 91 a8 40 	lds	r25, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    204a:	98 17       	cp	r25, r24
    204c:	10 f4       	brcc	.+4      	; 0x2052 <vTaskIncrementTick+0x1cc>
    204e:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
    2052:	f8 9e       	mul	r15, r24
    2054:	c0 01       	movw	r24, r0
    2056:	11 24       	eor	r1, r1
    2058:	b8 01       	movw	r22, r16
    205a:	8a 52       	subi	r24, 0x2A	; 42
    205c:	9f 4b       	sbci	r25, 0xBF	; 191
    205e:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    2062:	e0 91 be 40 	lds	r30, 0x40BE	; 0x8040be <pxDelayedTaskList>
    2066:	f0 91 bf 40 	lds	r31, 0x40BF	; 0x8040bf <pxDelayedTaskList+0x1>
    206a:	80 81       	ld	r24, Z
    206c:	81 11       	cpse	r24, r1
    206e:	b9 cf       	rjmp	.-142    	; 0x1fe2 <vTaskIncrementTick+0x15c>
    2070:	ac cf       	rjmp	.-168    	; 0x1fca <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2072:	80 91 a5 40 	lds	r24, 0x40A5	; 0x8040a5 <uxMissedTicks>
    2076:	8f 5f       	subi	r24, 0xFF	; 255
    2078:	80 93 a5 40 	sts	0x40A5, r24	; 0x8040a5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    207c:	df 91       	pop	r29
    207e:	cf 91       	pop	r28
    2080:	1f 91       	pop	r17
    2082:	0f 91       	pop	r16
    2084:	ff 90       	pop	r15
    2086:	08 95       	ret

00002088 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2088:	cf 92       	push	r12
    208a:	df 92       	push	r13
    208c:	ef 92       	push	r14
    208e:	ff 92       	push	r15
    2090:	0f 93       	push	r16
    2092:	1f 93       	push	r17
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2098:	0f b6       	in	r0, 0x3f	; 63
    209a:	f8 94       	cli
    209c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    209e:	80 91 a6 40 	lds	r24, 0x40A6	; 0x8040a6 <uxSchedulerSuspended>
    20a2:	81 50       	subi	r24, 0x01	; 1
    20a4:	80 93 a6 40 	sts	0x40A6, r24	; 0x8040a6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20a8:	80 91 a6 40 	lds	r24, 0x40A6	; 0x8040a6 <uxSchedulerSuspended>
    20ac:	81 11       	cpse	r24, r1
    20ae:	60 c0       	rjmp	.+192    	; 0x2170 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    20b0:	80 91 ae 40 	lds	r24, 0x40AE	; 0x8040ae <uxCurrentNumberOfTasks>
    20b4:	81 11       	cpse	r24, r1
    20b6:	2c c0       	rjmp	.+88     	; 0x2110 <xTaskResumeAll+0x88>
    20b8:	5e c0       	rjmp	.+188    	; 0x2176 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    20ba:	d7 01       	movw	r26, r14
    20bc:	17 96       	adiw	r26, 0x07	; 7
    20be:	ed 91       	ld	r30, X+
    20c0:	fc 91       	ld	r31, X
    20c2:	18 97       	sbiw	r26, 0x08	; 8
    20c4:	c0 85       	ldd	r28, Z+8	; 0x08
    20c6:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    20c8:	ce 01       	movw	r24, r28
    20ca:	0e 96       	adiw	r24, 0x0e	; 14
    20cc:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    20d0:	8e 01       	movw	r16, r28
    20d2:	0e 5f       	subi	r16, 0xFE	; 254
    20d4:	1f 4f       	sbci	r17, 0xFF	; 255
    20d6:	c8 01       	movw	r24, r16
    20d8:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    20dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20de:	90 91 a8 40 	lds	r25, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    20e2:	98 17       	cp	r25, r24
    20e4:	10 f4       	brcc	.+4      	; 0x20ea <xTaskResumeAll+0x62>
    20e6:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
    20ea:	d8 9e       	mul	r13, r24
    20ec:	c0 01       	movw	r24, r0
    20ee:	11 24       	eor	r1, r1
    20f0:	b8 01       	movw	r22, r16
    20f2:	8a 52       	subi	r24, 0x2A	; 42
    20f4:	9f 4b       	sbci	r25, 0xBF	; 191
    20f6:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20fa:	e0 91 02 41 	lds	r30, 0x4102	; 0x804102 <pxCurrentTCB>
    20fe:	f0 91 03 41 	lds	r31, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    2102:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2104:	82 8d       	ldd	r24, Z+26	; 0x1a
    2106:	98 17       	cp	r25, r24
    2108:	70 f0       	brcs	.+28     	; 0x2126 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    210a:	cc 24       	eor	r12, r12
    210c:	c3 94       	inc	r12
    210e:	0b c0       	rjmp	.+22     	; 0x2126 <xTaskResumeAll+0x9e>
    2110:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2112:	0f 2e       	mov	r0, r31
    2114:	f1 eb       	ldi	r31, 0xB1	; 177
    2116:	ef 2e       	mov	r14, r31
    2118:	f0 e4       	ldi	r31, 0x40	; 64
    211a:	ff 2e       	mov	r15, r31
    211c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    211e:	0f 2e       	mov	r0, r31
    2120:	fb e0       	ldi	r31, 0x0B	; 11
    2122:	df 2e       	mov	r13, r31
    2124:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2126:	f7 01       	movw	r30, r14
    2128:	80 81       	ld	r24, Z
    212a:	81 11       	cpse	r24, r1
    212c:	c6 cf       	rjmp	.-116    	; 0x20ba <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    212e:	80 91 a5 40 	lds	r24, 0x40A5	; 0x8040a5 <uxMissedTicks>
    2132:	88 23       	and	r24, r24
    2134:	81 f0       	breq	.+32     	; 0x2156 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2136:	80 91 a5 40 	lds	r24, 0x40A5	; 0x8040a5 <uxMissedTicks>
    213a:	88 23       	and	r24, r24
    213c:	99 f0       	breq	.+38     	; 0x2164 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    213e:	0e 94 43 0f 	call	0x1e86	; 0x1e86 <vTaskIncrementTick>
						--uxMissedTicks;
    2142:	80 91 a5 40 	lds	r24, 0x40A5	; 0x8040a5 <uxMissedTicks>
    2146:	81 50       	subi	r24, 0x01	; 1
    2148:	80 93 a5 40 	sts	0x40A5, r24	; 0x8040a5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    214c:	80 91 a5 40 	lds	r24, 0x40A5	; 0x8040a5 <uxMissedTicks>
    2150:	81 11       	cpse	r24, r1
    2152:	f5 cf       	rjmp	.-22     	; 0x213e <xTaskResumeAll+0xb6>
    2154:	07 c0       	rjmp	.+14     	; 0x2164 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2156:	f1 e0       	ldi	r31, 0x01	; 1
    2158:	cf 16       	cp	r12, r31
    215a:	21 f0       	breq	.+8      	; 0x2164 <xTaskResumeAll+0xdc>
    215c:	80 91 a4 40 	lds	r24, 0x40A4	; 0x8040a4 <xMissedYield>
    2160:	81 30       	cpi	r24, 0x01	; 1
    2162:	41 f4       	brne	.+16     	; 0x2174 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2164:	10 92 a4 40 	sts	0x40A4, r1	; 0x8040a4 <xMissedYield>
					portYIELD_WITHIN_API();
    2168:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	03 c0       	rjmp	.+6      	; 0x2176 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	01 c0       	rjmp	.+2      	; 0x2176 <xTaskResumeAll+0xee>
    2174:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2176:	0f 90       	pop	r0
    2178:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    217a:	df 91       	pop	r29
    217c:	cf 91       	pop	r28
    217e:	1f 91       	pop	r17
    2180:	0f 91       	pop	r16
    2182:	ff 90       	pop	r15
    2184:	ef 90       	pop	r14
    2186:	df 90       	pop	r13
    2188:	cf 90       	pop	r12
    218a:	08 95       	ret

0000218c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    218c:	cf 92       	push	r12
    218e:	df 92       	push	r13
    2190:	ef 92       	push	r14
    2192:	ff 92       	push	r15
    2194:	cf 93       	push	r28
    2196:	df 93       	push	r29
    2198:	ec 01       	movw	r28, r24
    219a:	6a 01       	movw	r12, r20
    219c:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    219e:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    21a2:	88 81       	ld	r24, Y
    21a4:	99 81       	ldd	r25, Y+1	; 0x01
    21a6:	aa 81       	ldd	r26, Y+2	; 0x02
    21a8:	bb 81       	ldd	r27, Y+3	; 0x03
    21aa:	c8 0e       	add	r12, r24
    21ac:	d9 1e       	adc	r13, r25
    21ae:	ea 1e       	adc	r14, r26
    21b0:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    21b2:	40 91 aa 40 	lds	r20, 0x40AA	; 0x8040aa <xTickCount>
    21b6:	50 91 ab 40 	lds	r21, 0x40AB	; 0x8040ab <xTickCount+0x1>
    21ba:	60 91 ac 40 	lds	r22, 0x40AC	; 0x8040ac <xTickCount+0x2>
    21be:	70 91 ad 40 	lds	r23, 0x40AD	; 0x8040ad <xTickCount+0x3>
    21c2:	48 17       	cp	r20, r24
    21c4:	59 07       	cpc	r21, r25
    21c6:	6a 07       	cpc	r22, r26
    21c8:	7b 07       	cpc	r23, r27
    21ca:	b8 f4       	brcc	.+46     	; 0x21fa <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    21cc:	c8 16       	cp	r12, r24
    21ce:	d9 06       	cpc	r13, r25
    21d0:	ea 06       	cpc	r14, r26
    21d2:	fb 06       	cpc	r15, r27
    21d4:	e0 f5       	brcc	.+120    	; 0x224e <vTaskDelayUntil+0xc2>
    21d6:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    21da:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    21de:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    21e2:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    21e6:	c8 82       	st	Y, r12
    21e8:	d9 82       	std	Y+1, r13	; 0x01
    21ea:	ea 82       	std	Y+2, r14	; 0x02
    21ec:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    21ee:	8c 15       	cp	r24, r12
    21f0:	9d 05       	cpc	r25, r13
    21f2:	ae 05       	cpc	r26, r14
    21f4:	bf 05       	cpc	r27, r15
    21f6:	f8 f4       	brcc	.+62     	; 0x2236 <vTaskDelayUntil+0xaa>
    21f8:	13 c0       	rjmp	.+38     	; 0x2220 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    21fa:	c8 16       	cp	r12, r24
    21fc:	d9 06       	cpc	r13, r25
    21fe:	ea 06       	cpc	r14, r26
    2200:	fb 06       	cpc	r15, r27
    2202:	00 f1       	brcs	.+64     	; 0x2244 <vTaskDelayUntil+0xb8>
    2204:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    2208:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    220c:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    2210:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    2214:	8c 15       	cp	r24, r12
    2216:	9d 05       	cpc	r25, r13
    2218:	ae 05       	cpc	r26, r14
    221a:	bf 05       	cpc	r27, r15
    221c:	98 f0       	brcs	.+38     	; 0x2244 <vTaskDelayUntil+0xb8>
    221e:	17 c0       	rjmp	.+46     	; 0x224e <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2220:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    2224:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    2228:	02 96       	adiw	r24, 0x02	; 2
    222a:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    222e:	c7 01       	movw	r24, r14
    2230:	b6 01       	movw	r22, r12
    2232:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2236:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    223a:	81 11       	cpse	r24, r1
    223c:	0d c0       	rjmp	.+26     	; 0x2258 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    223e:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
		}
	}
    2242:	0a c0       	rjmp	.+20     	; 0x2258 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2244:	c8 82       	st	Y, r12
    2246:	d9 82       	std	Y+1, r13	; 0x01
    2248:	ea 82       	std	Y+2, r14	; 0x02
    224a:	fb 82       	std	Y+3, r15	; 0x03
    224c:	e9 cf       	rjmp	.-46     	; 0x2220 <vTaskDelayUntil+0x94>
    224e:	c8 82       	st	Y, r12
    2250:	d9 82       	std	Y+1, r13	; 0x01
    2252:	ea 82       	std	Y+2, r14	; 0x02
    2254:	fb 82       	std	Y+3, r15	; 0x03
    2256:	ef cf       	rjmp	.-34     	; 0x2236 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2258:	df 91       	pop	r29
    225a:	cf 91       	pop	r28
    225c:	ff 90       	pop	r15
    225e:	ef 90       	pop	r14
    2260:	df 90       	pop	r13
    2262:	cf 90       	pop	r12
    2264:	08 95       	ret

00002266 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2266:	cf 92       	push	r12
    2268:	df 92       	push	r13
    226a:	ef 92       	push	r14
    226c:	ff 92       	push	r15
    226e:	6b 01       	movw	r12, r22
    2270:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2272:	67 2b       	or	r22, r23
    2274:	68 2b       	or	r22, r24
    2276:	69 2b       	or	r22, r25
    2278:	e9 f0       	breq	.+58     	; 0x22b4 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    227a:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    227e:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    2282:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    2286:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    228a:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    228e:	c8 0e       	add	r12, r24
    2290:	d9 1e       	adc	r13, r25
    2292:	ea 1e       	adc	r14, r26
    2294:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2296:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    229a:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    229e:	02 96       	adiw	r24, 0x02	; 2
    22a0:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22a4:	c7 01       	movw	r24, r14
    22a6:	b6 01       	movw	r22, r12
    22a8:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    22ac:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22b0:	81 11       	cpse	r24, r1
    22b2:	02 c0       	rjmp	.+4      	; 0x22b8 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    22b4:	0e 94 39 0a 	call	0x1472	; 0x1472 <vPortYield>
		}
	}
    22b8:	ff 90       	pop	r15
    22ba:	ef 90       	pop	r14
    22bc:	df 90       	pop	r13
    22be:	cf 90       	pop	r12
    22c0:	08 95       	ret

000022c2 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22c2:	80 91 a6 40 	lds	r24, 0x40A6	; 0x8040a6 <uxSchedulerSuspended>
    22c6:	81 11       	cpse	r24, r1
    22c8:	0c c0       	rjmp	.+24     	; 0x22e2 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22ca:	e0 91 a8 40 	lds	r30, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    22ce:	4b e0       	ldi	r20, 0x0B	; 11
    22d0:	e4 9f       	mul	r30, r20
    22d2:	f0 01       	movw	r30, r0
    22d4:	11 24       	eor	r1, r1
    22d6:	ea 52       	subi	r30, 0x2A	; 42
    22d8:	ff 4b       	sbci	r31, 0xBF	; 191
    22da:	80 81       	ld	r24, Z
    22dc:	88 23       	and	r24, r24
    22de:	29 f0       	breq	.+10     	; 0x22ea <vTaskSwitchContext+0x28>
    22e0:	14 c0       	rjmp	.+40     	; 0x230a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	80 93 a4 40 	sts	0x40A4, r24	; 0x8040a4 <xMissedYield>
    22e8:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22ea:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    22ec:	80 91 a8 40 	lds	r24, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    22f0:	81 50       	subi	r24, 0x01	; 1
    22f2:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22f6:	e0 91 a8 40 	lds	r30, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    22fa:	9e 9f       	mul	r25, r30
    22fc:	f0 01       	movw	r30, r0
    22fe:	11 24       	eor	r1, r1
    2300:	ea 52       	subi	r30, 0x2A	; 42
    2302:	ff 4b       	sbci	r31, 0xBF	; 191
    2304:	80 81       	ld	r24, Z
    2306:	88 23       	and	r24, r24
    2308:	89 f3       	breq	.-30     	; 0x22ec <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    230a:	80 91 a8 40 	lds	r24, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    230e:	28 2f       	mov	r18, r24
    2310:	30 e0       	ldi	r19, 0x00	; 0
    2312:	4b e0       	ldi	r20, 0x0B	; 11
    2314:	84 9f       	mul	r24, r20
    2316:	c0 01       	movw	r24, r0
    2318:	11 24       	eor	r1, r1
    231a:	dc 01       	movw	r26, r24
    231c:	aa 52       	subi	r26, 0x2A	; 42
    231e:	bf 4b       	sbci	r27, 0xBF	; 191
    2320:	11 96       	adiw	r26, 0x01	; 1
    2322:	ed 91       	ld	r30, X+
    2324:	fc 91       	ld	r31, X
    2326:	12 97       	sbiw	r26, 0x02	; 2
    2328:	04 80       	ldd	r0, Z+4	; 0x04
    232a:	f5 81       	ldd	r31, Z+5	; 0x05
    232c:	e0 2d       	mov	r30, r0
    232e:	11 96       	adiw	r26, 0x01	; 1
    2330:	ed 93       	st	X+, r30
    2332:	fc 93       	st	X, r31
    2334:	12 97       	sbiw	r26, 0x02	; 2
    2336:	87 52       	subi	r24, 0x27	; 39
    2338:	9f 4b       	sbci	r25, 0xBF	; 191
    233a:	e8 17       	cp	r30, r24
    233c:	f9 07       	cpc	r31, r25
    233e:	61 f4       	brne	.+24     	; 0x2358 <vTaskSwitchContext+0x96>
    2340:	84 81       	ldd	r24, Z+4	; 0x04
    2342:	95 81       	ldd	r25, Z+5	; 0x05
    2344:	4b e0       	ldi	r20, 0x0B	; 11
    2346:	42 9f       	mul	r20, r18
    2348:	f0 01       	movw	r30, r0
    234a:	43 9f       	mul	r20, r19
    234c:	f0 0d       	add	r31, r0
    234e:	11 24       	eor	r1, r1
    2350:	ea 52       	subi	r30, 0x2A	; 42
    2352:	ff 4b       	sbci	r31, 0xBF	; 191
    2354:	81 83       	std	Z+1, r24	; 0x01
    2356:	92 83       	std	Z+2, r25	; 0x02
    2358:	8b e0       	ldi	r24, 0x0B	; 11
    235a:	82 9f       	mul	r24, r18
    235c:	f0 01       	movw	r30, r0
    235e:	83 9f       	mul	r24, r19
    2360:	f0 0d       	add	r31, r0
    2362:	11 24       	eor	r1, r1
    2364:	ea 52       	subi	r30, 0x2A	; 42
    2366:	ff 4b       	sbci	r31, 0xBF	; 191
    2368:	01 80       	ldd	r0, Z+1	; 0x01
    236a:	f2 81       	ldd	r31, Z+2	; 0x02
    236c:	e0 2d       	mov	r30, r0
    236e:	80 85       	ldd	r24, Z+8	; 0x08
    2370:	91 85       	ldd	r25, Z+9	; 0x09
    2372:	80 93 02 41 	sts	0x4102, r24	; 0x804102 <pxCurrentTCB>
    2376:	90 93 03 41 	sts	0x4103, r25	; 0x804103 <pxCurrentTCB+0x1>
    237a:	08 95       	ret

0000237c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    237c:	cf 92       	push	r12
    237e:	df 92       	push	r13
    2380:	ef 92       	push	r14
    2382:	ff 92       	push	r15
    2384:	6a 01       	movw	r12, r20
    2386:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2388:	60 91 02 41 	lds	r22, 0x4102	; 0x804102 <pxCurrentTCB>
    238c:	70 91 03 41 	lds	r23, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    2390:	62 5f       	subi	r22, 0xF2	; 242
    2392:	7f 4f       	sbci	r23, 0xFF	; 255
    2394:	0e 94 14 09 	call	0x1228	; 0x1228 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2398:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    239c:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    23a0:	02 96       	adiw	r24, 0x02	; 2
    23a2:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    23a6:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    23aa:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    23ae:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    23b2:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    23b6:	bc 01       	movw	r22, r24
    23b8:	cd 01       	movw	r24, r26
    23ba:	6c 0d       	add	r22, r12
    23bc:	7d 1d       	adc	r23, r13
    23be:	8e 1d       	adc	r24, r14
    23c0:	9f 1d       	adc	r25, r15
    23c2:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    23c6:	ff 90       	pop	r15
    23c8:	ef 90       	pop	r14
    23ca:	df 90       	pop	r13
    23cc:	cf 90       	pop	r12
    23ce:	08 95       	ret

000023d0 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    23d0:	0f 93       	push	r16
    23d2:	1f 93       	push	r17
    23d4:	cf 93       	push	r28
    23d6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23d8:	dc 01       	movw	r26, r24
    23da:	17 96       	adiw	r26, 0x07	; 7
    23dc:	ed 91       	ld	r30, X+
    23de:	fc 91       	ld	r31, X
    23e0:	18 97       	sbiw	r26, 0x08	; 8
    23e2:	c0 85       	ldd	r28, Z+8	; 0x08
    23e4:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    23e6:	8e 01       	movw	r16, r28
    23e8:	02 5f       	subi	r16, 0xF2	; 242
    23ea:	1f 4f       	sbci	r17, 0xFF	; 255
    23ec:	c8 01       	movw	r24, r16
    23ee:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23f2:	80 91 a6 40 	lds	r24, 0x40A6	; 0x8040a6 <uxSchedulerSuspended>
    23f6:	81 11       	cpse	r24, r1
    23f8:	16 c0       	rjmp	.+44     	; 0x2426 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    23fa:	0c 50       	subi	r16, 0x0C	; 12
    23fc:	11 09       	sbc	r17, r1
    23fe:	c8 01       	movw	r24, r16
    2400:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2404:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2406:	90 91 a8 40 	lds	r25, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    240a:	98 17       	cp	r25, r24
    240c:	10 f4       	brcc	.+4      	; 0x2412 <xTaskRemoveFromEventList+0x42>
    240e:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
    2412:	bb e0       	ldi	r27, 0x0B	; 11
    2414:	8b 9f       	mul	r24, r27
    2416:	c0 01       	movw	r24, r0
    2418:	11 24       	eor	r1, r1
    241a:	b8 01       	movw	r22, r16
    241c:	8a 52       	subi	r24, 0x2A	; 42
    241e:	9f 4b       	sbci	r25, 0xBF	; 191
    2420:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    2424:	05 c0       	rjmp	.+10     	; 0x2430 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2426:	b8 01       	movw	r22, r16
    2428:	81 eb       	ldi	r24, 0xB1	; 177
    242a:	90 e4       	ldi	r25, 0x40	; 64
    242c:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2430:	e0 91 02 41 	lds	r30, 0x4102	; 0x804102 <pxCurrentTCB>
    2434:	f0 91 03 41 	lds	r31, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    243c:	92 8d       	ldd	r25, Z+26	; 0x1a
    243e:	29 17       	cp	r18, r25
    2440:	08 f4       	brcc	.+2      	; 0x2444 <xTaskRemoveFromEventList+0x74>
    2442:	80 e0       	ldi	r24, 0x00	; 0
}
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	1f 91       	pop	r17
    244a:	0f 91       	pop	r16
    244c:	08 95       	ret

0000244e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    244e:	20 91 a3 40 	lds	r18, 0x40A3	; 0x8040a3 <xNumOfOverflows>
    2452:	fc 01       	movw	r30, r24
    2454:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2456:	40 91 aa 40 	lds	r20, 0x40AA	; 0x8040aa <xTickCount>
    245a:	50 91 ab 40 	lds	r21, 0x40AB	; 0x8040ab <xTickCount+0x1>
    245e:	60 91 ac 40 	lds	r22, 0x40AC	; 0x8040ac <xTickCount+0x2>
    2462:	70 91 ad 40 	lds	r23, 0x40AD	; 0x8040ad <xTickCount+0x3>
    2466:	41 83       	std	Z+1, r20	; 0x01
    2468:	52 83       	std	Z+2, r21	; 0x02
    246a:	63 83       	std	Z+3, r22	; 0x03
    246c:	74 83       	std	Z+4, r23	; 0x04
    246e:	08 95       	ret

00002470 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2470:	8f 92       	push	r8
    2472:	9f 92       	push	r9
    2474:	af 92       	push	r10
    2476:	bf 92       	push	r11
    2478:	cf 92       	push	r12
    247a:	df 92       	push	r13
    247c:	ef 92       	push	r14
    247e:	ff 92       	push	r15
    2480:	0f 93       	push	r16
    2482:	1f 93       	push	r17
    2484:	cf 93       	push	r28
    2486:	df 93       	push	r29
    2488:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    248a:	0f b6       	in	r0, 0x3f	; 63
    248c:	f8 94       	cli
    248e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2490:	80 91 a3 40 	lds	r24, 0x40A3	; 0x8040a3 <xNumOfOverflows>
    2494:	90 81       	ld	r25, Z
    2496:	98 17       	cp	r25, r24
    2498:	89 f0       	breq	.+34     	; 0x24bc <xTaskCheckForTimeOut+0x4c>
    249a:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    249e:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    24a2:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    24a6:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    24aa:	01 81       	ldd	r16, Z+1	; 0x01
    24ac:	12 81       	ldd	r17, Z+2	; 0x02
    24ae:	23 81       	ldd	r18, Z+3	; 0x03
    24b0:	34 81       	ldd	r19, Z+4	; 0x04
    24b2:	80 17       	cp	r24, r16
    24b4:	91 07       	cpc	r25, r17
    24b6:	a2 07       	cpc	r26, r18
    24b8:	b3 07       	cpc	r27, r19
    24ba:	a8 f5       	brcc	.+106    	; 0x2526 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    24bc:	80 91 aa 40 	lds	r24, 0x40AA	; 0x8040aa <xTickCount>
    24c0:	90 91 ab 40 	lds	r25, 0x40AB	; 0x8040ab <xTickCount+0x1>
    24c4:	a0 91 ac 40 	lds	r26, 0x40AC	; 0x8040ac <xTickCount+0x2>
    24c8:	b0 91 ad 40 	lds	r27, 0x40AD	; 0x8040ad <xTickCount+0x3>
    24cc:	c1 80       	ldd	r12, Z+1	; 0x01
    24ce:	d2 80       	ldd	r13, Z+2	; 0x02
    24d0:	e3 80       	ldd	r14, Z+3	; 0x03
    24d2:	f4 80       	ldd	r15, Z+4	; 0x04
    24d4:	eb 01       	movw	r28, r22
    24d6:	08 81       	ld	r16, Y
    24d8:	19 81       	ldd	r17, Y+1	; 0x01
    24da:	2a 81       	ldd	r18, Y+2	; 0x02
    24dc:	3b 81       	ldd	r19, Y+3	; 0x03
    24de:	8c 19       	sub	r24, r12
    24e0:	9d 09       	sbc	r25, r13
    24e2:	ae 09       	sbc	r26, r14
    24e4:	bf 09       	sbc	r27, r15
    24e6:	80 17       	cp	r24, r16
    24e8:	91 07       	cpc	r25, r17
    24ea:	a2 07       	cpc	r26, r18
    24ec:	b3 07       	cpc	r27, r19
    24ee:	e8 f4       	brcc	.+58     	; 0x252a <xTaskCheckForTimeOut+0xba>
    24f0:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    24f2:	80 90 aa 40 	lds	r8, 0x40AA	; 0x8040aa <xTickCount>
    24f6:	90 90 ab 40 	lds	r9, 0x40AB	; 0x8040ab <xTickCount+0x1>
    24fa:	a0 90 ac 40 	lds	r10, 0x40AC	; 0x8040ac <xTickCount+0x2>
    24fe:	b0 90 ad 40 	lds	r11, 0x40AD	; 0x8040ad <xTickCount+0x3>
    2502:	b5 01       	movw	r22, r10
    2504:	a4 01       	movw	r20, r8
    2506:	4c 19       	sub	r20, r12
    2508:	5d 09       	sbc	r21, r13
    250a:	6e 09       	sbc	r22, r14
    250c:	7f 09       	sbc	r23, r15
    250e:	04 1b       	sub	r16, r20
    2510:	15 0b       	sbc	r17, r21
    2512:	26 0b       	sbc	r18, r22
    2514:	37 0b       	sbc	r19, r23
    2516:	08 83       	st	Y, r16
    2518:	19 83       	std	Y+1, r17	; 0x01
    251a:	2a 83       	std	Y+2, r18	; 0x02
    251c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    251e:	0e 94 27 12 	call	0x244e	; 0x244e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2522:	80 e0       	ldi	r24, 0x00	; 0
    2524:	03 c0       	rjmp	.+6      	; 0x252c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	01 c0       	rjmp	.+2      	; 0x252c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    252a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    252c:	0f 90       	pop	r0
    252e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2530:	df 91       	pop	r29
    2532:	cf 91       	pop	r28
    2534:	1f 91       	pop	r17
    2536:	0f 91       	pop	r16
    2538:	ff 90       	pop	r15
    253a:	ef 90       	pop	r14
    253c:	df 90       	pop	r13
    253e:	cf 90       	pop	r12
    2540:	bf 90       	pop	r11
    2542:	af 90       	pop	r10
    2544:	9f 90       	pop	r9
    2546:	8f 90       	pop	r8
    2548:	08 95       	ret

0000254a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    254a:	81 e0       	ldi	r24, 0x01	; 1
    254c:	80 93 a4 40 	sts	0x40A4, r24	; 0x8040a4 <xMissedYield>
    2550:	08 95       	ret

00002552 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2552:	00 97       	sbiw	r24, 0x00	; 0
    2554:	21 f4       	brne	.+8      	; 0x255e <uxTaskGetStackHighWaterMark+0xc>
    2556:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    255a:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    255e:	dc 01       	movw	r26, r24
    2560:	5b 96       	adiw	r26, 0x1b	; 27
    2562:	ed 91       	ld	r30, X+
    2564:	fc 91       	ld	r31, X
    2566:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2568:	80 81       	ld	r24, Z
    256a:	81 31       	cpi	r24, 0x11	; 17
    256c:	41 f4       	brne	.+16     	; 0x257e <uxTaskGetStackHighWaterMark+0x2c>
    256e:	31 96       	adiw	r30, 0x01	; 1
    2570:	80 e0       	ldi	r24, 0x00	; 0
    2572:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2574:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2576:	21 91       	ld	r18, Z+
    2578:	21 31       	cpi	r18, 0x11	; 17
    257a:	e1 f3       	breq	.-8      	; 0x2574 <uxTaskGetStackHighWaterMark+0x22>
    257c:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    257e:	80 e0       	ldi	r24, 0x00	; 0
    2580:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2582:	08 95       	ret

00002584 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2584:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxCurrentTCB>
    2588:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxCurrentTCB+0x1>

		return xReturn;
	}
    258c:	08 95       	ret

0000258e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    258e:	0f 93       	push	r16
    2590:	1f 93       	push	r17
    2592:	cf 93       	push	r28
    2594:	df 93       	push	r29
    2596:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2598:	22 8d       	ldd	r18, Z+26	; 0x1a
    259a:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    259e:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    25a2:	5a 96       	adiw	r26, 0x1a	; 26
    25a4:	8c 91       	ld	r24, X
    25a6:	28 17       	cp	r18, r24
    25a8:	08 f0       	brcs	.+2      	; 0x25ac <vTaskPriorityInherit+0x1e>
    25aa:	41 c0       	rjmp	.+130    	; 0x262e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    25ac:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    25b0:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    25b4:	5a 96       	adiw	r26, 0x1a	; 26
    25b6:	3c 91       	ld	r19, X
    25b8:	84 e0       	ldi	r24, 0x04	; 4
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	a0 e0       	ldi	r26, 0x00	; 0
    25be:	b0 e0       	ldi	r27, 0x00	; 0
    25c0:	83 1b       	sub	r24, r19
    25c2:	91 09       	sbc	r25, r1
    25c4:	a1 09       	sbc	r26, r1
    25c6:	b1 09       	sbc	r27, r1
    25c8:	86 87       	std	Z+14, r24	; 0x0e
    25ca:	97 87       	std	Z+15, r25	; 0x0f
    25cc:	a0 8b       	std	Z+16, r26	; 0x10
    25ce:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    25d0:	8b e0       	ldi	r24, 0x0B	; 11
    25d2:	28 9f       	mul	r18, r24
    25d4:	90 01       	movw	r18, r0
    25d6:	11 24       	eor	r1, r1
    25d8:	2a 52       	subi	r18, 0x2A	; 42
    25da:	3f 4b       	sbci	r19, 0xBF	; 191
    25dc:	84 85       	ldd	r24, Z+12	; 0x0c
    25de:	95 85       	ldd	r25, Z+13	; 0x0d
    25e0:	82 17       	cp	r24, r18
    25e2:	93 07       	cpc	r25, r19
    25e4:	e9 f4       	brne	.+58     	; 0x2620 <vTaskPriorityInherit+0x92>
    25e6:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    25e8:	ef 01       	movw	r28, r30
    25ea:	22 96       	adiw	r28, 0x02	; 2
    25ec:	ce 01       	movw	r24, r28
    25ee:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    25f2:	e0 91 02 41 	lds	r30, 0x4102	; 0x804102 <pxCurrentTCB>
    25f6:	f0 91 03 41 	lds	r31, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    25fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    25fc:	f8 01       	movw	r30, r16
    25fe:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2600:	90 91 a8 40 	lds	r25, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    2604:	98 17       	cp	r25, r24
    2606:	10 f4       	brcc	.+4      	; 0x260c <vTaskPriorityInherit+0x7e>
    2608:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
    260c:	fb e0       	ldi	r31, 0x0B	; 11
    260e:	8f 9f       	mul	r24, r31
    2610:	c0 01       	movw	r24, r0
    2612:	11 24       	eor	r1, r1
    2614:	be 01       	movw	r22, r28
    2616:	8a 52       	subi	r24, 0x2A	; 42
    2618:	9f 4b       	sbci	r25, 0xBF	; 191
    261a:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    261e:	07 c0       	rjmp	.+14     	; 0x262e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2620:	a0 91 02 41 	lds	r26, 0x4102	; 0x804102 <pxCurrentTCB>
    2624:	b0 91 03 41 	lds	r27, 0x4103	; 0x804103 <pxCurrentTCB+0x1>
    2628:	5a 96       	adiw	r26, 0x1a	; 26
    262a:	8c 91       	ld	r24, X
    262c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    262e:	df 91       	pop	r29
    2630:	cf 91       	pop	r28
    2632:	1f 91       	pop	r17
    2634:	0f 91       	pop	r16
    2636:	08 95       	ret

00002638 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2638:	0f 93       	push	r16
    263a:	1f 93       	push	r17
    263c:	cf 93       	push	r28
    263e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2640:	00 97       	sbiw	r24, 0x00	; 0
    2642:	49 f1       	breq	.+82     	; 0x2696 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2644:	fc 01       	movw	r30, r24
    2646:	32 8d       	ldd	r19, Z+26	; 0x1a
    2648:	27 a1       	ldd	r18, Z+39	; 0x27
    264a:	32 17       	cp	r19, r18
    264c:	21 f1       	breq	.+72     	; 0x2696 <vTaskPriorityDisinherit+0x5e>
    264e:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2650:	8c 01       	movw	r16, r24
    2652:	0e 5f       	subi	r16, 0xFE	; 254
    2654:	1f 4f       	sbci	r17, 0xFF	; 255
    2656:	c8 01       	movw	r24, r16
    2658:	0e 94 5f 09 	call	0x12be	; 0x12be <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    265c:	8f a1       	ldd	r24, Y+39	; 0x27
    265e:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2660:	44 e0       	ldi	r20, 0x04	; 4
    2662:	50 e0       	ldi	r21, 0x00	; 0
    2664:	60 e0       	ldi	r22, 0x00	; 0
    2666:	70 e0       	ldi	r23, 0x00	; 0
    2668:	48 1b       	sub	r20, r24
    266a:	51 09       	sbc	r21, r1
    266c:	61 09       	sbc	r22, r1
    266e:	71 09       	sbc	r23, r1
    2670:	4e 87       	std	Y+14, r20	; 0x0e
    2672:	5f 87       	std	Y+15, r21	; 0x0f
    2674:	68 8b       	std	Y+16, r22	; 0x10
    2676:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2678:	90 91 a8 40 	lds	r25, 0x40A8	; 0x8040a8 <uxTopReadyPriority>
    267c:	98 17       	cp	r25, r24
    267e:	10 f4       	brcc	.+4      	; 0x2684 <vTaskPriorityDisinherit+0x4c>
    2680:	80 93 a8 40 	sts	0x40A8, r24	; 0x8040a8 <uxTopReadyPriority>
    2684:	fb e0       	ldi	r31, 0x0B	; 11
    2686:	8f 9f       	mul	r24, r31
    2688:	c0 01       	movw	r24, r0
    268a:	11 24       	eor	r1, r1
    268c:	b8 01       	movw	r22, r16
    268e:	8a 52       	subi	r24, 0x2A	; 42
    2690:	9f 4b       	sbci	r25, 0xBF	; 191
    2692:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
			}
		}
	}
    2696:	df 91       	pop	r29
    2698:	cf 91       	pop	r28
    269a:	1f 91       	pop	r17
    269c:	0f 91       	pop	r16
    269e:	08 95       	ret

000026a0 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    26a0:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    26a2:	e8 81       	ld	r30, Y
    26a4:	f9 81       	ldd	r31, Y+1	; 0x01
    26a6:	01 90       	ld	r0, Z+
    26a8:	f0 81       	ld	r31, Z
    26aa:	e0 2d       	mov	r30, r0
    26ac:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    26ae:	1a 82       	std	Y+2, r1	; 0x02
    26b0:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    26b2:	6f ef       	ldi	r22, 0xFF	; 255
    26b4:	7f ef       	ldi	r23, 0xFF	; 255
    26b6:	cb 01       	movw	r24, r22
    26b8:	0e 94 33 11 	call	0x2266	; 0x2266 <vTaskDelay>
    26bc:	fa cf       	rjmp	.-12     	; 0x26b2 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000026be <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    26be:	fc 01       	movw	r30, r24
    26c0:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    26c2:	65 87       	std	Z+13, r22	; 0x0d
    26c4:	08 95       	ret

000026c6 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    26c6:	4f 92       	push	r4
    26c8:	5f 92       	push	r5
    26ca:	6f 92       	push	r6
    26cc:	7f 92       	push	r7
    26ce:	8f 92       	push	r8
    26d0:	9f 92       	push	r9
    26d2:	af 92       	push	r10
    26d4:	bf 92       	push	r11
    26d6:	cf 92       	push	r12
    26d8:	df 92       	push	r13
    26da:	ef 92       	push	r14
    26dc:	ff 92       	push	r15
    26de:	0f 93       	push	r16
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	2a 97       	sbiw	r28, 0x0a	; 10
    26ec:	cd bf       	out	0x3d, r28	; 61
    26ee:	de bf       	out	0x3e, r29	; 62
    26f0:	4c 01       	movw	r8, r24
    26f2:	29 01       	movw	r4, r18
    26f4:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    26f6:	87 e2       	ldi	r24, 0x27	; 39
    26f8:	90 e2       	ldi	r25, 0x20	; 32
    26fa:	f4 01       	movw	r30, r8
    26fc:	80 83       	st	Z, r24
    26fe:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2700:	fb 01       	movw	r30, r22
    2702:	80 81       	ld	r24, Z
    2704:	88 23       	and	r24, r24
    2706:	69 f0       	breq	.+26     	; 0x2722 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2708:	de 01       	movw	r26, r28
    270a:	11 96       	adiw	r26, 0x01	; 1
    270c:	31 96       	adiw	r30, 0x01	; 1
    270e:	90 e0       	ldi	r25, 0x00	; 0
    2710:	02 c0       	rjmp	.+4      	; 0x2716 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2712:	99 30       	cpi	r25, 0x09	; 9
    2714:	39 f0       	breq	.+14     	; 0x2724 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2716:	9f 5f       	subi	r25, 0xFF	; 255
    2718:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    271a:	81 91       	ld	r24, Z+
    271c:	81 11       	cpse	r24, r1
    271e:	f9 cf       	rjmp	.-14     	; 0x2712 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2720:	01 c0       	rjmp	.+2      	; 0x2724 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2722:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2724:	e1 e0       	ldi	r30, 0x01	; 1
    2726:	f0 e0       	ldi	r31, 0x00	; 0
    2728:	ec 0f       	add	r30, r28
    272a:	fd 1f       	adc	r31, r29
    272c:	e9 0f       	add	r30, r25
    272e:	f1 1d       	adc	r31, r1
    2730:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2732:	74 01       	movw	r14, r8
    2734:	f2 e0       	ldi	r31, 0x02	; 2
    2736:	ef 0e       	add	r14, r31
    2738:	f1 1c       	adc	r15, r1
    273a:	a1 2c       	mov	r10, r1
    273c:	b1 2c       	mov	r11, r1
    273e:	c1 2c       	mov	r12, r1
    2740:	d1 2c       	mov	r13, r1
    2742:	04 2f       	mov	r16, r20
    2744:	94 01       	movw	r18, r8
    2746:	a2 01       	movw	r20, r4
    2748:	be 01       	movw	r22, r28
    274a:	6f 5f       	subi	r22, 0xFF	; 255
    274c:	7f 4f       	sbci	r23, 0xFF	; 255
    274e:	8c e9       	ldi	r24, 0x9C	; 156
    2750:	92 e0       	ldi	r25, 0x02	; 2
    2752:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2756:	f4 01       	movw	r30, r8
    2758:	66 82       	std	Z+6, r6	; 0x06
    275a:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    275c:	40 86       	std	Z+8, r4	; 0x08
    275e:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2760:	20 91 04 41 	lds	r18, 0x4104	; 0x804104 <last_created_task_pointer>
    2764:	30 91 05 41 	lds	r19, 0x4105	; 0x804105 <last_created_task_pointer+0x1>
    2768:	24 83       	std	Z+4, r18	; 0x04
    276a:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    276c:	80 92 04 41 	sts	0x4104, r8	; 0x804104 <last_created_task_pointer>
    2770:	90 92 05 41 	sts	0x4105, r9	; 0x804105 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2774:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2776:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2778:	40 90 42 41 	lds	r4, 0x4142	; 0x804142 <portStackTopForTask>
    277c:	50 90 43 41 	lds	r5, 0x4143	; 0x804143 <portStackTopForTask+0x1>
    2780:	ff ef       	ldi	r31, 0xFF	; 255
    2782:	4f 1a       	sub	r4, r31
    2784:	5f 0a       	sbc	r5, r31
    2786:	40 92 42 41 	sts	0x4142, r4	; 0x804142 <portStackTopForTask>
    278a:	50 92 43 41 	sts	0x4143, r5	; 0x804143 <portStackTopForTask+0x1>
    278e:	f4 01       	movw	r30, r8
    2790:	42 86       	std	Z+10, r4	; 0x0a
    2792:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2794:	16 86       	std	Z+14, r1	; 0x0e
    2796:	17 86       	std	Z+15, r1	; 0x0f
    2798:	10 8a       	std	Z+16, r1	; 0x10
    279a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    279c:	61 14       	cp	r6, r1
    279e:	71 04       	cpc	r7, r1
    27a0:	09 f4       	brne	.+2      	; 0x27a4 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    27a2:	44 c0       	rjmp	.+136    	; 0x282c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    27a4:	81 30       	cpi	r24, 0x01	; 1
    27a6:	79 f5       	brne	.+94     	; 0x2806 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    27a8:	6a e0       	ldi	r22, 0x0A	; 10
    27aa:	c3 01       	movw	r24, r6
    27ac:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    27b0:	7c 01       	movw	r14, r24
    27b2:	65 e8       	ldi	r22, 0x85	; 133
    27b4:	74 e0       	ldi	r23, 0x04	; 4
    27b6:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    27ba:	be 01       	movw	r22, r28
    27bc:	6f 5f       	subi	r22, 0xFF	; 255
    27be:	7f 4f       	sbci	r23, 0xFF	; 255
    27c0:	c7 01       	movw	r24, r14
    27c2:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    27c6:	6a e0       	ldi	r22, 0x0A	; 10
    27c8:	c7 01       	movw	r24, r14
    27ca:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    27ce:	7c 01       	movw	r14, r24
    27d0:	6c e7       	ldi	r22, 0x7C	; 124
    27d2:	74 e0       	ldi	r23, 0x04	; 4
    27d4:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    27d8:	6a e0       	ldi	r22, 0x0A	; 10
    27da:	c7 01       	movw	r24, r14
    27dc:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    27e0:	7c 01       	movw	r14, r24
    27e2:	6e e6       	ldi	r22, 0x6E	; 110
    27e4:	74 e0       	ldi	r23, 0x04	; 4
    27e6:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    27ea:	63 e0       	ldi	r22, 0x03	; 3
    27ec:	c7 01       	movw	r24, r14
    27ee:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    27f2:	b2 01       	movw	r22, r4
    27f4:	0e 94 29 19 	call	0x3252	; 0x3252 <_ZN8emstreamlsEj>
    27f8:	62 e0       	ldi	r22, 0x02	; 2
    27fa:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    27fe:	66 e0       	ldi	r22, 0x06	; 6
    2800:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2804:	13 c0       	rjmp	.+38     	; 0x282c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2806:	6a e0       	ldi	r22, 0x0A	; 10
    2808:	c3 01       	movw	r24, r6
    280a:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    280e:	4c 01       	movw	r8, r24
    2810:	69 e5       	ldi	r22, 0x59	; 89
    2812:	74 e0       	ldi	r23, 0x04	; 4
    2814:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2818:	be 01       	movw	r22, r28
    281a:	6f 5f       	subi	r22, 0xFF	; 255
    281c:	7f 4f       	sbci	r23, 0xFF	; 255
    281e:	c4 01       	movw	r24, r8
    2820:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2824:	66 e0       	ldi	r22, 0x06	; 6
    2826:	c4 01       	movw	r24, r8
    2828:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    282c:	2a 96       	adiw	r28, 0x0a	; 10
    282e:	cd bf       	out	0x3d, r28	; 61
    2830:	de bf       	out	0x3e, r29	; 62
    2832:	df 91       	pop	r29
    2834:	cf 91       	pop	r28
    2836:	1f 91       	pop	r17
    2838:	0f 91       	pop	r16
    283a:	ff 90       	pop	r15
    283c:	ef 90       	pop	r14
    283e:	df 90       	pop	r13
    2840:	cf 90       	pop	r12
    2842:	bf 90       	pop	r11
    2844:	af 90       	pop	r10
    2846:	9f 90       	pop	r9
    2848:	8f 90       	pop	r8
    284a:	7f 90       	pop	r7
    284c:	6f 90       	pop	r6
    284e:	5f 90       	pop	r5
    2850:	4f 90       	pop	r4
    2852:	08 95       	ret

00002854 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2854:	cf 92       	push	r12
    2856:	df 92       	push	r13
    2858:	ef 92       	push	r14
    285a:	ff 92       	push	r15
    285c:	0f 93       	push	r16
    285e:	1f 93       	push	r17
    2860:	cf 93       	push	r28
    2862:	df 93       	push	r29
    2864:	ec 01       	movw	r28, r24
    2866:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2868:	8a 81       	ldd	r24, Y+2	; 0x02
    286a:	9b 81       	ldd	r25, Y+3	; 0x03
    286c:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <pcTaskGetTaskName>
    2870:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2872:	6a e0       	ldi	r22, 0x0A	; 10
    2874:	c7 01       	movw	r24, r14
    2876:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    287a:	8c 01       	movw	r16, r24
    287c:	68 e9       	ldi	r22, 0x98	; 152
    287e:	74 e0       	ldi	r23, 0x04	; 4
    2880:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2884:	6a e0       	ldi	r22, 0x0A	; 10
    2886:	c8 01       	movw	r24, r16
    2888:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    288c:	8c 01       	movw	r16, r24
    288e:	61 e9       	ldi	r22, 0x91	; 145
    2890:	74 e0       	ldi	r23, 0x04	; 4
    2892:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2896:	b6 01       	movw	r22, r12
    2898:	c8 01       	movw	r24, r16
    289a:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    289e:	6a e0       	ldi	r22, 0x0A	; 10
    28a0:	c8 01       	movw	r24, r16
    28a2:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    28a6:	8c 01       	movw	r16, r24
    28a8:	6b e8       	ldi	r22, 0x8B	; 139
    28aa:	74 e0       	ldi	r23, 0x04	; 4
    28ac:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    28b0:	66 e0       	ldi	r22, 0x06	; 6
    28b2:	c8 01       	movw	r24, r16
    28b4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    28b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    28ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    28bc:	e8 85       	ldd	r30, Y+8	; 0x08
    28be:	f9 85       	ldd	r31, Y+9	; 0x09
    28c0:	01 e1       	ldi	r16, 0x11	; 17
    28c2:	21 e0       	ldi	r18, 0x01	; 1
    28c4:	a7 01       	movw	r20, r14
    28c6:	bc 01       	movw	r22, r24
    28c8:	8e 1b       	sub	r24, r30
    28ca:	9f 0b       	sbc	r25, r31
    28cc:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    28d0:	8c 81       	ldd	r24, Y+4	; 0x04
    28d2:	9d 81       	ldd	r25, Y+5	; 0x05
    28d4:	00 97       	sbiw	r24, 0x00	; 0
    28d6:	19 f0       	breq	.+6      	; 0x28de <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    28d8:	b7 01       	movw	r22, r14
    28da:	0e 94 2a 14 	call	0x2854	; 0x2854 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    28de:	df 91       	pop	r29
    28e0:	cf 91       	pop	r28
    28e2:	1f 91       	pop	r17
    28e4:	0f 91       	pop	r16
    28e6:	ff 90       	pop	r15
    28e8:	ef 90       	pop	r14
    28ea:	df 90       	pop	r13
    28ec:	cf 90       	pop	r12
    28ee:	08 95       	ret

000028f0 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    28f0:	0f 93       	push	r16
    28f2:	1f 93       	push	r17
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    28fa:	80 91 04 41 	lds	r24, 0x4104	; 0x804104 <last_created_task_pointer>
    28fe:	90 91 05 41 	lds	r25, 0x4105	; 0x804105 <last_created_task_pointer+0x1>
    2902:	00 97       	sbiw	r24, 0x00	; 0
    2904:	19 f0       	breq	.+6      	; 0x290c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2906:	be 01       	movw	r22, r28
    2908:	0e 94 2a 14 	call	0x2854	; 0x2854 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    290c:	6a e0       	ldi	r22, 0x0A	; 10
    290e:	ce 01       	movw	r24, r28
    2910:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2914:	8c 01       	movw	r16, r24
    2916:	6e ea       	ldi	r22, 0xAE	; 174
    2918:	74 e0       	ldi	r23, 0x04	; 4
    291a:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    291e:	6a e0       	ldi	r22, 0x0A	; 10
    2920:	c8 01       	movw	r24, r16
    2922:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2926:	8c 01       	movw	r16, r24
    2928:	63 ea       	ldi	r22, 0xA3	; 163
    292a:	74 e0       	ldi	r23, 0x04	; 4
    292c:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2930:	6a e0       	ldi	r22, 0x0A	; 10
    2932:	c8 01       	movw	r24, r16
    2934:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2938:	8c 01       	movw	r16, r24
    293a:	6d e9       	ldi	r22, 0x9D	; 157
    293c:	74 e0       	ldi	r23, 0x04	; 4
    293e:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2942:	66 e0       	ldi	r22, 0x06	; 6
    2944:	c8 01       	movw	r24, r16
    2946:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    294a:	80 91 42 41 	lds	r24, 0x4142	; 0x804142 <portStackTopForTask>
    294e:	90 91 43 41 	lds	r25, 0x4143	; 0x804143 <portStackTopForTask+0x1>
    2952:	bc 01       	movw	r22, r24
    2954:	6f 5f       	subi	r22, 0xFF	; 255
    2956:	7f 4f       	sbci	r23, 0xFF	; 255
    2958:	01 e1       	ldi	r16, 0x11	; 17
    295a:	21 e0       	ldi	r18, 0x01	; 1
    295c:	ae 01       	movw	r20, r28
    295e:	83 56       	subi	r24, 0x63	; 99
    2960:	91 09       	sbc	r25, r1
    2962:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2966:	df 91       	pop	r29
    2968:	cf 91       	pop	r28
    296a:	1f 91       	pop	r17
    296c:	0f 91       	pop	r16
    296e:	08 95       	ret

00002970 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2970:	8f 92       	push	r8
    2972:	9f 92       	push	r9
    2974:	af 92       	push	r10
    2976:	bf 92       	push	r11
    2978:	cf 92       	push	r12
    297a:	df 92       	push	r13
    297c:	ef 92       	push	r14
    297e:	ff 92       	push	r15
    2980:	0f 93       	push	r16
    2982:	1f 93       	push	r17
    2984:	cf 93       	push	r28
    2986:	df 93       	push	r29
    2988:	ec 01       	movw	r28, r24
    298a:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    298c:	8a 81       	ldd	r24, Y+2	; 0x02
    298e:	9b 81       	ldd	r25, Y+3	; 0x03
    2990:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <pcTaskGetTaskName>
    2994:	bc 01       	movw	r22, r24
    2996:	c8 01       	movw	r24, r16
    2998:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    299c:	d8 01       	movw	r26, r16
    299e:	ed 91       	ld	r30, X+
    29a0:	fc 91       	ld	r31, X
    29a2:	02 80       	ldd	r0, Z+2	; 0x02
    29a4:	f3 81       	ldd	r31, Z+3	; 0x03
    29a6:	e0 2d       	mov	r30, r0
    29a8:	69 e0       	ldi	r22, 0x09	; 9
    29aa:	c8 01       	movw	r24, r16
    29ac:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    29ae:	8a 81       	ldd	r24, Y+2	; 0x02
    29b0:	9b 81       	ldd	r25, Y+3	; 0x03
    29b2:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <pcTaskGetTaskName>
    29b6:	fc 01       	movw	r30, r24
    29b8:	01 90       	ld	r0, Z+
    29ba:	00 20       	and	r0, r0
    29bc:	e9 f7       	brne	.-6      	; 0x29b8 <_ZN8frt_task12print_statusER8emstream+0x48>
    29be:	31 97       	sbiw	r30, 0x01	; 1
    29c0:	e8 1b       	sub	r30, r24
    29c2:	f9 0b       	sbc	r31, r25
    29c4:	38 97       	sbiw	r30, 0x08	; 8
    29c6:	48 f4       	brcc	.+18     	; 0x29da <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    29c8:	d8 01       	movw	r26, r16
    29ca:	ed 91       	ld	r30, X+
    29cc:	fc 91       	ld	r31, X
    29ce:	02 80       	ldd	r0, Z+2	; 0x02
    29d0:	f3 81       	ldd	r31, Z+3	; 0x03
    29d2:	e0 2d       	mov	r30, r0
    29d4:	69 e0       	ldi	r22, 0x09	; 9
    29d6:	c8 01       	movw	r24, r16
    29d8:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    29da:	ce 84       	ldd	r12, Y+14	; 0x0e
    29dc:	df 84       	ldd	r13, Y+15	; 0x0f
    29de:	e8 88       	ldd	r14, Y+16	; 0x10
    29e0:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    29e2:	a8 84       	ldd	r10, Y+8	; 0x08
    29e4:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    29e6:	8a 81       	ldd	r24, Y+2	; 0x02
    29e8:	9b 81       	ldd	r25, Y+3	; 0x03
    29ea:	0e 94 a9 12 	call	0x2552	; 0x2552 <uxTaskGetStackHighWaterMark>
    29ee:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    29f0:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    29f2:	8a 81       	ldd	r24, Y+2	; 0x02
    29f4:	9b 81       	ldd	r25, Y+3	; 0x03
    29f6:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <uxTaskPriorityGet>
    29fa:	68 2f       	mov	r22, r24
    29fc:	c8 01       	movw	r24, r16
    29fe:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    2a02:	6a e0       	ldi	r22, 0x0A	; 10
    2a04:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2a08:	ec 01       	movw	r28, r24
    2a0a:	63 e2       	ldi	r22, 0x23	; 35
    2a0c:	75 e0       	ldi	r23, 0x05	; 5
    2a0e:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2a12:	68 2d       	mov	r22, r8
    2a14:	ce 01       	movw	r24, r28
    2a16:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2a1a:	6a e0       	ldi	r22, 0x0A	; 10
    2a1c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2a20:	ec 01       	movw	r28, r24
    2a22:	61 e2       	ldi	r22, 0x21	; 33
    2a24:	75 e0       	ldi	r23, 0x05	; 5
    2a26:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2a2a:	69 2d       	mov	r22, r9
    2a2c:	ce 01       	movw	r24, r28
    2a2e:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    2a32:	6a e0       	ldi	r22, 0x0A	; 10
    2a34:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2a38:	ec 01       	movw	r28, r24
    2a3a:	6f e1       	ldi	r22, 0x1F	; 31
    2a3c:	75 e0       	ldi	r23, 0x05	; 5
    2a3e:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2a42:	b5 01       	movw	r22, r10
    2a44:	ce 01       	movw	r24, r28
    2a46:	0e 94 29 19 	call	0x3252	; 0x3252 <_ZN8emstreamlsEj>
    2a4a:	6a e0       	ldi	r22, 0x0A	; 10
    2a4c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2a50:	ec 01       	movw	r28, r24
    2a52:	6d e1       	ldi	r22, 0x1D	; 29
    2a54:	75 e0       	ldi	r23, 0x05	; 5
    2a56:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2a5a:	6a e0       	ldi	r22, 0x0A	; 10
    2a5c:	ce 01       	movw	r24, r28
    2a5e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2a62:	ec 01       	movw	r28, r24
    2a64:	6b e1       	ldi	r22, 0x1B	; 27
    2a66:	75 e0       	ldi	r23, 0x05	; 5
    2a68:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2a6c:	b7 01       	movw	r22, r14
    2a6e:	a6 01       	movw	r20, r12
    2a70:	ce 01       	movw	r24, r28
    2a72:	0e 94 5d 19 	call	0x32ba	; 0x32ba <_ZN8emstreamlsEm>
}
    2a76:	df 91       	pop	r29
    2a78:	cf 91       	pop	r28
    2a7a:	1f 91       	pop	r17
    2a7c:	0f 91       	pop	r16
    2a7e:	ff 90       	pop	r15
    2a80:	ef 90       	pop	r14
    2a82:	df 90       	pop	r13
    2a84:	cf 90       	pop	r12
    2a86:	bf 90       	pop	r11
    2a88:	af 90       	pop	r10
    2a8a:	9f 90       	pop	r9
    2a8c:	8f 90       	pop	r8
    2a8e:	08 95       	ret

00002a90 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2a90:	cf 93       	push	r28
    2a92:	df 93       	push	r29
    2a94:	ec 01       	movw	r28, r24
    2a96:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2a98:	db 01       	movw	r26, r22
    2a9a:	ed 91       	ld	r30, X+
    2a9c:	fc 91       	ld	r31, X
    2a9e:	02 80       	ldd	r0, Z+2	; 0x02
    2aa0:	f3 81       	ldd	r31, Z+3	; 0x03
    2aa2:	e0 2d       	mov	r30, r0
    2aa4:	be 01       	movw	r22, r28
    2aa6:	19 95       	eicall
	return (ser_dev);
}
    2aa8:	ce 01       	movw	r24, r28
    2aaa:	df 91       	pop	r29
    2aac:	cf 91       	pop	r28
    2aae:	08 95       	ret

00002ab0 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2ab0:	0f 93       	push	r16
    2ab2:	1f 93       	push	r17
    2ab4:	cf 93       	push	r28
    2ab6:	df 93       	push	r29
    2ab8:	ec 01       	movw	r28, r24
    2aba:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2abc:	bc 01       	movw	r22, r24
    2abe:	c8 01       	movw	r24, r16
    2ac0:	0e 94 48 15 	call	0x2a90	; 0x2a90 <_ZlsR8emstreamR8frt_task>
    2ac4:	66 e0       	ldi	r22, 0x06	; 6
    2ac6:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2aca:	8c 81       	ldd	r24, Y+4	; 0x04
    2acc:	9d 81       	ldd	r25, Y+5	; 0x05
    2ace:	00 97       	sbiw	r24, 0x00	; 0
    2ad0:	19 f0       	breq	.+6      	; 0x2ad8 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2ad2:	b8 01       	movw	r22, r16
    2ad4:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2ad8:	df 91       	pop	r29
    2ada:	cf 91       	pop	r28
    2adc:	1f 91       	pop	r17
    2ade:	0f 91       	pop	r16
    2ae0:	08 95       	ret

00002ae2 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2ae2:	0f 93       	push	r16
    2ae4:	1f 93       	push	r17
    2ae6:	cf 93       	push	r28
    2ae8:	df 93       	push	r29
    2aea:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2aec:	6a e0       	ldi	r22, 0x0A	; 10
    2aee:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2af2:	8c 01       	movw	r16, r24
    2af4:	60 e1       	ldi	r22, 0x10	; 16
    2af6:	75 e0       	ldi	r23, 0x05	; 5
    2af8:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2afc:	6a e0       	ldi	r22, 0x0A	; 10
    2afe:	c8 01       	movw	r24, r16
    2b00:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b04:	8c 01       	movw	r16, r24
    2b06:	69 e0       	ldi	r22, 0x09	; 9
    2b08:	75 e0       	ldi	r23, 0x05	; 5
    2b0a:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2b0e:	66 e0       	ldi	r22, 0x06	; 6
    2b10:	c8 01       	movw	r24, r16
    2b12:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2b16:	6a e0       	ldi	r22, 0x0A	; 10
    2b18:	ce 01       	movw	r24, r28
    2b1a:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b1e:	8c 01       	movw	r16, r24
    2b20:	68 ef       	ldi	r22, 0xF8	; 248
    2b22:	74 e0       	ldi	r23, 0x04	; 4
    2b24:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2b28:	6a e0       	ldi	r22, 0x0A	; 10
    2b2a:	c8 01       	movw	r24, r16
    2b2c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b30:	8c 01       	movw	r16, r24
    2b32:	6c ee       	ldi	r22, 0xEC	; 236
    2b34:	74 e0       	ldi	r23, 0x04	; 4
    2b36:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2b3a:	6a e0       	ldi	r22, 0x0A	; 10
    2b3c:	c8 01       	movw	r24, r16
    2b3e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b42:	8c 01       	movw	r16, r24
    2b44:	66 ee       	ldi	r22, 0xE6	; 230
    2b46:	74 e0       	ldi	r23, 0x04	; 4
    2b48:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2b4c:	66 e0       	ldi	r22, 0x06	; 6
    2b4e:	c8 01       	movw	r24, r16
    2b50:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2b54:	6a e0       	ldi	r22, 0x0A	; 10
    2b56:	ce 01       	movw	r24, r28
    2b58:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b5c:	8c 01       	movw	r16, r24
    2b5e:	65 ed       	ldi	r22, 0xD5	; 213
    2b60:	74 e0       	ldi	r23, 0x04	; 4
    2b62:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2b66:	6a e0       	ldi	r22, 0x0A	; 10
    2b68:	c8 01       	movw	r24, r16
    2b6a:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b6e:	8c 01       	movw	r16, r24
    2b70:	69 ec       	ldi	r22, 0xC9	; 201
    2b72:	74 e0       	ldi	r23, 0x04	; 4
    2b74:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2b78:	6a e0       	ldi	r22, 0x0A	; 10
    2b7a:	c8 01       	movw	r24, r16
    2b7c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2b80:	8c 01       	movw	r16, r24
    2b82:	63 ec       	ldi	r22, 0xC3	; 195
    2b84:	74 e0       	ldi	r23, 0x04	; 4
    2b86:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2b8a:	66 e0       	ldi	r22, 0x06	; 6
    2b8c:	c8 01       	movw	r24, r16
    2b8e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2b92:	80 91 04 41 	lds	r24, 0x4104	; 0x804104 <last_created_task_pointer>
    2b96:	90 91 05 41 	lds	r25, 0x4105	; 0x804105 <last_created_task_pointer+0x1>
    2b9a:	00 97       	sbiw	r24, 0x00	; 0
    2b9c:	19 f0       	breq	.+6      	; 0x2ba4 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2b9e:	be 01       	movw	r22, r28
    2ba0:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2ba4:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <xTaskGetIdleTaskHandle>
    2ba8:	0e 94 a9 12 	call	0x2552	; 0x2552 <uxTaskGetStackHighWaterMark>
    2bac:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2bae:	6a e0       	ldi	r22, 0x0A	; 10
    2bb0:	ce 01       	movw	r24, r28
    2bb2:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2bb6:	ec 01       	movw	r28, r24
    2bb8:	68 eb       	ldi	r22, 0xB8	; 184
    2bba:	74 e0       	ldi	r23, 0x04	; 4
    2bbc:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2bc0:	61 2f       	mov	r22, r17
    2bc2:	ce 01       	movw	r24, r28
    2bc4:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2bc8:	6a e0       	ldi	r22, 0x0A	; 10
    2bca:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2bce:	ec 01       	movw	r28, r24
    2bd0:	66 eb       	ldi	r22, 0xB6	; 182
    2bd2:	74 e0       	ldi	r23, 0x04	; 4
    2bd4:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2bd8:	64 e6       	ldi	r22, 0x64	; 100
    2bda:	70 e0       	ldi	r23, 0x00	; 0
    2bdc:	ce 01       	movw	r24, r28
    2bde:	0e 94 29 19 	call	0x3252	; 0x3252 <_ZN8emstreamlsEj>
    2be2:	6a e0       	ldi	r22, 0x0A	; 10
    2be4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2be8:	ec 01       	movw	r28, r24
    2bea:	63 eb       	ldi	r22, 0xB3	; 179
    2bec:	74 e0       	ldi	r23, 0x04	; 4
    2bee:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2bf2:	66 e0       	ldi	r22, 0x06	; 6
    2bf4:	ce 01       	movw	r24, r28
    2bf6:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
}
    2bfa:	df 91       	pop	r29
    2bfc:	cf 91       	pop	r28
    2bfe:	1f 91       	pop	r17
    2c00:	0f 91       	pop	r16
    2c02:	08 95       	ret

00002c04 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2c04:	0f 93       	push	r16
    2c06:	cf 93       	push	r28
    2c08:	df 93       	push	r29
    2c0a:	1f 92       	push	r1
    2c0c:	cd b7       	in	r28, 0x3d	; 61
    2c0e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2c10:	00 e0       	ldi	r16, 0x00	; 0
    2c12:	2f ef       	ldi	r18, 0xFF	; 255
    2c14:	3f ef       	ldi	r19, 0xFF	; 255
    2c16:	a9 01       	movw	r20, r18
    2c18:	be 01       	movw	r22, r28
    2c1a:	6f 5f       	subi	r22, 0xFF	; 255
    2c1c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c1e:	fc 01       	movw	r30, r24
    2c20:	80 85       	ldd	r24, Z+8	; 0x08
    2c22:	91 85       	ldd	r25, Z+9	; 0x09
    2c24:	0e 94 bd 0c 	call	0x197a	; 0x197a <xQueueGenericReceive>
    2c28:	81 30       	cpi	r24, 0x01	; 1
    2c2a:	19 f4       	brne	.+6      	; 0x2c32 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2c2c:	89 81       	ldd	r24, Y+1	; 0x01
    2c2e:	90 e0       	ldi	r25, 0x00	; 0
    2c30:	02 c0       	rjmp	.+4      	; 0x2c36 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2c32:	8f ef       	ldi	r24, 0xFF	; 255
    2c34:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2c36:	0f 90       	pop	r0
    2c38:	df 91       	pop	r29
    2c3a:	cf 91       	pop	r28
    2c3c:	0f 91       	pop	r16
    2c3e:	08 95       	ret

00002c40 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2c40:	fc 01       	movw	r30, r24
    2c42:	80 85       	ldd	r24, Z+8	; 0x08
    2c44:	91 85       	ldd	r25, Z+9	; 0x09
    2c46:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxQueueMessagesWaiting>
    2c4a:	91 e0       	ldi	r25, 0x01	; 1
    2c4c:	81 11       	cpse	r24, r1
    2c4e:	01 c0       	rjmp	.+2      	; 0x2c52 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2c50:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2c52:	89 2f       	mov	r24, r25
    2c54:	08 95       	ret

00002c56 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2c56:	0f 93       	push	r16
    2c58:	cf 93       	push	r28
    2c5a:	df 93       	push	r29
    2c5c:	1f 92       	push	r1
    2c5e:	cd b7       	in	r28, 0x3d	; 61
    2c60:	de b7       	in	r29, 0x3e	; 62
    2c62:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2c64:	fc 01       	movw	r30, r24
    2c66:	22 85       	ldd	r18, Z+10	; 0x0a
    2c68:	33 85       	ldd	r19, Z+11	; 0x0b
    2c6a:	44 85       	ldd	r20, Z+12	; 0x0c
    2c6c:	55 85       	ldd	r21, Z+13	; 0x0d
    2c6e:	00 e0       	ldi	r16, 0x00	; 0
    2c70:	be 01       	movw	r22, r28
    2c72:	6f 5f       	subi	r22, 0xFF	; 255
    2c74:	7f 4f       	sbci	r23, 0xFF	; 255
    2c76:	80 85       	ldd	r24, Z+8	; 0x08
    2c78:	91 85       	ldd	r25, Z+9	; 0x09
    2c7a:	0e 94 22 0c 	call	0x1844	; 0x1844 <xQueueGenericSend>
    2c7e:	91 e0       	ldi	r25, 0x01	; 1
    2c80:	81 11       	cpse	r24, r1
    2c82:	01 c0       	rjmp	.+2      	; 0x2c86 <_ZN14frt_text_queue7putcharEc+0x30>
    2c84:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2c86:	89 2f       	mov	r24, r25
    2c88:	0f 90       	pop	r0
    2c8a:	df 91       	pop	r29
    2c8c:	cf 91       	pop	r28
    2c8e:	0f 91       	pop	r16
    2c90:	08 95       	ret

00002c92 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2c92:	8f 92       	push	r8
    2c94:	9f 92       	push	r9
    2c96:	bf 92       	push	r11
    2c98:	cf 92       	push	r12
    2c9a:	df 92       	push	r13
    2c9c:	ef 92       	push	r14
    2c9e:	ff 92       	push	r15
    2ca0:	0f 93       	push	r16
    2ca2:	1f 93       	push	r17
    2ca4:	cf 93       	push	r28
    2ca6:	df 93       	push	r29
    2ca8:	ec 01       	movw	r28, r24
    2caa:	b6 2e       	mov	r11, r22
    2cac:	4a 01       	movw	r8, r20
    2cae:	68 01       	movw	r12, r16
    2cb0:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2cb2:	0e 94 9d 18 	call	0x313a	; 0x313a <_ZN8emstreamC1Ev>
    2cb6:	8f e2       	ldi	r24, 0x2F	; 47
    2cb8:	90 e2       	ldi	r25, 0x20	; 32
    2cba:	88 83       	st	Y, r24
    2cbc:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2cbe:	8e 86       	std	Y+14, r8	; 0x0e
    2cc0:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2cc2:	40 e0       	ldi	r20, 0x00	; 0
    2cc4:	61 e0       	ldi	r22, 0x01	; 1
    2cc6:	8b 2d       	mov	r24, r11
    2cc8:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <xQueueGenericCreate>
    2ccc:	88 87       	std	Y+8, r24	; 0x08
    2cce:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2cd0:	ca 86       	std	Y+10, r12	; 0x0a
    2cd2:	db 86       	std	Y+11, r13	; 0x0b
    2cd4:	ec 86       	std	Y+12, r14	; 0x0c
    2cd6:	fd 86       	std	Y+13, r15	; 0x0d
}
    2cd8:	df 91       	pop	r29
    2cda:	cf 91       	pop	r28
    2cdc:	1f 91       	pop	r17
    2cde:	0f 91       	pop	r16
    2ce0:	ff 90       	pop	r15
    2ce2:	ef 90       	pop	r14
    2ce4:	df 90       	pop	r13
    2ce6:	cf 90       	pop	r12
    2ce8:	bf 90       	pop	r11
    2cea:	9f 90       	pop	r9
    2cec:	8f 90       	pop	r8
    2cee:	08 95       	ret

00002cf0 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2cf0:	cf 92       	push	r12
    2cf2:	df 92       	push	r13
    2cf4:	ef 92       	push	r14
    2cf6:	ff 92       	push	r15
    2cf8:	cf 93       	push	r28
    2cfa:	df 93       	push	r29
    2cfc:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2cfe:	68 81       	ld	r22, Y
    2d00:	79 81       	ldd	r23, Y+1	; 0x01
    2d02:	8a 81       	ldd	r24, Y+2	; 0x02
    2d04:	9b 81       	ldd	r25, Y+3	; 0x03
    2d06:	0f 2e       	mov	r0, r31
    2d08:	f8 ee       	ldi	r31, 0xE8	; 232
    2d0a:	cf 2e       	mov	r12, r31
    2d0c:	f3 e0       	ldi	r31, 0x03	; 3
    2d0e:	df 2e       	mov	r13, r31
    2d10:	e1 2c       	mov	r14, r1
    2d12:	f1 2c       	mov	r15, r1
    2d14:	f0 2d       	mov	r31, r0
    2d16:	a7 01       	movw	r20, r14
    2d18:	96 01       	movw	r18, r12
    2d1a:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__udivmodsi4>
    2d1e:	9b 01       	movw	r18, r22
    2d20:	ac 01       	movw	r20, r24
    2d22:	60 e4       	ldi	r22, 0x40	; 64
    2d24:	72 e4       	ldi	r23, 0x42	; 66
    2d26:	8f e0       	ldi	r24, 0x0F	; 15
    2d28:	90 e0       	ldi	r25, 0x00	; 0
    2d2a:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <__mulsi3>
    2d2e:	a7 01       	movw	r20, r14
    2d30:	96 01       	movw	r18, r12
    2d32:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__udivmodsi4>
    2d36:	69 01       	movw	r12, r18
    2d38:	7a 01       	movw	r14, r20
    2d3a:	ac 81       	ldd	r26, Y+4	; 0x04
    2d3c:	bd 81       	ldd	r27, Y+5	; 0x05
    2d3e:	20 e4       	ldi	r18, 0x40	; 64
    2d40:	32 e4       	ldi	r19, 0x42	; 66
    2d42:	4f e0       	ldi	r20, 0x0F	; 15
    2d44:	50 e0       	ldi	r21, 0x00	; 0
    2d46:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__muluhisi3>
    2d4a:	20 e0       	ldi	r18, 0x00	; 0
    2d4c:	38 e4       	ldi	r19, 0x48	; 72
    2d4e:	48 ee       	ldi	r20, 0xE8	; 232
    2d50:	51 e0       	ldi	r21, 0x01	; 1
    2d52:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__udivmodsi4>
    2d56:	c7 01       	movw	r24, r14
    2d58:	b6 01       	movw	r22, r12
    2d5a:	62 0f       	add	r22, r18
    2d5c:	73 1f       	adc	r23, r19
    2d5e:	84 1f       	adc	r24, r20
    2d60:	95 1f       	adc	r25, r21
}
    2d62:	df 91       	pop	r29
    2d64:	cf 91       	pop	r28
    2d66:	ff 90       	pop	r15
    2d68:	ef 90       	pop	r14
    2d6a:	df 90       	pop	r13
    2d6c:	cf 90       	pop	r12
    2d6e:	08 95       	ret

00002d70 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2d70:	cf 92       	push	r12
    2d72:	df 92       	push	r13
    2d74:	ef 92       	push	r14
    2d76:	ff 92       	push	r15
    2d78:	0f 93       	push	r16
    2d7a:	1f 93       	push	r17
    2d7c:	cf 93       	push	r28
    2d7e:	df 93       	push	r29
    2d80:	cd b7       	in	r28, 0x3d	; 61
    2d82:	de b7       	in	r29, 0x3e	; 62
    2d84:	2f 97       	sbiw	r28, 0x0f	; 15
    2d86:	cd bf       	out	0x3d, r28	; 61
    2d88:	de bf       	out	0x3e, r29	; 62
    2d8a:	6c 01       	movw	r12, r24
    2d8c:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2d8e:	db 01       	movw	r26, r22
    2d90:	6d 91       	ld	r22, X+
    2d92:	7d 91       	ld	r23, X+
    2d94:	8d 91       	ld	r24, X+
    2d96:	9c 91       	ld	r25, X
    2d98:	28 ee       	ldi	r18, 0xE8	; 232
    2d9a:	33 e0       	ldi	r19, 0x03	; 3
    2d9c:	40 e0       	ldi	r20, 0x00	; 0
    2d9e:	50 e0       	ldi	r21, 0x00	; 0
    2da0:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__udivmodsi4>
    2da4:	ba 01       	movw	r22, r20
    2da6:	a9 01       	movw	r20, r18
    2da8:	c6 01       	movw	r24, r12
    2daa:	0e 94 5d 19 	call	0x32ba	; 0x32ba <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2dae:	d6 01       	movw	r26, r12
    2db0:	ed 91       	ld	r30, X+
    2db2:	fc 91       	ld	r31, X
    2db4:	02 80       	ldd	r0, Z+2	; 0x02
    2db6:	f3 81       	ldd	r31, Z+3	; 0x03
    2db8:	e0 2d       	mov	r30, r0
    2dba:	6e e2       	ldi	r22, 0x2E	; 46
    2dbc:	c6 01       	movw	r24, r12
    2dbe:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2dc0:	c8 01       	movw	r24, r16
    2dc2:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <_ZN10time_stamp12get_microsecEv>
    2dc6:	8e 01       	movw	r16, r28
    2dc8:	09 5f       	subi	r16, 0xF9	; 249
    2dca:	1f 4f       	sbci	r17, 0xFF	; 255
    2dcc:	fe 01       	movw	r30, r28
    2dce:	31 96       	adiw	r30, 0x01	; 1
    2dd0:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2dd2:	2a e0       	ldi	r18, 0x0A	; 10
    2dd4:	30 e0       	ldi	r19, 0x00	; 0
    2dd6:	40 e0       	ldi	r20, 0x00	; 0
    2dd8:	50 e0       	ldi	r21, 0x00	; 0
    2dda:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <__divmodsi4>
    2dde:	e6 2f       	mov	r30, r22
    2de0:	28 87       	std	Y+8, r18	; 0x08
    2de2:	39 87       	std	Y+9, r19	; 0x09
    2de4:	4a 87       	std	Y+10, r20	; 0x0a
    2de6:	5b 87       	std	Y+11, r21	; 0x0b
    2de8:	68 85       	ldd	r22, Y+8	; 0x08
    2dea:	79 85       	ldd	r23, Y+9	; 0x09
    2dec:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dee:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2df0:	20 e3       	ldi	r18, 0x30	; 48
    2df2:	2e 0f       	add	r18, r30
    2df4:	d8 01       	movw	r26, r16
    2df6:	2e 93       	st	-X, r18
    2df8:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2dfa:	ae 15       	cp	r26, r14
    2dfc:	bf 05       	cpc	r27, r15
    2dfe:	49 f7       	brne	.-46     	; 0x2dd2 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2e00:	1f 82       	std	Y+7, r1	; 0x07
    2e02:	be 01       	movw	r22, r28
    2e04:	6f 5f       	subi	r22, 0xFF	; 255
    2e06:	7f 4f       	sbci	r23, 0xFF	; 255
    2e08:	c6 01       	movw	r24, r12
    2e0a:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2e0e:	c6 01       	movw	r24, r12
    2e10:	2f 96       	adiw	r28, 0x0f	; 15
    2e12:	cd bf       	out	0x3d, r28	; 61
    2e14:	de bf       	out	0x3e, r29	; 62
    2e16:	df 91       	pop	r29
    2e18:	cf 91       	pop	r28
    2e1a:	1f 91       	pop	r17
    2e1c:	0f 91       	pop	r16
    2e1e:	ff 90       	pop	r15
    2e20:	ef 90       	pop	r14
    2e22:	df 90       	pop	r13
    2e24:	cf 90       	pop	r12
    2e26:	08 95       	ret

00002e28 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2e28:	cf 93       	push	r28
    2e2a:	df 93       	push	r29
    2e2c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2e2e:	0f b6       	in	r0, 0x3f	; 63
    2e30:	f8 94       	cli
    2e32:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2e34:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2e38:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2e3c:	8c 83       	std	Y+4, r24	; 0x04
    2e3e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2e40:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskGetTickCount>
    2e44:	68 83       	st	Y, r22
    2e46:	79 83       	std	Y+1, r23	; 0x01
    2e48:	8a 83       	std	Y+2, r24	; 0x02
    2e4a:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2e4c:	0f 90       	pop	r0
    2e4e:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2e50:	ce 01       	movw	r24, r28
    2e52:	df 91       	pop	r29
    2e54:	cf 91       	pop	r28
    2e56:	08 95       	ret

00002e58 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2e58:	5f 92       	push	r5
    2e5a:	6f 92       	push	r6
    2e5c:	7f 92       	push	r7
    2e5e:	8f 92       	push	r8
    2e60:	9f 92       	push	r9
    2e62:	af 92       	push	r10
    2e64:	bf 92       	push	r11
    2e66:	cf 92       	push	r12
    2e68:	df 92       	push	r13
    2e6a:	ef 92       	push	r14
    2e6c:	ff 92       	push	r15
    2e6e:	0f 93       	push	r16
    2e70:	1f 93       	push	r17
    2e72:	cf 93       	push	r28
    2e74:	df 93       	push	r29
    2e76:	5c 01       	movw	r10, r24
    2e78:	4b 01       	movw	r8, r22
    2e7a:	7a 01       	movw	r14, r20
    2e7c:	12 2f       	mov	r17, r18
    2e7e:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2e80:	63 e0       	ldi	r22, 0x03	; 3
    2e82:	ca 01       	movw	r24, r20
    2e84:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2e88:	a8 14       	cp	r10, r8
    2e8a:	b9 04       	cpc	r11, r9
    2e8c:	08 f0       	brcs	.+2      	; 0x2e90 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2e8e:	7d c0       	rjmp	.+250    	; 0x2f8a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2e90:	65 01       	movw	r12, r10
    2e92:	84 e1       	ldi	r24, 0x14	; 20
    2e94:	c8 0e       	add	r12, r24
    2e96:	d1 1c       	adc	r13, r1
    2e98:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2e9a:	6a 2c       	mov	r6, r10
    2e9c:	5b 2c       	mov	r5, r11
    2e9e:	b5 01       	movw	r22, r10
    2ea0:	c7 01       	movw	r24, r14
    2ea2:	0e 94 29 19 	call	0x3252	; 0x3252 <_ZN8emstreamlsEj>
    2ea6:	6a e0       	ldi	r22, 0x0A	; 10
    2ea8:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2eac:	65 e3       	ldi	r22, 0x35	; 53
    2eae:	75 e0       	ldi	r23, 0x05	; 5
    2eb0:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2eb4:	11 23       	and	r17, r17
    2eb6:	09 f4       	brne	.+2      	; 0x2eba <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2eb8:	6d c0       	rjmp	.+218    	; 0x2f94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2eba:	00 23       	and	r16, r16
    2ebc:	09 f4       	brne	.+2      	; 0x2ec0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2ebe:	6a c0       	rjmp	.+212    	; 0x2f94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2ec0:	6a e0       	ldi	r22, 0x0A	; 10
    2ec2:	c7 01       	movw	r24, r14
    2ec4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2ec8:	60 e3       	ldi	r22, 0x30	; 48
    2eca:	75 e0       	ldi	r23, 0x05	; 5
    2ecc:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    2ed0:	61 c0       	rjmp	.+194    	; 0x2f94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2ed2:	11 23       	and	r17, r17
    2ed4:	71 f0       	breq	.+28     	; 0x2ef2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2ed6:	01 11       	cpse	r16, r1
    2ed8:	0c c0       	rjmp	.+24     	; 0x2ef2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2eda:	88 81       	ld	r24, Y
    2edc:	87 15       	cp	r24, r7
    2ede:	49 f0       	breq	.+18     	; 0x2ef2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2ee0:	6a e0       	ldi	r22, 0x0A	; 10
    2ee2:	c7 01       	movw	r24, r14
    2ee4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2ee8:	6b e2       	ldi	r22, 0x2B	; 43
    2eea:	75 e0       	ldi	r23, 0x05	; 5
    2eec:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2ef0:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2ef2:	69 91       	ld	r22, Y+
    2ef4:	c7 01       	movw	r24, r14
    2ef6:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2efa:	dc 01       	movw	r26, r24
    2efc:	ed 91       	ld	r30, X+
    2efe:	fc 91       	ld	r31, X
    2f00:	02 80       	ldd	r0, Z+2	; 0x02
    2f02:	f3 81       	ldd	r31, Z+3	; 0x03
    2f04:	e0 2d       	mov	r30, r0
    2f06:	60 e2       	ldi	r22, 0x20	; 32
    2f08:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2f0a:	cc 16       	cp	r12, r28
    2f0c:	dd 06       	cpc	r13, r29
    2f0e:	09 f7       	brne	.-62     	; 0x2ed2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2f10:	11 23       	and	r17, r17
    2f12:	89 f0       	breq	.+34     	; 0x2f36 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2f14:	6a e0       	ldi	r22, 0x0A	; 10
    2f16:	c7 01       	movw	r24, r14
    2f18:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2f1c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2f1e:	65 e2       	ldi	r22, 0x25	; 37
    2f20:	75 e0       	ldi	r23, 0x05	; 5
    2f22:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2f26:	e8 81       	ld	r30, Y
    2f28:	f9 81       	ldd	r31, Y+1	; 0x01
    2f2a:	02 80       	ldd	r0, Z+2	; 0x02
    2f2c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f2e:	e0 2d       	mov	r30, r0
    2f30:	60 e2       	ldi	r22, 0x20	; 32
    2f32:	ce 01       	movw	r24, r28
    2f34:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2f36:	c6 2d       	mov	r28, r6
    2f38:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2f3a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2f3c:	80 ee       	ldi	r24, 0xE0	; 224
    2f3e:	86 0f       	add	r24, r22
    2f40:	8f 35       	cpi	r24, 0x5F	; 95
    2f42:	48 f4       	brcc	.+18     	; 0x2f56 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2f44:	d7 01       	movw	r26, r14
    2f46:	ed 91       	ld	r30, X+
    2f48:	fc 91       	ld	r31, X
    2f4a:	02 80       	ldd	r0, Z+2	; 0x02
    2f4c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f4e:	e0 2d       	mov	r30, r0
    2f50:	c7 01       	movw	r24, r14
    2f52:	19 95       	eicall
    2f54:	09 c0       	rjmp	.+18     	; 0x2f68 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2f56:	d7 01       	movw	r26, r14
    2f58:	ed 91       	ld	r30, X+
    2f5a:	fc 91       	ld	r31, X
    2f5c:	02 80       	ldd	r0, Z+2	; 0x02
    2f5e:	f3 81       	ldd	r31, Z+3	; 0x03
    2f60:	e0 2d       	mov	r30, r0
    2f62:	6e e2       	ldi	r22, 0x2E	; 46
    2f64:	c7 01       	movw	r24, r14
    2f66:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2f68:	cc 16       	cp	r12, r28
    2f6a:	dd 06       	cpc	r13, r29
    2f6c:	31 f7       	brne	.-52     	; 0x2f3a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2f6e:	b4 e1       	ldi	r27, 0x14	; 20
    2f70:	ab 0e       	add	r10, r27
    2f72:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2f74:	66 e0       	ldi	r22, 0x06	; 6
    2f76:	c7 01       	movw	r24, r14
    2f78:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    2f7c:	84 e1       	ldi	r24, 0x14	; 20
    2f7e:	c8 0e       	add	r12, r24
    2f80:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2f82:	a8 14       	cp	r10, r8
    2f84:	b9 04       	cpc	r11, r9
    2f86:	08 f4       	brcc	.+2      	; 0x2f8a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2f88:	88 cf       	rjmp	.-240    	; 0x2e9a <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2f8a:	62 e0       	ldi	r22, 0x02	; 2
    2f8c:	c7 01       	movw	r24, r14
    2f8e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
}
    2f92:	03 c0       	rjmp	.+6      	; 0x2f9a <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2f94:	c6 2d       	mov	r28, r6
    2f96:	d5 2d       	mov	r29, r5
    2f98:	9c cf       	rjmp	.-200    	; 0x2ed2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2f9a:	df 91       	pop	r29
    2f9c:	cf 91       	pop	r28
    2f9e:	1f 91       	pop	r17
    2fa0:	0f 91       	pop	r16
    2fa2:	ff 90       	pop	r15
    2fa4:	ef 90       	pop	r14
    2fa6:	df 90       	pop	r13
    2fa8:	cf 90       	pop	r12
    2faa:	bf 90       	pop	r11
    2fac:	af 90       	pop	r10
    2fae:	9f 90       	pop	r9
    2fb0:	8f 90       	pop	r8
    2fb2:	7f 90       	pop	r7
    2fb4:	6f 90       	pop	r6
    2fb6:	5f 90       	pop	r5
    2fb8:	08 95       	ret

00002fba <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2fba:	0e 94 06 08 	call	0x100c	; 0x100c <pvPortMalloc>
    2fbe:	08 95       	ret

00002fc0 <_Znaj>:
    2fc0:	0e 94 06 08 	call	0x100c	; 0x100c <pvPortMalloc>
    2fc4:	08 95       	ret

00002fc6 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2fc6:	08 95       	ret

00002fc8 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2fc8:	cf 93       	push	r28
    2fca:	df 93       	push	r29
    2fcc:	fc 01       	movw	r30, r24
    2fce:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2fd0:	40 3a       	cpi	r20, 0xA0	; 160
    2fd2:	68 e0       	ldi	r22, 0x08	; 8
    2fd4:	56 07       	cpc	r21, r22
    2fd6:	49 f4       	brne	.+18     	; 0x2fea <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2fd8:	80 e4       	ldi	r24, 0x40	; 64
    2fda:	96 e0       	ldi	r25, 0x06	; 6
    2fdc:	82 83       	std	Z+2, r24	; 0x02
    2fde:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2fe0:	82 e0       	ldi	r24, 0x02	; 2
    2fe2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2fe4:	83 e0       	ldi	r24, 0x03	; 3
    2fe6:	85 83       	std	Z+5, r24	; 0x05
    2fe8:	4c c0       	rjmp	.+152    	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2fea:	40 3b       	cpi	r20, 0xB0	; 176
    2fec:	78 e0       	ldi	r23, 0x08	; 8
    2fee:	57 07       	cpc	r21, r23
    2ff0:	49 f4       	brne	.+18     	; 0x3004 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2ff2:	80 e4       	ldi	r24, 0x40	; 64
    2ff4:	96 e0       	ldi	r25, 0x06	; 6
    2ff6:	82 83       	std	Z+2, r24	; 0x02
    2ff8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2ffa:	86 e0       	ldi	r24, 0x06	; 6
    2ffc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2ffe:	87 e0       	ldi	r24, 0x07	; 7
    3000:	85 83       	std	Z+5, r24	; 0x05
    3002:	3f c0       	rjmp	.+126    	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3004:	40 3a       	cpi	r20, 0xA0	; 160
    3006:	89 e0       	ldi	r24, 0x09	; 9
    3008:	58 07       	cpc	r21, r24
    300a:	49 f4       	brne	.+18     	; 0x301e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    300c:	80 e6       	ldi	r24, 0x60	; 96
    300e:	96 e0       	ldi	r25, 0x06	; 6
    3010:	82 83       	std	Z+2, r24	; 0x02
    3012:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3014:	82 e0       	ldi	r24, 0x02	; 2
    3016:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3018:	83 e0       	ldi	r24, 0x03	; 3
    301a:	85 83       	std	Z+5, r24	; 0x05
    301c:	32 c0       	rjmp	.+100    	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    301e:	40 3b       	cpi	r20, 0xB0	; 176
    3020:	69 e0       	ldi	r22, 0x09	; 9
    3022:	56 07       	cpc	r21, r22
    3024:	49 f4       	brne	.+18     	; 0x3038 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3026:	80 e6       	ldi	r24, 0x60	; 96
    3028:	96 e0       	ldi	r25, 0x06	; 6
    302a:	82 83       	std	Z+2, r24	; 0x02
    302c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    302e:	86 e0       	ldi	r24, 0x06	; 6
    3030:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3032:	87 e0       	ldi	r24, 0x07	; 7
    3034:	85 83       	std	Z+5, r24	; 0x05
    3036:	25 c0       	rjmp	.+74     	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3038:	40 3a       	cpi	r20, 0xA0	; 160
    303a:	7a e0       	ldi	r23, 0x0A	; 10
    303c:	57 07       	cpc	r21, r23
    303e:	49 f4       	brne	.+18     	; 0x3052 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    3040:	80 e8       	ldi	r24, 0x80	; 128
    3042:	96 e0       	ldi	r25, 0x06	; 6
    3044:	82 83       	std	Z+2, r24	; 0x02
    3046:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3048:	82 e0       	ldi	r24, 0x02	; 2
    304a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    304c:	83 e0       	ldi	r24, 0x03	; 3
    304e:	85 83       	std	Z+5, r24	; 0x05
    3050:	18 c0       	rjmp	.+48     	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    3052:	40 3b       	cpi	r20, 0xB0	; 176
    3054:	8a e0       	ldi	r24, 0x0A	; 10
    3056:	58 07       	cpc	r21, r24
    3058:	49 f4       	brne	.+18     	; 0x306c <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    305a:	80 e8       	ldi	r24, 0x80	; 128
    305c:	96 e0       	ldi	r25, 0x06	; 6
    305e:	82 83       	std	Z+2, r24	; 0x02
    3060:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3062:	86 e0       	ldi	r24, 0x06	; 6
    3064:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3066:	87 e0       	ldi	r24, 0x07	; 7
    3068:	85 83       	std	Z+5, r24	; 0x05
    306a:	0b c0       	rjmp	.+22     	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    306c:	40 3a       	cpi	r20, 0xA0	; 160
    306e:	5b 40       	sbci	r21, 0x0B	; 11
    3070:	41 f4       	brne	.+16     	; 0x3082 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    3072:	80 ea       	ldi	r24, 0xA0	; 160
    3074:	96 e0       	ldi	r25, 0x06	; 6
    3076:	82 83       	std	Z+2, r24	; 0x02
    3078:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    307a:	82 e0       	ldi	r24, 0x02	; 2
    307c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    307e:	83 e0       	ldi	r24, 0x03	; 3
    3080:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3082:	a6 83       	std	Z+6, r26	; 0x06
    3084:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3086:	cd 01       	movw	r24, r26
    3088:	01 96       	adiw	r24, 0x01	; 1
    308a:	80 87       	std	Z+8, r24	; 0x08
    308c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    308e:	03 96       	adiw	r24, 0x03	; 3
    3090:	82 87       	std	Z+10, r24	; 0x0a
    3092:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3094:	25 81       	ldd	r18, Z+5	; 0x05
    3096:	c2 81       	ldd	r28, Z+2	; 0x02
    3098:	d3 81       	ldd	r29, Z+3	; 0x03
    309a:	4c 81       	ldd	r20, Y+4	; 0x04
    309c:	81 e0       	ldi	r24, 0x01	; 1
    309e:	90 e0       	ldi	r25, 0x00	; 0
    30a0:	bc 01       	movw	r22, r24
    30a2:	02 c0       	rjmp	.+4      	; 0x30a8 <_ZN7base232C1EjP12USART_struct+0xe0>
    30a4:	66 0f       	add	r22, r22
    30a6:	77 1f       	adc	r23, r23
    30a8:	2a 95       	dec	r18
    30aa:	e2 f7       	brpl	.-8      	; 0x30a4 <_ZN7base232C1EjP12USART_struct+0xdc>
    30ac:	9b 01       	movw	r18, r22
    30ae:	24 2b       	or	r18, r20
    30b0:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    30b2:	25 81       	ldd	r18, Z+5	; 0x05
    30b4:	c2 81       	ldd	r28, Z+2	; 0x02
    30b6:	d3 81       	ldd	r29, Z+3	; 0x03
    30b8:	48 81       	ld	r20, Y
    30ba:	bc 01       	movw	r22, r24
    30bc:	02 c0       	rjmp	.+4      	; 0x30c2 <_ZN7base232C1EjP12USART_struct+0xfa>
    30be:	66 0f       	add	r22, r22
    30c0:	77 1f       	adc	r23, r23
    30c2:	2a 95       	dec	r18
    30c4:	e2 f7       	brpl	.-8      	; 0x30be <_ZN7base232C1EjP12USART_struct+0xf6>
    30c6:	9b 01       	movw	r18, r22
    30c8:	24 2b       	or	r18, r20
    30ca:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    30cc:	34 81       	ldd	r19, Z+4	; 0x04
    30ce:	c2 81       	ldd	r28, Z+2	; 0x02
    30d0:	d3 81       	ldd	r29, Z+3	; 0x03
    30d2:	28 81       	ld	r18, Y
    30d4:	02 c0       	rjmp	.+4      	; 0x30da <_ZN7base232C1EjP12USART_struct+0x112>
    30d6:	88 0f       	add	r24, r24
    30d8:	99 1f       	adc	r25, r25
    30da:	3a 95       	dec	r19
    30dc:	e2 f7       	brpl	.-8      	; 0x30d6 <_ZN7base232C1EjP12USART_struct+0x10e>
    30de:	80 95       	com	r24
    30e0:	90 95       	com	r25
    30e2:	82 23       	and	r24, r18
    30e4:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    30e6:	80 e1       	ldi	r24, 0x10	; 16
    30e8:	13 96       	adiw	r26, 0x03	; 3
    30ea:	8c 93       	st	X, r24
    30ec:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    30ee:	83 e0       	ldi	r24, 0x03	; 3
    30f0:	15 96       	adiw	r26, 0x05	; 5
    30f2:	8c 93       	st	X, r24
    30f4:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    30f6:	80 ef       	ldi	r24, 0xF0	; 240
    30f8:	17 96       	adiw	r26, 0x07	; 7
    30fa:	8c 93       	st	X, r24
    30fc:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    30fe:	81 e2       	ldi	r24, 0x21	; 33
    3100:	16 96       	adiw	r26, 0x06	; 6
    3102:	8c 93       	st	X, r24
    3104:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3106:	88 e1       	ldi	r24, 0x18	; 24
    3108:	14 96       	adiw	r26, 0x04	; 4
    310a:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    310c:	80 e8       	ldi	r24, 0x80	; 128
    310e:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3110:	80 e4       	ldi	r24, 0x40	; 64
    3112:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3114:	80 e2       	ldi	r24, 0x20	; 32
    3116:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3118:	06 80       	ldd	r0, Z+6	; 0x06
    311a:	f7 81       	ldd	r31, Z+7	; 0x07
    311c:	e0 2d       	mov	r30, r0
    311e:	80 81       	ld	r24, Z
    3120:	80 81       	ld	r24, Z
}
    3122:	df 91       	pop	r29
    3124:	cf 91       	pop	r28
    3126:	08 95       	ret

00003128 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3128:	81 e0       	ldi	r24, 0x01	; 1
    312a:	08 95       	ret

0000312c <_ZN8emstream7getcharEv>:
    312c:	80 e0       	ldi	r24, 0x00	; 0
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	08 95       	ret

00003132 <_ZN8emstream14check_for_charEv>:
    3132:	80 e0       	ldi	r24, 0x00	; 0
    3134:	08 95       	ret

00003136 <_ZN8emstream12transmit_nowEv>:
    3136:	08 95       	ret

00003138 <_ZN8emstream12clear_screenEv>:
    3138:	08 95       	ret

0000313a <_ZN8emstreamC1Ev>:
    313a:	fc 01       	movw	r30, r24
    313c:	8f e3       	ldi	r24, 0x3F	; 63
    313e:	90 e2       	ldi	r25, 0x20	; 32
    3140:	80 83       	st	Z, r24
    3142:	91 83       	std	Z+1, r25	; 0x01
    3144:	8a e0       	ldi	r24, 0x0A	; 10
    3146:	82 83       	std	Z+2, r24	; 0x02
    3148:	13 82       	std	Z+3, r1	; 0x03
    314a:	83 e0       	ldi	r24, 0x03	; 3
    314c:	85 83       	std	Z+5, r24	; 0x05
    314e:	14 82       	std	Z+4, r1	; 0x04
    3150:	16 82       	std	Z+6, r1	; 0x06
    3152:	17 82       	std	Z+7, r1	; 0x07
    3154:	08 95       	ret

00003156 <_ZN8emstream4putsEPKc>:
    3156:	0f 93       	push	r16
    3158:	1f 93       	push	r17
    315a:	cf 93       	push	r28
    315c:	df 93       	push	r29
    315e:	8c 01       	movw	r16, r24
    3160:	fb 01       	movw	r30, r22
    3162:	dc 01       	movw	r26, r24
    3164:	14 96       	adiw	r26, 0x04	; 4
    3166:	8c 91       	ld	r24, X
    3168:	81 11       	cpse	r24, r1
    316a:	04 c0       	rjmp	.+8      	; 0x3174 <_ZN8emstream4putsEPKc+0x1e>
    316c:	60 81       	ld	r22, Z
    316e:	61 11       	cpse	r22, r1
    3170:	17 c0       	rjmp	.+46     	; 0x31a0 <_ZN8emstream4putsEPKc+0x4a>
    3172:	23 c0       	rjmp	.+70     	; 0x31ba <_ZN8emstream4putsEPKc+0x64>
    3174:	d8 01       	movw	r26, r16
    3176:	14 96       	adiw	r26, 0x04	; 4
    3178:	1c 92       	st	X, r1
    317a:	eb 01       	movw	r28, r22
    317c:	21 96       	adiw	r28, 0x01	; 1
    317e:	64 91       	lpm	r22, Z
    3180:	66 23       	and	r22, r22
    3182:	d9 f0       	breq	.+54     	; 0x31ba <_ZN8emstream4putsEPKc+0x64>
    3184:	d8 01       	movw	r26, r16
    3186:	ed 91       	ld	r30, X+
    3188:	fc 91       	ld	r31, X
    318a:	02 80       	ldd	r0, Z+2	; 0x02
    318c:	f3 81       	ldd	r31, Z+3	; 0x03
    318e:	e0 2d       	mov	r30, r0
    3190:	c8 01       	movw	r24, r16
    3192:	19 95       	eicall
    3194:	fe 01       	movw	r30, r28
    3196:	64 91       	lpm	r22, Z
    3198:	21 96       	adiw	r28, 0x01	; 1
    319a:	61 11       	cpse	r22, r1
    319c:	f3 cf       	rjmp	.-26     	; 0x3184 <_ZN8emstream4putsEPKc+0x2e>
    319e:	0d c0       	rjmp	.+26     	; 0x31ba <_ZN8emstream4putsEPKc+0x64>
    31a0:	ef 01       	movw	r28, r30
    31a2:	21 96       	adiw	r28, 0x01	; 1
    31a4:	d8 01       	movw	r26, r16
    31a6:	ed 91       	ld	r30, X+
    31a8:	fc 91       	ld	r31, X
    31aa:	02 80       	ldd	r0, Z+2	; 0x02
    31ac:	f3 81       	ldd	r31, Z+3	; 0x03
    31ae:	e0 2d       	mov	r30, r0
    31b0:	c8 01       	movw	r24, r16
    31b2:	19 95       	eicall
    31b4:	69 91       	ld	r22, Y+
    31b6:	61 11       	cpse	r22, r1
    31b8:	f5 cf       	rjmp	.-22     	; 0x31a4 <_ZN8emstream4putsEPKc+0x4e>
    31ba:	df 91       	pop	r29
    31bc:	cf 91       	pop	r28
    31be:	1f 91       	pop	r17
    31c0:	0f 91       	pop	r16
    31c2:	08 95       	ret

000031c4 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    31c4:	cf 93       	push	r28
    31c6:	df 93       	push	r29
    31c8:	ec 01       	movw	r28, r24
	switch (new_manip)
    31ca:	86 2f       	mov	r24, r22
    31cc:	90 e0       	ldi	r25, 0x00	; 0
    31ce:	8b 30       	cpi	r24, 0x0B	; 11
    31d0:	91 05       	cpc	r25, r1
    31d2:	d8 f5       	brcc	.+118    	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
    31d4:	fc 01       	movw	r30, r24
    31d6:	88 27       	eor	r24, r24
    31d8:	e2 50       	subi	r30, 0x02	; 2
    31da:	ff 4f       	sbci	r31, 0xFF	; 255
    31dc:	8f 4f       	sbci	r24, 0xFF	; 255
    31de:	0c 94 5a 1e 	jmp	0x3cb4	; 0x3cb4 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    31e2:	82 e0       	ldi	r24, 0x02	; 2
    31e4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31e6:	31 c0       	rjmp	.+98     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    31e8:	88 e0       	ldi	r24, 0x08	; 8
    31ea:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31ec:	2e c0       	rjmp	.+92     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    31ee:	8a e0       	ldi	r24, 0x0A	; 10
    31f0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31f2:	2b c0       	rjmp	.+86     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    31f4:	80 e1       	ldi	r24, 0x10	; 16
    31f6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31f8:	28 c0       	rjmp	.+80     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    31fa:	81 e0       	ldi	r24, 0x01	; 1
    31fc:	8b 83       	std	Y+3, r24	; 0x03
			break;
    31fe:	25 c0       	rjmp	.+74     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3200:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3202:	23 c0       	rjmp	.+70     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3204:	e8 81       	ld	r30, Y
    3206:	f9 81       	ldd	r31, Y+1	; 0x01
    3208:	02 80       	ldd	r0, Z+2	; 0x02
    320a:	f3 81       	ldd	r31, Z+3	; 0x03
    320c:	e0 2d       	mov	r30, r0
    320e:	6d e0       	ldi	r22, 0x0D	; 13
    3210:	ce 01       	movw	r24, r28
    3212:	19 95       	eicall
    3214:	e8 81       	ld	r30, Y
    3216:	f9 81       	ldd	r31, Y+1	; 0x01
    3218:	02 80       	ldd	r0, Z+2	; 0x02
    321a:	f3 81       	ldd	r31, Z+3	; 0x03
    321c:	e0 2d       	mov	r30, r0
    321e:	6a e0       	ldi	r22, 0x0A	; 10
    3220:	ce 01       	movw	r24, r28
    3222:	19 95       	eicall
			break;
    3224:	12 c0       	rjmp	.+36     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3226:	e8 81       	ld	r30, Y
    3228:	f9 81       	ldd	r31, Y+1	; 0x01
    322a:	02 84       	ldd	r0, Z+10	; 0x0a
    322c:	f3 85       	ldd	r31, Z+11	; 0x0b
    322e:	e0 2d       	mov	r30, r0
    3230:	ce 01       	movw	r24, r28
    3232:	19 95       	eicall
			break;
    3234:	0a c0       	rjmp	.+20     	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3236:	e8 81       	ld	r30, Y
    3238:	f9 81       	ldd	r31, Y+1	; 0x01
    323a:	00 84       	ldd	r0, Z+8	; 0x08
    323c:	f1 85       	ldd	r31, Z+9	; 0x09
    323e:	e0 2d       	mov	r30, r0
    3240:	ce 01       	movw	r24, r28
    3242:	19 95       	eicall
			break;
    3244:	02 c0       	rjmp	.+4      	; 0x324a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3246:	81 e0       	ldi	r24, 0x01	; 1
    3248:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    324a:	ce 01       	movw	r24, r28
    324c:	df 91       	pop	r29
    324e:	cf 91       	pop	r28
    3250:	08 95       	ret

00003252 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3252:	ff 92       	push	r15
    3254:	0f 93       	push	r16
    3256:	1f 93       	push	r17
    3258:	cf 93       	push	r28
    325a:	df 93       	push	r29
    325c:	cd b7       	in	r28, 0x3d	; 61
    325e:	de b7       	in	r29, 0x3e	; 62
    3260:	61 97       	sbiw	r28, 0x11	; 17
    3262:	cd bf       	out	0x3d, r28	; 61
    3264:	de bf       	out	0x3e, r29	; 62
    3266:	8c 01       	movw	r16, r24
    3268:	f6 2e       	mov	r15, r22
    326a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    326c:	f8 01       	movw	r30, r16
    326e:	42 81       	ldd	r20, Z+2	; 0x02
    3270:	40 31       	cpi	r20, 0x10	; 16
    3272:	21 f0       	breq	.+8      	; 0x327c <_ZN8emstreamlsEj+0x2a>
    3274:	48 30       	cpi	r20, 0x08	; 8
    3276:	11 f0       	breq	.+4      	; 0x327c <_ZN8emstreamlsEj+0x2a>
    3278:	42 30       	cpi	r20, 0x02	; 2
    327a:	41 f4       	brne	.+16     	; 0x328c <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    327c:	69 2f       	mov	r22, r25
    327e:	c8 01       	movw	r24, r16
    3280:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    3284:	6f 2d       	mov	r22, r15
    3286:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    328a:	0d c0       	rjmp	.+26     	; 0x32a6 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    328c:	50 e0       	ldi	r21, 0x00	; 0
    328e:	be 01       	movw	r22, r28
    3290:	6f 5f       	subi	r22, 0xFF	; 255
    3292:	7f 4f       	sbci	r23, 0xFF	; 255
    3294:	8f 2d       	mov	r24, r15
    3296:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    329a:	be 01       	movw	r22, r28
    329c:	6f 5f       	subi	r22, 0xFF	; 255
    329e:	7f 4f       	sbci	r23, 0xFF	; 255
    32a0:	c8 01       	movw	r24, r16
    32a2:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    32a6:	c8 01       	movw	r24, r16
    32a8:	61 96       	adiw	r28, 0x11	; 17
    32aa:	cd bf       	out	0x3d, r28	; 61
    32ac:	de bf       	out	0x3e, r29	; 62
    32ae:	df 91       	pop	r29
    32b0:	cf 91       	pop	r28
    32b2:	1f 91       	pop	r17
    32b4:	0f 91       	pop	r16
    32b6:	ff 90       	pop	r15
    32b8:	08 95       	ret

000032ba <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    32ba:	df 92       	push	r13
    32bc:	ef 92       	push	r14
    32be:	ff 92       	push	r15
    32c0:	0f 93       	push	r16
    32c2:	1f 93       	push	r17
    32c4:	cf 93       	push	r28
    32c6:	df 93       	push	r29
    32c8:	cd b7       	in	r28, 0x3d	; 61
    32ca:	de b7       	in	r29, 0x3e	; 62
    32cc:	a1 97       	sbiw	r28, 0x21	; 33
    32ce:	cd bf       	out	0x3d, r28	; 61
    32d0:	de bf       	out	0x3e, r29	; 62
    32d2:	8c 01       	movw	r16, r24
    32d4:	d4 2e       	mov	r13, r20
    32d6:	e5 2e       	mov	r14, r21
    32d8:	f6 2e       	mov	r15, r22
    32da:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    32dc:	f8 01       	movw	r30, r16
    32de:	22 81       	ldd	r18, Z+2	; 0x02
    32e0:	20 31       	cpi	r18, 0x10	; 16
    32e2:	21 f0       	breq	.+8      	; 0x32ec <_ZN8emstreamlsEm+0x32>
    32e4:	28 30       	cpi	r18, 0x08	; 8
    32e6:	11 f0       	breq	.+4      	; 0x32ec <_ZN8emstreamlsEm+0x32>
    32e8:	22 30       	cpi	r18, 0x02	; 2
    32ea:	71 f4       	brne	.+28     	; 0x3308 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    32ec:	69 2f       	mov	r22, r25
    32ee:	c8 01       	movw	r24, r16
    32f0:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    32f4:	6f 2d       	mov	r22, r15
    32f6:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    32fa:	6e 2d       	mov	r22, r14
    32fc:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    3300:	6d 2d       	mov	r22, r13
    3302:	0e 94 9f 19 	call	0x333e	; 0x333e <_ZN8emstreamlsEh>
    3306:	0f c0       	rjmp	.+30     	; 0x3326 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3308:	30 e0       	ldi	r19, 0x00	; 0
    330a:	ae 01       	movw	r20, r28
    330c:	4f 5f       	subi	r20, 0xFF	; 255
    330e:	5f 4f       	sbci	r21, 0xFF	; 255
    3310:	6d 2d       	mov	r22, r13
    3312:	7e 2d       	mov	r23, r14
    3314:	8f 2d       	mov	r24, r15
    3316:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    331a:	be 01       	movw	r22, r28
    331c:	6f 5f       	subi	r22, 0xFF	; 255
    331e:	7f 4f       	sbci	r23, 0xFF	; 255
    3320:	c8 01       	movw	r24, r16
    3322:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3326:	c8 01       	movw	r24, r16
    3328:	a1 96       	adiw	r28, 0x21	; 33
    332a:	cd bf       	out	0x3d, r28	; 61
    332c:	de bf       	out	0x3e, r29	; 62
    332e:	df 91       	pop	r29
    3330:	cf 91       	pop	r28
    3332:	1f 91       	pop	r17
    3334:	0f 91       	pop	r16
    3336:	ff 90       	pop	r15
    3338:	ef 90       	pop	r14
    333a:	df 90       	pop	r13
    333c:	08 95       	ret

0000333e <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    333e:	cf 92       	push	r12
    3340:	df 92       	push	r13
    3342:	ef 92       	push	r14
    3344:	ff 92       	push	r15
    3346:	0f 93       	push	r16
    3348:	1f 93       	push	r17
    334a:	cf 93       	push	r28
    334c:	df 93       	push	r29
    334e:	cd b7       	in	r28, 0x3d	; 61
    3350:	de b7       	in	r29, 0x3e	; 62
    3352:	29 97       	sbiw	r28, 0x09	; 9
    3354:	cd bf       	out	0x3d, r28	; 61
    3356:	de bf       	out	0x3e, r29	; 62
    3358:	8c 01       	movw	r16, r24
    335a:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    335c:	dc 01       	movw	r26, r24
    335e:	13 96       	adiw	r26, 0x03	; 3
    3360:	8c 91       	ld	r24, X
    3362:	13 97       	sbiw	r26, 0x03	; 3
    3364:	88 23       	and	r24, r24
    3366:	41 f0       	breq	.+16     	; 0x3378 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3368:	ed 91       	ld	r30, X+
    336a:	fc 91       	ld	r31, X
    336c:	02 80       	ldd	r0, Z+2	; 0x02
    336e:	f3 81       	ldd	r31, Z+3	; 0x03
    3370:	e0 2d       	mov	r30, r0
    3372:	c8 01       	movw	r24, r16
    3374:	19 95       	eicall
    3376:	56 c0       	rjmp	.+172    	; 0x3424 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3378:	f8 01       	movw	r30, r16
    337a:	42 81       	ldd	r20, Z+2	; 0x02
    337c:	42 30       	cpi	r20, 0x02	; 2
    337e:	19 f5       	brne	.+70     	; 0x33c6 <_ZN8emstreamlsEh+0x88>
    3380:	68 94       	set
    3382:	cc 24       	eor	r12, r12
    3384:	c3 f8       	bld	r12, 3
    3386:	d1 2c       	mov	r13, r1
    3388:	68 94       	set
    338a:	ff 24       	eor	r15, r15
    338c:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    338e:	8e 2d       	mov	r24, r14
    3390:	8f 21       	and	r24, r15
    3392:	51 f0       	breq	.+20     	; 0x33a8 <_ZN8emstreamlsEh+0x6a>
    3394:	d8 01       	movw	r26, r16
    3396:	ed 91       	ld	r30, X+
    3398:	fc 91       	ld	r31, X
    339a:	02 80       	ldd	r0, Z+2	; 0x02
    339c:	f3 81       	ldd	r31, Z+3	; 0x03
    339e:	e0 2d       	mov	r30, r0
    33a0:	61 e3       	ldi	r22, 0x31	; 49
    33a2:	c8 01       	movw	r24, r16
    33a4:	19 95       	eicall
    33a6:	09 c0       	rjmp	.+18     	; 0x33ba <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    33a8:	d8 01       	movw	r26, r16
    33aa:	ed 91       	ld	r30, X+
    33ac:	fc 91       	ld	r31, X
    33ae:	02 80       	ldd	r0, Z+2	; 0x02
    33b0:	f3 81       	ldd	r31, Z+3	; 0x03
    33b2:	e0 2d       	mov	r30, r0
    33b4:	60 e3       	ldi	r22, 0x30	; 48
    33b6:	c8 01       	movw	r24, r16
    33b8:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    33ba:	f6 94       	lsr	r15
    33bc:	b1 e0       	ldi	r27, 0x01	; 1
    33be:	cb 1a       	sub	r12, r27
    33c0:	d1 08       	sbc	r13, r1
    33c2:	29 f7       	brne	.-54     	; 0x338e <_ZN8emstreamlsEh+0x50>
    33c4:	2f c0       	rjmp	.+94     	; 0x3424 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    33c6:	40 31       	cpi	r20, 0x10	; 16
    33c8:	f9 f4       	brne	.+62     	; 0x3408 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    33ca:	62 95       	swap	r22
    33cc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    33ce:	01 90       	ld	r0, Z+
    33d0:	f0 81       	ld	r31, Z
    33d2:	e0 2d       	mov	r30, r0
    33d4:	02 80       	ldd	r0, Z+2	; 0x02
    33d6:	f3 81       	ldd	r31, Z+3	; 0x03
    33d8:	e0 2d       	mov	r30, r0
    33da:	6a 30       	cpi	r22, 0x0A	; 10
    33dc:	10 f0       	brcs	.+4      	; 0x33e2 <_ZN8emstreamlsEh+0xa4>
    33de:	69 5c       	subi	r22, 0xC9	; 201
    33e0:	01 c0       	rjmp	.+2      	; 0x33e4 <_ZN8emstreamlsEh+0xa6>
    33e2:	60 5d       	subi	r22, 0xD0	; 208
    33e4:	c8 01       	movw	r24, r16
    33e6:	19 95       	eicall
		temp_char = num & 0x0F;
    33e8:	6e 2d       	mov	r22, r14
    33ea:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    33ec:	d8 01       	movw	r26, r16
    33ee:	ed 91       	ld	r30, X+
    33f0:	fc 91       	ld	r31, X
    33f2:	02 80       	ldd	r0, Z+2	; 0x02
    33f4:	f3 81       	ldd	r31, Z+3	; 0x03
    33f6:	e0 2d       	mov	r30, r0
    33f8:	6a 30       	cpi	r22, 0x0A	; 10
    33fa:	10 f0       	brcs	.+4      	; 0x3400 <_ZN8emstreamlsEh+0xc2>
    33fc:	69 5c       	subi	r22, 0xC9	; 201
    33fe:	01 c0       	rjmp	.+2      	; 0x3402 <_ZN8emstreamlsEh+0xc4>
    3400:	60 5d       	subi	r22, 0xD0	; 208
    3402:	c8 01       	movw	r24, r16
    3404:	19 95       	eicall
    3406:	0e c0       	rjmp	.+28     	; 0x3424 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3408:	50 e0       	ldi	r21, 0x00	; 0
    340a:	be 01       	movw	r22, r28
    340c:	6f 5f       	subi	r22, 0xFF	; 255
    340e:	7f 4f       	sbci	r23, 0xFF	; 255
    3410:	8e 2d       	mov	r24, r14
    3412:	90 e0       	ldi	r25, 0x00	; 0
    3414:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3418:	be 01       	movw	r22, r28
    341a:	6f 5f       	subi	r22, 0xFF	; 255
    341c:	7f 4f       	sbci	r23, 0xFF	; 255
    341e:	c8 01       	movw	r24, r16
    3420:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3424:	c8 01       	movw	r24, r16
    3426:	29 96       	adiw	r28, 0x09	; 9
    3428:	cd bf       	out	0x3d, r28	; 61
    342a:	de bf       	out	0x3e, r29	; 62
    342c:	df 91       	pop	r29
    342e:	cf 91       	pop	r28
    3430:	1f 91       	pop	r17
    3432:	0f 91       	pop	r16
    3434:	ff 90       	pop	r15
    3436:	ef 90       	pop	r14
    3438:	df 90       	pop	r13
    343a:	cf 90       	pop	r12
    343c:	08 95       	ret

0000343e <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    343e:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3440:	50 96       	adiw	r26, 0x10	; 16
    3442:	ed 91       	ld	r30, X+
    3444:	fc 91       	ld	r31, X
    3446:	51 97       	sbiw	r26, 0x11	; 17
    3448:	80 81       	ld	r24, Z
    344a:	54 96       	adiw	r26, 0x14	; 20
    344c:	4c 91       	ld	r20, X
    344e:	54 97       	sbiw	r26, 0x14	; 20
    3450:	84 23       	and	r24, r20
    3452:	29 f0       	breq	.+10     	; 0x345e <_ZN5rs2327putcharEc+0x20>
    3454:	09 c0       	rjmp	.+18     	; 0x3468 <_ZN5rs2327putcharEc+0x2a>
    3456:	21 50       	subi	r18, 0x01	; 1
    3458:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    345a:	19 f4       	brne	.+6      	; 0x3462 <_ZN5rs2327putcharEc+0x24>
    345c:	12 c0       	rjmp	.+36     	; 0x3482 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    345e:	21 e2       	ldi	r18, 0x21	; 33
    3460:	3e e4       	ldi	r19, 0x4E	; 78
    3462:	90 81       	ld	r25, Z
    3464:	94 23       	and	r25, r20
    3466:	b9 f3       	breq	.-18     	; 0x3456 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3468:	90 81       	ld	r25, Z
    346a:	56 96       	adiw	r26, 0x16	; 22
    346c:	8c 91       	ld	r24, X
    346e:	56 97       	sbiw	r26, 0x16	; 22
    3470:	89 2b       	or	r24, r25
    3472:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3474:	1e 96       	adiw	r26, 0x0e	; 14
    3476:	ed 91       	ld	r30, X+
    3478:	fc 91       	ld	r31, X
    347a:	1f 97       	sbiw	r26, 0x0f	; 15
    347c:	60 83       	st	Z, r22
	return (true);
    347e:	81 e0       	ldi	r24, 0x01	; 1
    3480:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3482:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3484:	08 95       	ret

00003486 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3486:	cf 93       	push	r28
    3488:	df 93       	push	r29
    348a:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    348c:	c1 8d       	ldd	r28, Z+25	; 0x19
    348e:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3490:	28 81       	ld	r18, Y
    3492:	39 81       	ldd	r19, Y+1	; 0x01
    3494:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3496:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3498:	4d 91       	ld	r20, X+
    349a:	5c 91       	ld	r21, X
    349c:	24 17       	cp	r18, r20
    349e:	35 07       	cpc	r19, r21
    34a0:	e9 f3       	breq	.-6      	; 0x349c <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    34a2:	a7 89       	ldd	r26, Z+23	; 0x17
    34a4:	b0 8d       	ldd	r27, Z+24	; 0x18
    34a6:	0d 90       	ld	r0, X+
    34a8:	bc 91       	ld	r27, X
    34aa:	a0 2d       	mov	r26, r0
    34ac:	a2 0f       	add	r26, r18
    34ae:	b3 1f       	adc	r27, r19
    34b0:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    34b2:	2f 5f       	subi	r18, 0xFF	; 255
    34b4:	3f 4f       	sbci	r19, 0xFF	; 255
    34b6:	28 83       	st	Y, r18
    34b8:	39 83       	std	Y+1, r19	; 0x01
    34ba:	24 36       	cpi	r18, 0x64	; 100
    34bc:	31 05       	cpc	r19, r1
    34be:	28 f0       	brcs	.+10     	; 0x34ca <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    34c0:	01 8c       	ldd	r0, Z+25	; 0x19
    34c2:	f2 8d       	ldd	r31, Z+26	; 0x1a
    34c4:	e0 2d       	mov	r30, r0
    34c6:	10 82       	st	Z, r1
    34c8:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	df 91       	pop	r29
    34ce:	cf 91       	pop	r28
    34d0:	08 95       	ret

000034d2 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    34d2:	cf 93       	push	r28
    34d4:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    34d6:	ec 01       	movw	r28, r24
    34d8:	a9 8d       	ldd	r26, Y+25	; 0x19
    34da:	ba 8d       	ldd	r27, Y+26	; 0x1a
    34dc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    34de:	fc 8d       	ldd	r31, Y+28	; 0x1c
    34e0:	81 e0       	ldi	r24, 0x01	; 1
    34e2:	4d 91       	ld	r20, X+
    34e4:	5c 91       	ld	r21, X
    34e6:	20 81       	ld	r18, Z
    34e8:	31 81       	ldd	r19, Z+1	; 0x01
    34ea:	42 17       	cp	r20, r18
    34ec:	53 07       	cpc	r21, r19
    34ee:	09 f4       	brne	.+2      	; 0x34f2 <_ZN5rs23214check_for_charEv+0x20>
    34f0:	80 e0       	ldi	r24, 0x00	; 0
}
    34f2:	df 91       	pop	r29
    34f4:	cf 91       	pop	r28
    34f6:	08 95       	ret

000034f8 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    34f8:	dc 01       	movw	r26, r24
    34fa:	ed 91       	ld	r30, X+
    34fc:	fc 91       	ld	r31, X
    34fe:	02 80       	ldd	r0, Z+2	; 0x02
    3500:	f3 81       	ldd	r31, Z+3	; 0x03
    3502:	e0 2d       	mov	r30, r0
    3504:	6c e0       	ldi	r22, 0x0C	; 12
    3506:	19 95       	eicall
    3508:	08 95       	ret

0000350a <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    350a:	ef 92       	push	r14
    350c:	ff 92       	push	r15
    350e:	0f 93       	push	r16
    3510:	1f 93       	push	r17
    3512:	cf 93       	push	r28
    3514:	df 93       	push	r29
    3516:	ec 01       	movw	r28, r24
    3518:	7b 01       	movw	r14, r22
    351a:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    351c:	0e 94 9d 18 	call	0x313a	; 0x313a <_ZN8emstreamC1Ev>
    3520:	a8 01       	movw	r20, r16
    3522:	b7 01       	movw	r22, r14
    3524:	ce 01       	movw	r24, r28
    3526:	08 96       	adiw	r24, 0x08	; 8
    3528:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <_ZN7base232C1EjP12USART_struct>
    352c:	8f e4       	ldi	r24, 0x4F	; 79
    352e:	90 e2       	ldi	r25, 0x20	; 32
    3530:	88 83       	st	Y, r24
    3532:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3534:	00 3a       	cpi	r16, 0xA0	; 160
    3536:	88 e0       	ldi	r24, 0x08	; 8
    3538:	18 07       	cpc	r17, r24
    353a:	69 f4       	brne	.+26     	; 0x3556 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    353c:	8e e2       	ldi	r24, 0x2E	; 46
    353e:	91 e4       	ldi	r25, 0x41	; 65
    3540:	8f 8b       	std	Y+23, r24	; 0x17
    3542:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3544:	80 e2       	ldi	r24, 0x20	; 32
    3546:	91 e4       	ldi	r25, 0x41	; 65
    3548:	89 8f       	std	Y+25, r24	; 0x19
    354a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    354c:	82 e1       	ldi	r24, 0x12	; 18
    354e:	91 e4       	ldi	r25, 0x41	; 65
    3550:	8b 8f       	std	Y+27, r24	; 0x1b
    3552:	9c 8f       	std	Y+28, r25	; 0x1c
    3554:	64 c0       	rjmp	.+200    	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3556:	00 3b       	cpi	r16, 0xB0	; 176
    3558:	e8 e0       	ldi	r30, 0x08	; 8
    355a:	1e 07       	cpc	r17, r30
    355c:	69 f4       	brne	.+26     	; 0x3578 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    355e:	8c e2       	ldi	r24, 0x2C	; 44
    3560:	91 e4       	ldi	r25, 0x41	; 65
    3562:	8f 8b       	std	Y+23, r24	; 0x17
    3564:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3566:	8e e1       	ldi	r24, 0x1E	; 30
    3568:	91 e4       	ldi	r25, 0x41	; 65
    356a:	89 8f       	std	Y+25, r24	; 0x19
    356c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    356e:	80 e1       	ldi	r24, 0x10	; 16
    3570:	91 e4       	ldi	r25, 0x41	; 65
    3572:	8b 8f       	std	Y+27, r24	; 0x1b
    3574:	9c 8f       	std	Y+28, r25	; 0x1c
    3576:	53 c0       	rjmp	.+166    	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3578:	00 3a       	cpi	r16, 0xA0	; 160
    357a:	f9 e0       	ldi	r31, 0x09	; 9
    357c:	1f 07       	cpc	r17, r31
    357e:	69 f4       	brne	.+26     	; 0x359a <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3580:	8a e2       	ldi	r24, 0x2A	; 42
    3582:	91 e4       	ldi	r25, 0x41	; 65
    3584:	8f 8b       	std	Y+23, r24	; 0x17
    3586:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3588:	8c e1       	ldi	r24, 0x1C	; 28
    358a:	91 e4       	ldi	r25, 0x41	; 65
    358c:	89 8f       	std	Y+25, r24	; 0x19
    358e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3590:	8e e0       	ldi	r24, 0x0E	; 14
    3592:	91 e4       	ldi	r25, 0x41	; 65
    3594:	8b 8f       	std	Y+27, r24	; 0x1b
    3596:	9c 8f       	std	Y+28, r25	; 0x1c
    3598:	42 c0       	rjmp	.+132    	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    359a:	00 3b       	cpi	r16, 0xB0	; 176
    359c:	89 e0       	ldi	r24, 0x09	; 9
    359e:	18 07       	cpc	r17, r24
    35a0:	69 f4       	brne	.+26     	; 0x35bc <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    35a2:	88 e2       	ldi	r24, 0x28	; 40
    35a4:	91 e4       	ldi	r25, 0x41	; 65
    35a6:	8f 8b       	std	Y+23, r24	; 0x17
    35a8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    35aa:	8a e1       	ldi	r24, 0x1A	; 26
    35ac:	91 e4       	ldi	r25, 0x41	; 65
    35ae:	89 8f       	std	Y+25, r24	; 0x19
    35b0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    35b2:	8c e0       	ldi	r24, 0x0C	; 12
    35b4:	91 e4       	ldi	r25, 0x41	; 65
    35b6:	8b 8f       	std	Y+27, r24	; 0x1b
    35b8:	9c 8f       	std	Y+28, r25	; 0x1c
    35ba:	31 c0       	rjmp	.+98     	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    35bc:	00 3a       	cpi	r16, 0xA0	; 160
    35be:	ea e0       	ldi	r30, 0x0A	; 10
    35c0:	1e 07       	cpc	r17, r30
    35c2:	69 f4       	brne	.+26     	; 0x35de <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    35c4:	86 e2       	ldi	r24, 0x26	; 38
    35c6:	91 e4       	ldi	r25, 0x41	; 65
    35c8:	8f 8b       	std	Y+23, r24	; 0x17
    35ca:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    35cc:	88 e1       	ldi	r24, 0x18	; 24
    35ce:	91 e4       	ldi	r25, 0x41	; 65
    35d0:	89 8f       	std	Y+25, r24	; 0x19
    35d2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    35d4:	8a e0       	ldi	r24, 0x0A	; 10
    35d6:	91 e4       	ldi	r25, 0x41	; 65
    35d8:	8b 8f       	std	Y+27, r24	; 0x1b
    35da:	9c 8f       	std	Y+28, r25	; 0x1c
    35dc:	20 c0       	rjmp	.+64     	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    35de:	00 3b       	cpi	r16, 0xB0	; 176
    35e0:	fa e0       	ldi	r31, 0x0A	; 10
    35e2:	1f 07       	cpc	r17, r31
    35e4:	69 f4       	brne	.+26     	; 0x3600 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    35e6:	84 e2       	ldi	r24, 0x24	; 36
    35e8:	91 e4       	ldi	r25, 0x41	; 65
    35ea:	8f 8b       	std	Y+23, r24	; 0x17
    35ec:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    35ee:	86 e1       	ldi	r24, 0x16	; 22
    35f0:	91 e4       	ldi	r25, 0x41	; 65
    35f2:	89 8f       	std	Y+25, r24	; 0x19
    35f4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    35f6:	88 e0       	ldi	r24, 0x08	; 8
    35f8:	91 e4       	ldi	r25, 0x41	; 65
    35fa:	8b 8f       	std	Y+27, r24	; 0x1b
    35fc:	9c 8f       	std	Y+28, r25	; 0x1c
    35fe:	0f c0       	rjmp	.+30     	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    3600:	00 3a       	cpi	r16, 0xA0	; 160
    3602:	1b 40       	sbci	r17, 0x0B	; 11
    3604:	61 f4       	brne	.+24     	; 0x361e <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3606:	82 e2       	ldi	r24, 0x22	; 34
    3608:	91 e4       	ldi	r25, 0x41	; 65
    360a:	8f 8b       	std	Y+23, r24	; 0x17
    360c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    360e:	84 e1       	ldi	r24, 0x14	; 20
    3610:	91 e4       	ldi	r25, 0x41	; 65
    3612:	89 8f       	std	Y+25, r24	; 0x19
    3614:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    3616:	86 e0       	ldi	r24, 0x06	; 6
    3618:	91 e4       	ldi	r25, 0x41	; 65
    361a:	8b 8f       	std	Y+27, r24	; 0x1b
    361c:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    361e:	0f 89       	ldd	r16, Y+23	; 0x17
    3620:	18 8d       	ldd	r17, Y+24	; 0x18
    3622:	84 e6       	ldi	r24, 0x64	; 100
    3624:	90 e0       	ldi	r25, 0x00	; 0
    3626:	0e 94 e0 17 	call	0x2fc0	; 0x2fc0 <_Znaj>
    362a:	f8 01       	movw	r30, r16
    362c:	80 83       	st	Z, r24
    362e:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3630:	e9 8d       	ldd	r30, Y+25	; 0x19
    3632:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3634:	10 82       	st	Z, r1
    3636:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3638:	eb 8d       	ldd	r30, Y+27	; 0x1b
    363a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    363c:	10 82       	st	Z, r1
    363e:	11 82       	std	Z+1, r1	; 0x01
}
    3640:	df 91       	pop	r29
    3642:	cf 91       	pop	r28
    3644:	1f 91       	pop	r17
    3646:	0f 91       	pop	r16
    3648:	ff 90       	pop	r15
    364a:	ef 90       	pop	r14
    364c:	08 95       	ret

0000364e <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    364e:	1f 92       	push	r1
    3650:	0f 92       	push	r0
    3652:	0f b6       	in	r0, 0x3f	; 63
    3654:	0f 92       	push	r0
    3656:	11 24       	eor	r1, r1
    3658:	0b b6       	in	r0, 0x3b	; 59
    365a:	0f 92       	push	r0
    365c:	2f 93       	push	r18
    365e:	3f 93       	push	r19
    3660:	8f 93       	push	r24
    3662:	9f 93       	push	r25
    3664:	ef 93       	push	r30
    3666:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3668:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    366c:	e0 91 2e 41 	lds	r30, 0x412E	; 0x80412e <rcvC0_buffer>
    3670:	f0 91 2f 41 	lds	r31, 0x412F	; 0x80412f <rcvC0_buffer+0x1>
    3674:	80 91 12 41 	lds	r24, 0x4112	; 0x804112 <rcvC0_write_index>
    3678:	90 91 13 41 	lds	r25, 0x4113	; 0x804113 <rcvC0_write_index+0x1>
    367c:	e8 0f       	add	r30, r24
    367e:	f9 1f       	adc	r31, r25
    3680:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3682:	80 91 12 41 	lds	r24, 0x4112	; 0x804112 <rcvC0_write_index>
    3686:	90 91 13 41 	lds	r25, 0x4113	; 0x804113 <rcvC0_write_index+0x1>
    368a:	01 96       	adiw	r24, 0x01	; 1
    368c:	84 36       	cpi	r24, 0x64	; 100
    368e:	91 05       	cpc	r25, r1
    3690:	60 f4       	brcc	.+24     	; 0x36aa <__vector_25+0x5c>
    3692:	80 93 12 41 	sts	0x4112, r24	; 0x804112 <rcvC0_write_index>
    3696:	90 93 13 41 	sts	0x4113, r25	; 0x804113 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    369a:	20 91 20 41 	lds	r18, 0x4120	; 0x804120 <rcvC0_read_index>
    369e:	30 91 21 41 	lds	r19, 0x4121	; 0x804121 <rcvC0_read_index+0x1>
    36a2:	82 17       	cp	r24, r18
    36a4:	93 07       	cpc	r25, r19
    36a6:	f1 f4       	brne	.+60     	; 0x36e4 <__vector_25+0x96>
    36a8:	0c c0       	rjmp	.+24     	; 0x36c2 <__vector_25+0x74>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    36aa:	10 92 12 41 	sts	0x4112, r1	; 0x804112 <rcvC0_write_index>
    36ae:	10 92 13 41 	sts	0x4113, r1	; 0x804113 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    36b2:	80 91 20 41 	lds	r24, 0x4120	; 0x804120 <rcvC0_read_index>
    36b6:	90 91 21 41 	lds	r25, 0x4121	; 0x804121 <rcvC0_read_index+0x1>
    36ba:	18 16       	cp	r1, r24
    36bc:	19 06       	cpc	r1, r25
    36be:	91 f4       	brne	.+36     	; 0x36e4 <__vector_25+0x96>
    36c0:	0e c0       	rjmp	.+28     	; 0x36de <__vector_25+0x90>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    36c2:	01 96       	adiw	r24, 0x01	; 1
    36c4:	84 36       	cpi	r24, 0x64	; 100
    36c6:	91 05       	cpc	r25, r1
    36c8:	28 f4       	brcc	.+10     	; 0x36d4 <__vector_25+0x86>
    36ca:	80 93 20 41 	sts	0x4120, r24	; 0x804120 <rcvC0_read_index>
    36ce:	90 93 21 41 	sts	0x4121, r25	; 0x804121 <rcvC0_read_index+0x1>
    36d2:	08 c0       	rjmp	.+16     	; 0x36e4 <__vector_25+0x96>
			rcvC0_read_index = 0;
    36d4:	10 92 20 41 	sts	0x4120, r1	; 0x804120 <rcvC0_read_index>
    36d8:	10 92 21 41 	sts	0x4121, r1	; 0x804121 <rcvC0_read_index+0x1>
}
    36dc:	03 c0       	rjmp	.+6      	; 0x36e4 <__vector_25+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    36de:	81 e0       	ldi	r24, 0x01	; 1
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	f3 cf       	rjmp	.-26     	; 0x36ca <__vector_25+0x7c>
			rcvC0_read_index = 0;
}
    36e4:	ff 91       	pop	r31
    36e6:	ef 91       	pop	r30
    36e8:	9f 91       	pop	r25
    36ea:	8f 91       	pop	r24
    36ec:	3f 91       	pop	r19
    36ee:	2f 91       	pop	r18
    36f0:	0f 90       	pop	r0
    36f2:	0b be       	out	0x3b, r0	; 59
    36f4:	0f 90       	pop	r0
    36f6:	0f be       	out	0x3f, r0	; 63
    36f8:	0f 90       	pop	r0
    36fa:	1f 90       	pop	r1
    36fc:	18 95       	reti

000036fe <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    36fe:	1f 92       	push	r1
    3700:	0f 92       	push	r0
    3702:	0f b6       	in	r0, 0x3f	; 63
    3704:	0f 92       	push	r0
    3706:	11 24       	eor	r1, r1
    3708:	0b b6       	in	r0, 0x3b	; 59
    370a:	0f 92       	push	r0
    370c:	2f 93       	push	r18
    370e:	3f 93       	push	r19
    3710:	8f 93       	push	r24
    3712:	9f 93       	push	r25
    3714:	ef 93       	push	r30
    3716:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3718:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    371c:	e0 91 2c 41 	lds	r30, 0x412C	; 0x80412c <rcvC1_buffer>
    3720:	f0 91 2d 41 	lds	r31, 0x412D	; 0x80412d <rcvC1_buffer+0x1>
    3724:	80 91 10 41 	lds	r24, 0x4110	; 0x804110 <rcvC1_write_index>
    3728:	90 91 11 41 	lds	r25, 0x4111	; 0x804111 <rcvC1_write_index+0x1>
    372c:	e8 0f       	add	r30, r24
    372e:	f9 1f       	adc	r31, r25
    3730:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3732:	80 91 10 41 	lds	r24, 0x4110	; 0x804110 <rcvC1_write_index>
    3736:	90 91 11 41 	lds	r25, 0x4111	; 0x804111 <rcvC1_write_index+0x1>
    373a:	01 96       	adiw	r24, 0x01	; 1
    373c:	84 36       	cpi	r24, 0x64	; 100
    373e:	91 05       	cpc	r25, r1
    3740:	60 f4       	brcc	.+24     	; 0x375a <__vector_28+0x5c>
    3742:	80 93 10 41 	sts	0x4110, r24	; 0x804110 <rcvC1_write_index>
    3746:	90 93 11 41 	sts	0x4111, r25	; 0x804111 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    374a:	20 91 1e 41 	lds	r18, 0x411E	; 0x80411e <rcvC1_read_index>
    374e:	30 91 1f 41 	lds	r19, 0x411F	; 0x80411f <rcvC1_read_index+0x1>
    3752:	82 17       	cp	r24, r18
    3754:	93 07       	cpc	r25, r19
    3756:	f1 f4       	brne	.+60     	; 0x3794 <__vector_28+0x96>
    3758:	0c c0       	rjmp	.+24     	; 0x3772 <__vector_28+0x74>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    375a:	10 92 10 41 	sts	0x4110, r1	; 0x804110 <rcvC1_write_index>
    375e:	10 92 11 41 	sts	0x4111, r1	; 0x804111 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3762:	80 91 1e 41 	lds	r24, 0x411E	; 0x80411e <rcvC1_read_index>
    3766:	90 91 1f 41 	lds	r25, 0x411F	; 0x80411f <rcvC1_read_index+0x1>
    376a:	18 16       	cp	r1, r24
    376c:	19 06       	cpc	r1, r25
    376e:	91 f4       	brne	.+36     	; 0x3794 <__vector_28+0x96>
    3770:	0e c0       	rjmp	.+28     	; 0x378e <__vector_28+0x90>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3772:	01 96       	adiw	r24, 0x01	; 1
    3774:	84 36       	cpi	r24, 0x64	; 100
    3776:	91 05       	cpc	r25, r1
    3778:	28 f4       	brcc	.+10     	; 0x3784 <__vector_28+0x86>
    377a:	80 93 1e 41 	sts	0x411E, r24	; 0x80411e <rcvC1_read_index>
    377e:	90 93 1f 41 	sts	0x411F, r25	; 0x80411f <rcvC1_read_index+0x1>
    3782:	08 c0       	rjmp	.+16     	; 0x3794 <__vector_28+0x96>
	rcvC1_read_index = 0;
    3784:	10 92 1e 41 	sts	0x411E, r1	; 0x80411e <rcvC1_read_index>
    3788:	10 92 1f 41 	sts	0x411F, r1	; 0x80411f <rcvC1_read_index+0x1>
}
    378c:	03 c0       	rjmp	.+6      	; 0x3794 <__vector_28+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    378e:	81 e0       	ldi	r24, 0x01	; 1
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	f3 cf       	rjmp	.-26     	; 0x377a <__vector_28+0x7c>
	rcvC1_read_index = 0;
}
    3794:	ff 91       	pop	r31
    3796:	ef 91       	pop	r30
    3798:	9f 91       	pop	r25
    379a:	8f 91       	pop	r24
    379c:	3f 91       	pop	r19
    379e:	2f 91       	pop	r18
    37a0:	0f 90       	pop	r0
    37a2:	0b be       	out	0x3b, r0	; 59
    37a4:	0f 90       	pop	r0
    37a6:	0f be       	out	0x3f, r0	; 63
    37a8:	0f 90       	pop	r0
    37aa:	1f 90       	pop	r1
    37ac:	18 95       	reti

000037ae <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    37ae:	1f 92       	push	r1
    37b0:	0f 92       	push	r0
    37b2:	0f b6       	in	r0, 0x3f	; 63
    37b4:	0f 92       	push	r0
    37b6:	11 24       	eor	r1, r1
    37b8:	0b b6       	in	r0, 0x3b	; 59
    37ba:	0f 92       	push	r0
    37bc:	2f 93       	push	r18
    37be:	3f 93       	push	r19
    37c0:	8f 93       	push	r24
    37c2:	9f 93       	push	r25
    37c4:	ef 93       	push	r30
    37c6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvD0_write_index] = USARTD0.DATA;
    37c8:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    37cc:	e0 91 2a 41 	lds	r30, 0x412A	; 0x80412a <rcvD0_buffer>
    37d0:	f0 91 2b 41 	lds	r31, 0x412B	; 0x80412b <rcvD0_buffer+0x1>
    37d4:	80 91 0e 41 	lds	r24, 0x410E	; 0x80410e <rcvD0_write_index>
    37d8:	90 91 0f 41 	lds	r25, 0x410F	; 0x80410f <rcvD0_write_index+0x1>
    37dc:	e8 0f       	add	r30, r24
    37de:	f9 1f       	adc	r31, r25
    37e0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    37e2:	80 91 0e 41 	lds	r24, 0x410E	; 0x80410e <rcvD0_write_index>
    37e6:	90 91 0f 41 	lds	r25, 0x410F	; 0x80410f <rcvD0_write_index+0x1>
    37ea:	01 96       	adiw	r24, 0x01	; 1
    37ec:	84 36       	cpi	r24, 0x64	; 100
    37ee:	91 05       	cpc	r25, r1
    37f0:	60 f4       	brcc	.+24     	; 0x380a <__vector_88+0x5c>
    37f2:	80 93 0e 41 	sts	0x410E, r24	; 0x80410e <rcvD0_write_index>
    37f6:	90 93 0f 41 	sts	0x410F, r25	; 0x80410f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    37fa:	20 91 1c 41 	lds	r18, 0x411C	; 0x80411c <rcvD0_read_index>
    37fe:	30 91 1d 41 	lds	r19, 0x411D	; 0x80411d <rcvD0_read_index+0x1>
    3802:	82 17       	cp	r24, r18
    3804:	93 07       	cpc	r25, r19
    3806:	f1 f4       	brne	.+60     	; 0x3844 <__vector_88+0x96>
    3808:	0c c0       	rjmp	.+24     	; 0x3822 <__vector_88+0x74>

	rcvD0_buffer[rcvD0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    380a:	10 92 0e 41 	sts	0x410E, r1	; 0x80410e <rcvD0_write_index>
    380e:	10 92 0f 41 	sts	0x410F, r1	; 0x80410f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3812:	80 91 1c 41 	lds	r24, 0x411C	; 0x80411c <rcvD0_read_index>
    3816:	90 91 1d 41 	lds	r25, 0x411D	; 0x80411d <rcvD0_read_index+0x1>
    381a:	18 16       	cp	r1, r24
    381c:	19 06       	cpc	r1, r25
    381e:	91 f4       	brne	.+36     	; 0x3844 <__vector_88+0x96>
    3820:	0e c0       	rjmp	.+28     	; 0x383e <__vector_88+0x90>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3822:	01 96       	adiw	r24, 0x01	; 1
    3824:	84 36       	cpi	r24, 0x64	; 100
    3826:	91 05       	cpc	r25, r1
    3828:	28 f4       	brcc	.+10     	; 0x3834 <__vector_88+0x86>
    382a:	80 93 1c 41 	sts	0x411C, r24	; 0x80411c <rcvD0_read_index>
    382e:	90 93 1d 41 	sts	0x411D, r25	; 0x80411d <rcvD0_read_index+0x1>
    3832:	08 c0       	rjmp	.+16     	; 0x3844 <__vector_88+0x96>
	rcvD0_read_index = 0;
    3834:	10 92 1c 41 	sts	0x411C, r1	; 0x80411c <rcvD0_read_index>
    3838:	10 92 1d 41 	sts	0x411D, r1	; 0x80411d <rcvD0_read_index+0x1>
}
    383c:	03 c0       	rjmp	.+6      	; 0x3844 <__vector_88+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    383e:	81 e0       	ldi	r24, 0x01	; 1
    3840:	90 e0       	ldi	r25, 0x00	; 0
    3842:	f3 cf       	rjmp	.-26     	; 0x382a <__vector_88+0x7c>
	rcvD0_read_index = 0;
}
    3844:	ff 91       	pop	r31
    3846:	ef 91       	pop	r30
    3848:	9f 91       	pop	r25
    384a:	8f 91       	pop	r24
    384c:	3f 91       	pop	r19
    384e:	2f 91       	pop	r18
    3850:	0f 90       	pop	r0
    3852:	0b be       	out	0x3b, r0	; 59
    3854:	0f 90       	pop	r0
    3856:	0f be       	out	0x3f, r0	; 63
    3858:	0f 90       	pop	r0
    385a:	1f 90       	pop	r1
    385c:	18 95       	reti

0000385e <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    385e:	1f 92       	push	r1
    3860:	0f 92       	push	r0
    3862:	0f b6       	in	r0, 0x3f	; 63
    3864:	0f 92       	push	r0
    3866:	11 24       	eor	r1, r1
    3868:	0b b6       	in	r0, 0x3b	; 59
    386a:	0f 92       	push	r0
    386c:	2f 93       	push	r18
    386e:	3f 93       	push	r19
    3870:	8f 93       	push	r24
    3872:	9f 93       	push	r25
    3874:	ef 93       	push	r30
    3876:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3878:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    387c:	e0 91 28 41 	lds	r30, 0x4128	; 0x804128 <rcvD1_buffer>
    3880:	f0 91 29 41 	lds	r31, 0x4129	; 0x804129 <rcvD1_buffer+0x1>
    3884:	80 91 0c 41 	lds	r24, 0x410C	; 0x80410c <rcvD1_write_index>
    3888:	90 91 0d 41 	lds	r25, 0x410D	; 0x80410d <rcvD1_write_index+0x1>
    388c:	e8 0f       	add	r30, r24
    388e:	f9 1f       	adc	r31, r25
    3890:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3892:	80 91 0c 41 	lds	r24, 0x410C	; 0x80410c <rcvD1_write_index>
    3896:	90 91 0d 41 	lds	r25, 0x410D	; 0x80410d <rcvD1_write_index+0x1>
    389a:	01 96       	adiw	r24, 0x01	; 1
    389c:	84 36       	cpi	r24, 0x64	; 100
    389e:	91 05       	cpc	r25, r1
    38a0:	60 f4       	brcc	.+24     	; 0x38ba <__vector_91+0x5c>
    38a2:	80 93 0c 41 	sts	0x410C, r24	; 0x80410c <rcvD1_write_index>
    38a6:	90 93 0d 41 	sts	0x410D, r25	; 0x80410d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    38aa:	20 91 1a 41 	lds	r18, 0x411A	; 0x80411a <rcvD1_read_index>
    38ae:	30 91 1b 41 	lds	r19, 0x411B	; 0x80411b <rcvD1_read_index+0x1>
    38b2:	82 17       	cp	r24, r18
    38b4:	93 07       	cpc	r25, r19
    38b6:	f1 f4       	brne	.+60     	; 0x38f4 <__vector_91+0x96>
    38b8:	0c c0       	rjmp	.+24     	; 0x38d2 <__vector_91+0x74>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    38ba:	10 92 0c 41 	sts	0x410C, r1	; 0x80410c <rcvD1_write_index>
    38be:	10 92 0d 41 	sts	0x410D, r1	; 0x80410d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    38c2:	80 91 1a 41 	lds	r24, 0x411A	; 0x80411a <rcvD1_read_index>
    38c6:	90 91 1b 41 	lds	r25, 0x411B	; 0x80411b <rcvD1_read_index+0x1>
    38ca:	18 16       	cp	r1, r24
    38cc:	19 06       	cpc	r1, r25
    38ce:	91 f4       	brne	.+36     	; 0x38f4 <__vector_91+0x96>
    38d0:	0e c0       	rjmp	.+28     	; 0x38ee <__vector_91+0x90>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    38d2:	01 96       	adiw	r24, 0x01	; 1
    38d4:	84 36       	cpi	r24, 0x64	; 100
    38d6:	91 05       	cpc	r25, r1
    38d8:	28 f4       	brcc	.+10     	; 0x38e4 <__vector_91+0x86>
    38da:	80 93 1a 41 	sts	0x411A, r24	; 0x80411a <rcvD1_read_index>
    38de:	90 93 1b 41 	sts	0x411B, r25	; 0x80411b <rcvD1_read_index+0x1>
    38e2:	08 c0       	rjmp	.+16     	; 0x38f4 <__vector_91+0x96>
	rcvD1_read_index = 0;
    38e4:	10 92 1a 41 	sts	0x411A, r1	; 0x80411a <rcvD1_read_index>
    38e8:	10 92 1b 41 	sts	0x411B, r1	; 0x80411b <rcvD1_read_index+0x1>
}
    38ec:	03 c0       	rjmp	.+6      	; 0x38f4 <__vector_91+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    38ee:	81 e0       	ldi	r24, 0x01	; 1
    38f0:	90 e0       	ldi	r25, 0x00	; 0
    38f2:	f3 cf       	rjmp	.-26     	; 0x38da <__vector_91+0x7c>
	rcvD1_read_index = 0;
}
    38f4:	ff 91       	pop	r31
    38f6:	ef 91       	pop	r30
    38f8:	9f 91       	pop	r25
    38fa:	8f 91       	pop	r24
    38fc:	3f 91       	pop	r19
    38fe:	2f 91       	pop	r18
    3900:	0f 90       	pop	r0
    3902:	0b be       	out	0x3b, r0	; 59
    3904:	0f 90       	pop	r0
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	0f 90       	pop	r0
    390a:	1f 90       	pop	r1
    390c:	18 95       	reti

0000390e <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    390e:	1f 92       	push	r1
    3910:	0f 92       	push	r0
    3912:	0f b6       	in	r0, 0x3f	; 63
    3914:	0f 92       	push	r0
    3916:	11 24       	eor	r1, r1
    3918:	0b b6       	in	r0, 0x3b	; 59
    391a:	0f 92       	push	r0
    391c:	2f 93       	push	r18
    391e:	3f 93       	push	r19
    3920:	8f 93       	push	r24
    3922:	9f 93       	push	r25
    3924:	ef 93       	push	r30
    3926:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3928:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    392c:	e0 91 26 41 	lds	r30, 0x4126	; 0x804126 <rcvE0_buffer>
    3930:	f0 91 27 41 	lds	r31, 0x4127	; 0x804127 <rcvE0_buffer+0x1>
    3934:	80 91 0a 41 	lds	r24, 0x410A	; 0x80410a <rcvE0_write_index>
    3938:	90 91 0b 41 	lds	r25, 0x410B	; 0x80410b <rcvE0_write_index+0x1>
    393c:	e8 0f       	add	r30, r24
    393e:	f9 1f       	adc	r31, r25
    3940:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3942:	80 91 0a 41 	lds	r24, 0x410A	; 0x80410a <rcvE0_write_index>
    3946:	90 91 0b 41 	lds	r25, 0x410B	; 0x80410b <rcvE0_write_index+0x1>
    394a:	01 96       	adiw	r24, 0x01	; 1
    394c:	84 36       	cpi	r24, 0x64	; 100
    394e:	91 05       	cpc	r25, r1
    3950:	60 f4       	brcc	.+24     	; 0x396a <__vector_58+0x5c>
    3952:	80 93 0a 41 	sts	0x410A, r24	; 0x80410a <rcvE0_write_index>
    3956:	90 93 0b 41 	sts	0x410B, r25	; 0x80410b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    395a:	20 91 18 41 	lds	r18, 0x4118	; 0x804118 <rcvE0_read_index>
    395e:	30 91 19 41 	lds	r19, 0x4119	; 0x804119 <rcvE0_read_index+0x1>
    3962:	82 17       	cp	r24, r18
    3964:	93 07       	cpc	r25, r19
    3966:	f1 f4       	brne	.+60     	; 0x39a4 <__vector_58+0x96>
    3968:	0c c0       	rjmp	.+24     	; 0x3982 <__vector_58+0x74>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    396a:	10 92 0a 41 	sts	0x410A, r1	; 0x80410a <rcvE0_write_index>
    396e:	10 92 0b 41 	sts	0x410B, r1	; 0x80410b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3972:	80 91 18 41 	lds	r24, 0x4118	; 0x804118 <rcvE0_read_index>
    3976:	90 91 19 41 	lds	r25, 0x4119	; 0x804119 <rcvE0_read_index+0x1>
    397a:	18 16       	cp	r1, r24
    397c:	19 06       	cpc	r1, r25
    397e:	91 f4       	brne	.+36     	; 0x39a4 <__vector_58+0x96>
    3980:	0e c0       	rjmp	.+28     	; 0x399e <__vector_58+0x90>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3982:	01 96       	adiw	r24, 0x01	; 1
    3984:	84 36       	cpi	r24, 0x64	; 100
    3986:	91 05       	cpc	r25, r1
    3988:	28 f4       	brcc	.+10     	; 0x3994 <__vector_58+0x86>
    398a:	80 93 18 41 	sts	0x4118, r24	; 0x804118 <rcvE0_read_index>
    398e:	90 93 19 41 	sts	0x4119, r25	; 0x804119 <rcvE0_read_index+0x1>
    3992:	08 c0       	rjmp	.+16     	; 0x39a4 <__vector_58+0x96>
	rcvE0_read_index = 0;
    3994:	10 92 18 41 	sts	0x4118, r1	; 0x804118 <rcvE0_read_index>
    3998:	10 92 19 41 	sts	0x4119, r1	; 0x804119 <rcvE0_read_index+0x1>
}
    399c:	03 c0       	rjmp	.+6      	; 0x39a4 <__vector_58+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    399e:	81 e0       	ldi	r24, 0x01	; 1
    39a0:	90 e0       	ldi	r25, 0x00	; 0
    39a2:	f3 cf       	rjmp	.-26     	; 0x398a <__vector_58+0x7c>
	rcvE0_read_index = 0;
}
    39a4:	ff 91       	pop	r31
    39a6:	ef 91       	pop	r30
    39a8:	9f 91       	pop	r25
    39aa:	8f 91       	pop	r24
    39ac:	3f 91       	pop	r19
    39ae:	2f 91       	pop	r18
    39b0:	0f 90       	pop	r0
    39b2:	0b be       	out	0x3b, r0	; 59
    39b4:	0f 90       	pop	r0
    39b6:	0f be       	out	0x3f, r0	; 63
    39b8:	0f 90       	pop	r0
    39ba:	1f 90       	pop	r1
    39bc:	18 95       	reti

000039be <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    39be:	1f 92       	push	r1
    39c0:	0f 92       	push	r0
    39c2:	0f b6       	in	r0, 0x3f	; 63
    39c4:	0f 92       	push	r0
    39c6:	11 24       	eor	r1, r1
    39c8:	0b b6       	in	r0, 0x3b	; 59
    39ca:	0f 92       	push	r0
    39cc:	2f 93       	push	r18
    39ce:	3f 93       	push	r19
    39d0:	8f 93       	push	r24
    39d2:	9f 93       	push	r25
    39d4:	ef 93       	push	r30
    39d6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    39d8:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    39dc:	e0 91 24 41 	lds	r30, 0x4124	; 0x804124 <rcvE1_buffer>
    39e0:	f0 91 25 41 	lds	r31, 0x4125	; 0x804125 <rcvE1_buffer+0x1>
    39e4:	80 91 08 41 	lds	r24, 0x4108	; 0x804108 <rcvE1_write_index>
    39e8:	90 91 09 41 	lds	r25, 0x4109	; 0x804109 <rcvE1_write_index+0x1>
    39ec:	e8 0f       	add	r30, r24
    39ee:	f9 1f       	adc	r31, r25
    39f0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    39f2:	80 91 08 41 	lds	r24, 0x4108	; 0x804108 <rcvE1_write_index>
    39f6:	90 91 09 41 	lds	r25, 0x4109	; 0x804109 <rcvE1_write_index+0x1>
    39fa:	01 96       	adiw	r24, 0x01	; 1
    39fc:	84 36       	cpi	r24, 0x64	; 100
    39fe:	91 05       	cpc	r25, r1
    3a00:	60 f4       	brcc	.+24     	; 0x3a1a <__vector_61+0x5c>
    3a02:	80 93 08 41 	sts	0x4108, r24	; 0x804108 <rcvE1_write_index>
    3a06:	90 93 09 41 	sts	0x4109, r25	; 0x804109 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3a0a:	20 91 16 41 	lds	r18, 0x4116	; 0x804116 <rcvE1_read_index>
    3a0e:	30 91 17 41 	lds	r19, 0x4117	; 0x804117 <rcvE1_read_index+0x1>
    3a12:	82 17       	cp	r24, r18
    3a14:	93 07       	cpc	r25, r19
    3a16:	f1 f4       	brne	.+60     	; 0x3a54 <__vector_61+0x96>
    3a18:	0c c0       	rjmp	.+24     	; 0x3a32 <__vector_61+0x74>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3a1a:	10 92 08 41 	sts	0x4108, r1	; 0x804108 <rcvE1_write_index>
    3a1e:	10 92 09 41 	sts	0x4109, r1	; 0x804109 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3a22:	80 91 16 41 	lds	r24, 0x4116	; 0x804116 <rcvE1_read_index>
    3a26:	90 91 17 41 	lds	r25, 0x4117	; 0x804117 <rcvE1_read_index+0x1>
    3a2a:	18 16       	cp	r1, r24
    3a2c:	19 06       	cpc	r1, r25
    3a2e:	91 f4       	brne	.+36     	; 0x3a54 <__vector_61+0x96>
    3a30:	0e c0       	rjmp	.+28     	; 0x3a4e <__vector_61+0x90>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3a32:	01 96       	adiw	r24, 0x01	; 1
    3a34:	84 36       	cpi	r24, 0x64	; 100
    3a36:	91 05       	cpc	r25, r1
    3a38:	28 f4       	brcc	.+10     	; 0x3a44 <__vector_61+0x86>
    3a3a:	80 93 16 41 	sts	0x4116, r24	; 0x804116 <rcvE1_read_index>
    3a3e:	90 93 17 41 	sts	0x4117, r25	; 0x804117 <rcvE1_read_index+0x1>
    3a42:	08 c0       	rjmp	.+16     	; 0x3a54 <__vector_61+0x96>
	rcvE1_read_index = 0;
    3a44:	10 92 16 41 	sts	0x4116, r1	; 0x804116 <rcvE1_read_index>
    3a48:	10 92 17 41 	sts	0x4117, r1	; 0x804117 <rcvE1_read_index+0x1>
}
    3a4c:	03 c0       	rjmp	.+6      	; 0x3a54 <__vector_61+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3a4e:	81 e0       	ldi	r24, 0x01	; 1
    3a50:	90 e0       	ldi	r25, 0x00	; 0
    3a52:	f3 cf       	rjmp	.-26     	; 0x3a3a <__vector_61+0x7c>
	rcvE1_read_index = 0;
}
    3a54:	ff 91       	pop	r31
    3a56:	ef 91       	pop	r30
    3a58:	9f 91       	pop	r25
    3a5a:	8f 91       	pop	r24
    3a5c:	3f 91       	pop	r19
    3a5e:	2f 91       	pop	r18
    3a60:	0f 90       	pop	r0
    3a62:	0b be       	out	0x3b, r0	; 59
    3a64:	0f 90       	pop	r0
    3a66:	0f be       	out	0x3f, r0	; 63
    3a68:	0f 90       	pop	r0
    3a6a:	1f 90       	pop	r1
    3a6c:	18 95       	reti

00003a6e <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    3a6e:	1f 92       	push	r1
    3a70:	0f 92       	push	r0
    3a72:	0f b6       	in	r0, 0x3f	; 63
    3a74:	0f 92       	push	r0
    3a76:	11 24       	eor	r1, r1
    3a78:	0b b6       	in	r0, 0x3b	; 59
    3a7a:	0f 92       	push	r0
    3a7c:	2f 93       	push	r18
    3a7e:	3f 93       	push	r19
    3a80:	8f 93       	push	r24
    3a82:	9f 93       	push	r25
    3a84:	ef 93       	push	r30
    3a86:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    3a88:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    3a8c:	e0 91 22 41 	lds	r30, 0x4122	; 0x804122 <rcvF0_buffer>
    3a90:	f0 91 23 41 	lds	r31, 0x4123	; 0x804123 <rcvF0_buffer+0x1>
    3a94:	80 91 06 41 	lds	r24, 0x4106	; 0x804106 <rcvF0_write_index>
    3a98:	90 91 07 41 	lds	r25, 0x4107	; 0x804107 <rcvF0_write_index+0x1>
    3a9c:	e8 0f       	add	r30, r24
    3a9e:	f9 1f       	adc	r31, r25
    3aa0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3aa2:	80 91 06 41 	lds	r24, 0x4106	; 0x804106 <rcvF0_write_index>
    3aa6:	90 91 07 41 	lds	r25, 0x4107	; 0x804107 <rcvF0_write_index+0x1>
    3aaa:	01 96       	adiw	r24, 0x01	; 1
    3aac:	84 36       	cpi	r24, 0x64	; 100
    3aae:	91 05       	cpc	r25, r1
    3ab0:	60 f4       	brcc	.+24     	; 0x3aca <__vector_119+0x5c>
    3ab2:	80 93 06 41 	sts	0x4106, r24	; 0x804106 <rcvF0_write_index>
    3ab6:	90 93 07 41 	sts	0x4107, r25	; 0x804107 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3aba:	20 91 14 41 	lds	r18, 0x4114	; 0x804114 <rcvF0_read_index>
    3abe:	30 91 15 41 	lds	r19, 0x4115	; 0x804115 <rcvF0_read_index+0x1>
    3ac2:	82 17       	cp	r24, r18
    3ac4:	93 07       	cpc	r25, r19
    3ac6:	f1 f4       	brne	.+60     	; 0x3b04 <__vector_119+0x96>
    3ac8:	0c c0       	rjmp	.+24     	; 0x3ae2 <__vector_119+0x74>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    3aca:	10 92 06 41 	sts	0x4106, r1	; 0x804106 <rcvF0_write_index>
    3ace:	10 92 07 41 	sts	0x4107, r1	; 0x804107 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3ad2:	80 91 14 41 	lds	r24, 0x4114	; 0x804114 <rcvF0_read_index>
    3ad6:	90 91 15 41 	lds	r25, 0x4115	; 0x804115 <rcvF0_read_index+0x1>
    3ada:	18 16       	cp	r1, r24
    3adc:	19 06       	cpc	r1, r25
    3ade:	91 f4       	brne	.+36     	; 0x3b04 <__vector_119+0x96>
    3ae0:	0e c0       	rjmp	.+28     	; 0x3afe <__vector_119+0x90>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3ae2:	01 96       	adiw	r24, 0x01	; 1
    3ae4:	84 36       	cpi	r24, 0x64	; 100
    3ae6:	91 05       	cpc	r25, r1
    3ae8:	28 f4       	brcc	.+10     	; 0x3af4 <__vector_119+0x86>
    3aea:	80 93 14 41 	sts	0x4114, r24	; 0x804114 <rcvF0_read_index>
    3aee:	90 93 15 41 	sts	0x4115, r25	; 0x804115 <rcvF0_read_index+0x1>
    3af2:	08 c0       	rjmp	.+16     	; 0x3b04 <__vector_119+0x96>
	rcvF0_read_index = 0;
    3af4:	10 92 14 41 	sts	0x4114, r1	; 0x804114 <rcvF0_read_index>
    3af8:	10 92 15 41 	sts	0x4115, r1	; 0x804115 <rcvF0_read_index+0x1>
}
    3afc:	03 c0       	rjmp	.+6      	; 0x3b04 <__vector_119+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3afe:	81 e0       	ldi	r24, 0x01	; 1
    3b00:	90 e0       	ldi	r25, 0x00	; 0
    3b02:	f3 cf       	rjmp	.-26     	; 0x3aea <__vector_119+0x7c>
	rcvF0_read_index = 0;
}
    3b04:	ff 91       	pop	r31
    3b06:	ef 91       	pop	r30
    3b08:	9f 91       	pop	r25
    3b0a:	8f 91       	pop	r24
    3b0c:	3f 91       	pop	r19
    3b0e:	2f 91       	pop	r18
    3b10:	0f 90       	pop	r0
    3b12:	0b be       	out	0x3b, r0	; 59
    3b14:	0f 90       	pop	r0
    3b16:	0f be       	out	0x3f, r0	; 63
    3b18:	0f 90       	pop	r0
    3b1a:	1f 90       	pop	r1
    3b1c:	18 95       	reti

00003b1e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3b1e:	0f 93       	push	r16
    3b20:	1f 93       	push	r17
    3b22:	cf 93       	push	r28
    3b24:	df 93       	push	r29
    3b26:	cd b7       	in	r28, 0x3d	; 61
    3b28:	de b7       	in	r29, 0x3e	; 62
    3b2a:	6d 97       	sbiw	r28, 0x1d	; 29
    3b2c:	cd bf       	out	0x3d, r28	; 61
    3b2e:	de bf       	out	0x3e, r29	; 62
	cli();
    3b30:	f8 94       	cli
	// Configure the system clock to use internal oscillator at 32 MHz
	config_SYSCLOCK();
    3b32:	0e 94 d7 07 	call	0xfae	; 0xfae <_Z15config_SYSCLOCKv>
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3b36:	9d ef       	ldi	r25, 0xFD	; 253
    3b38:	88 ed       	ldi	r24, 0xD8	; 216
    3b3a:	08 b6       	in	r0, 0x38	; 56
    3b3c:	18 be       	out	0x38, r1	; 56
    3b3e:	84 bf       	out	0x34, r24	; 52
    3b40:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3b44:	08 be       	out	0x38, r0	; 56

	IR_flg = new shared_data<bool>;
    3b46:	81 e0       	ldi	r24, 0x01	; 1
    3b48:	90 e0       	ldi	r25, 0x00	; 0
    3b4a:	0e 94 dd 17 	call	0x2fba	; 0x2fba <_Znwj>
    3b4e:	80 93 30 41 	sts	0x4130, r24	; 0x804130 <IR_flg>
    3b52:	90 93 31 41 	sts	0x4131, r25	; 0x804131 <IR_flg+0x1>
	
	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3b56:	40 ea       	ldi	r20, 0xA0	; 160
    3b58:	5a e0       	ldi	r21, 0x0A	; 10
    3b5a:	60 e0       	ldi	r22, 0x00	; 0
    3b5c:	70 e0       	ldi	r23, 0x00	; 0
    3b5e:	ce 01       	movw	r24, r28
    3b60:	01 96       	adiw	r24, 0x01	; 1
    3b62:	0e 94 85 1a 	call	0x350a	; 0x350a <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3b66:	67 e0       	ldi	r22, 0x07	; 7
    3b68:	ce 01       	movw	r24, r28
    3b6a:	01 96       	adiw	r24, 0x01	; 1
    3b6c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    3b70:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3b72:	6b e5       	ldi	r22, 0x5B	; 91
    3b74:	70 e2       	ldi	r23, 0x20	; 32
    3b76:	0e 94 ab 18 	call	0x3156	; 0x3156 <_ZN8emstream4putsEPKc>
    3b7a:	66 e0       	ldi	r22, 0x06	; 6
    3b7c:	c8 01       	movw	r24, r16
    3b7e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
    3b82:	66 e0       	ldi	r22, 0x06	; 6
    3b84:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3b88:	82 e1       	ldi	r24, 0x12	; 18
    3b8a:	90 e0       	ldi	r25, 0x00	; 0
    3b8c:	0e 94 dd 17 	call	0x2fba	; 0x2fba <_Znwj>
    3b90:	8e 01       	movw	r16, r28
    3b92:	0f 5f       	subi	r16, 0xFF	; 255
    3b94:	1f 4f       	sbci	r17, 0xFF	; 255
    3b96:	24 e0       	ldi	r18, 0x04	; 4
    3b98:	31 e0       	ldi	r19, 0x01	; 1
    3b9a:	40 e0       	ldi	r20, 0x00	; 0
    3b9c:	6a e7       	ldi	r22, 0x7A	; 122
    3b9e:	70 e2       	ldi	r23, 0x20	; 32
    3ba0:	0e 94 52 05 	call	0xaa4	; 0xaa4 <_ZN9task_userC1EPKchjP8emstream>
	// The LED blinking task is also low priority and is used to test the timing accuracy
	// of the task transitions.
	
	//new task_LED ("LED BLINKER", task_priority (1), 260, &ser_dev);
	
	new task_EdgeSense ("Edge Sensor", task_priority (1), 260, &ser_dev);
    3ba4:	82 e1       	ldi	r24, 0x12	; 18
    3ba6:	90 e0       	ldi	r25, 0x00	; 0
    3ba8:	0e 94 dd 17 	call	0x2fba	; 0x2fba <_Znwj>
    3bac:	24 e0       	ldi	r18, 0x04	; 4
    3bae:	31 e0       	ldi	r19, 0x01	; 1
    3bb0:	41 e0       	ldi	r20, 0x01	; 1
    3bb2:	62 e8       	ldi	r22, 0x82	; 130
    3bb4:	70 e2       	ldi	r23, 0x20	; 32
    3bb6:	0e 94 78 04 	call	0x8f0	; 0x8f0 <_ZN14task_EdgeSenseC1EPKchjP8emstream>
	
	new task_MOTOR ("Motor Test", task_priority (2), 260, &ser_dev);
    3bba:	83 e1       	ldi	r24, 0x13	; 19
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
    3bbe:	0e 94 dd 17 	call	0x2fba	; 0x2fba <_Znwj>
    3bc2:	24 e0       	ldi	r18, 0x04	; 4
    3bc4:	31 e0       	ldi	r19, 0x01	; 1
    3bc6:	42 e0       	ldi	r20, 0x02	; 2
    3bc8:	6e e8       	ldi	r22, 0x8E	; 142
    3bca:	70 e2       	ldi	r23, 0x20	; 32
    3bcc:	0e 94 42 05 	call	0xa84	; 0xa84 <_ZN10task_MOTORC1EPKchjP8emstream>
	
	// Enable high - low level interrupts and enable global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3bd0:	87 e0       	ldi	r24, 0x07	; 7
    3bd2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3bd6:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3bd8:	0e 94 ef 0e 	call	0x1dde	; 0x1dde <vTaskStartScheduler>
    3bdc:	80 e0       	ldi	r24, 0x00	; 0
    3bde:	90 e0       	ldi	r25, 0x00	; 0
    3be0:	6d 96       	adiw	r28, 0x1d	; 29
    3be2:	cd bf       	out	0x3d, r28	; 61
    3be4:	de bf       	out	0x3e, r29	; 62
    3be6:	df 91       	pop	r29
    3be8:	cf 91       	pop	r28
    3bea:	1f 91       	pop	r17
    3bec:	0f 91       	pop	r16
    3bee:	08 95       	ret

00003bf0 <_GLOBAL__sub_I_print_ser_queue>:
    3bf0:	0f 93       	push	r16
    3bf2:	1f 93       	push	r17
#include "task_LED.h"                      // Header for user interface task
#include "task_MOTOR.h"
#include "task_EdgeSense.h"


frt_text_queue print_ser_queue (32, NULL, 10);
    3bf4:	0a e0       	ldi	r16, 0x0A	; 10
    3bf6:	10 e0       	ldi	r17, 0x00	; 0
    3bf8:	20 e0       	ldi	r18, 0x00	; 0
    3bfa:	30 e0       	ldi	r19, 0x00	; 0
    3bfc:	40 e0       	ldi	r20, 0x00	; 0
    3bfe:	50 e0       	ldi	r21, 0x00	; 0
    3c00:	60 e2       	ldi	r22, 0x20	; 32
    3c02:	70 e0       	ldi	r23, 0x00	; 0
    3c04:	82 e3       	ldi	r24, 0x32	; 50
    3c06:	91 e4       	ldi	r25, 0x41	; 65
    3c08:	0e 94 49 16 	call	0x2c92	; 0x2c92 <_ZN14frt_text_queueC1EjP8emstreamm>
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3c0c:	1f 91       	pop	r17
    3c0e:	0f 91       	pop	r16
    3c10:	08 95       	ret

00003c12 <__mulsi3>:
    3c12:	db 01       	movw	r26, r22
    3c14:	8f 93       	push	r24
    3c16:	9f 93       	push	r25
    3c18:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__muluhisi3>
    3c1c:	bf 91       	pop	r27
    3c1e:	af 91       	pop	r26
    3c20:	a2 9f       	mul	r26, r18
    3c22:	80 0d       	add	r24, r0
    3c24:	91 1d       	adc	r25, r1
    3c26:	a3 9f       	mul	r26, r19
    3c28:	90 0d       	add	r25, r0
    3c2a:	b2 9f       	mul	r27, r18
    3c2c:	90 0d       	add	r25, r0
    3c2e:	11 24       	eor	r1, r1
    3c30:	08 95       	ret

00003c32 <__udivmodsi4>:
    3c32:	a1 e2       	ldi	r26, 0x21	; 33
    3c34:	1a 2e       	mov	r1, r26
    3c36:	aa 1b       	sub	r26, r26
    3c38:	bb 1b       	sub	r27, r27
    3c3a:	fd 01       	movw	r30, r26
    3c3c:	0d c0       	rjmp	.+26     	; 0x3c58 <__udivmodsi4_ep>

00003c3e <__udivmodsi4_loop>:
    3c3e:	aa 1f       	adc	r26, r26
    3c40:	bb 1f       	adc	r27, r27
    3c42:	ee 1f       	adc	r30, r30
    3c44:	ff 1f       	adc	r31, r31
    3c46:	a2 17       	cp	r26, r18
    3c48:	b3 07       	cpc	r27, r19
    3c4a:	e4 07       	cpc	r30, r20
    3c4c:	f5 07       	cpc	r31, r21
    3c4e:	20 f0       	brcs	.+8      	; 0x3c58 <__udivmodsi4_ep>
    3c50:	a2 1b       	sub	r26, r18
    3c52:	b3 0b       	sbc	r27, r19
    3c54:	e4 0b       	sbc	r30, r20
    3c56:	f5 0b       	sbc	r31, r21

00003c58 <__udivmodsi4_ep>:
    3c58:	66 1f       	adc	r22, r22
    3c5a:	77 1f       	adc	r23, r23
    3c5c:	88 1f       	adc	r24, r24
    3c5e:	99 1f       	adc	r25, r25
    3c60:	1a 94       	dec	r1
    3c62:	69 f7       	brne	.-38     	; 0x3c3e <__udivmodsi4_loop>
    3c64:	60 95       	com	r22
    3c66:	70 95       	com	r23
    3c68:	80 95       	com	r24
    3c6a:	90 95       	com	r25
    3c6c:	9b 01       	movw	r18, r22
    3c6e:	ac 01       	movw	r20, r24
    3c70:	bd 01       	movw	r22, r26
    3c72:	cf 01       	movw	r24, r30
    3c74:	08 95       	ret

00003c76 <__divmodsi4>:
    3c76:	05 2e       	mov	r0, r21
    3c78:	97 fb       	bst	r25, 7
    3c7a:	1e f4       	brtc	.+6      	; 0x3c82 <__divmodsi4+0xc>
    3c7c:	00 94       	com	r0
    3c7e:	0e 94 52 1e 	call	0x3ca4	; 0x3ca4 <__negsi2>
    3c82:	57 fd       	sbrc	r21, 7
    3c84:	07 d0       	rcall	.+14     	; 0x3c94 <__divmodsi4_neg2>
    3c86:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__udivmodsi4>
    3c8a:	07 fc       	sbrc	r0, 7
    3c8c:	03 d0       	rcall	.+6      	; 0x3c94 <__divmodsi4_neg2>
    3c8e:	4e f4       	brtc	.+18     	; 0x3ca2 <__divmodsi4_exit>
    3c90:	0c 94 52 1e 	jmp	0x3ca4	; 0x3ca4 <__negsi2>

00003c94 <__divmodsi4_neg2>:
    3c94:	50 95       	com	r21
    3c96:	40 95       	com	r20
    3c98:	30 95       	com	r19
    3c9a:	21 95       	neg	r18
    3c9c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c9e:	4f 4f       	sbci	r20, 0xFF	; 255
    3ca0:	5f 4f       	sbci	r21, 0xFF	; 255

00003ca2 <__divmodsi4_exit>:
    3ca2:	08 95       	ret

00003ca4 <__negsi2>:
    3ca4:	90 95       	com	r25
    3ca6:	80 95       	com	r24
    3ca8:	70 95       	com	r23
    3caa:	61 95       	neg	r22
    3cac:	7f 4f       	sbci	r23, 0xFF	; 255
    3cae:	8f 4f       	sbci	r24, 0xFF	; 255
    3cb0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cb2:	08 95       	ret

00003cb4 <__tablejump2__>:
    3cb4:	ee 0f       	add	r30, r30
    3cb6:	ff 1f       	adc	r31, r31
    3cb8:	88 1f       	adc	r24, r24
    3cba:	8b bf       	out	0x3b, r24	; 59
    3cbc:	07 90       	elpm	r0, Z+
    3cbe:	f6 91       	elpm	r31, Z
    3cc0:	e0 2d       	mov	r30, r0
    3cc2:	19 94       	eijmp

00003cc4 <__umulhisi3>:
    3cc4:	a2 9f       	mul	r26, r18
    3cc6:	b0 01       	movw	r22, r0
    3cc8:	b3 9f       	mul	r27, r19
    3cca:	c0 01       	movw	r24, r0
    3ccc:	a3 9f       	mul	r26, r19
    3cce:	70 0d       	add	r23, r0
    3cd0:	81 1d       	adc	r24, r1
    3cd2:	11 24       	eor	r1, r1
    3cd4:	91 1d       	adc	r25, r1
    3cd6:	b2 9f       	mul	r27, r18
    3cd8:	70 0d       	add	r23, r0
    3cda:	81 1d       	adc	r24, r1
    3cdc:	11 24       	eor	r1, r1
    3cde:	91 1d       	adc	r25, r1
    3ce0:	08 95       	ret

00003ce2 <__muluhisi3>:
    3ce2:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <__umulhisi3>
    3ce6:	a5 9f       	mul	r26, r21
    3ce8:	90 0d       	add	r25, r0
    3cea:	b4 9f       	mul	r27, r20
    3cec:	90 0d       	add	r25, r0
    3cee:	a4 9f       	mul	r26, r20
    3cf0:	80 0d       	add	r24, r0
    3cf2:	91 1d       	adc	r25, r1
    3cf4:	11 24       	eor	r1, r1
    3cf6:	08 95       	ret

00003cf8 <memcpy>:
    3cf8:	fb 01       	movw	r30, r22
    3cfa:	dc 01       	movw	r26, r24
    3cfc:	02 c0       	rjmp	.+4      	; 0x3d02 <memcpy+0xa>
    3cfe:	01 90       	ld	r0, Z+
    3d00:	0d 92       	st	X+, r0
    3d02:	41 50       	subi	r20, 0x01	; 1
    3d04:	50 40       	sbci	r21, 0x00	; 0
    3d06:	d8 f7       	brcc	.-10     	; 0x3cfe <memcpy+0x6>
    3d08:	08 95       	ret

00003d0a <memset>:
    3d0a:	dc 01       	movw	r26, r24
    3d0c:	01 c0       	rjmp	.+2      	; 0x3d10 <memset+0x6>
    3d0e:	6d 93       	st	X+, r22
    3d10:	41 50       	subi	r20, 0x01	; 1
    3d12:	50 40       	sbci	r21, 0x00	; 0
    3d14:	e0 f7       	brcc	.-8      	; 0x3d0e <memset+0x4>
    3d16:	08 95       	ret

00003d18 <strncpy>:
    3d18:	fb 01       	movw	r30, r22
    3d1a:	dc 01       	movw	r26, r24
    3d1c:	41 50       	subi	r20, 0x01	; 1
    3d1e:	50 40       	sbci	r21, 0x00	; 0
    3d20:	48 f0       	brcs	.+18     	; 0x3d34 <strncpy+0x1c>
    3d22:	01 90       	ld	r0, Z+
    3d24:	0d 92       	st	X+, r0
    3d26:	00 20       	and	r0, r0
    3d28:	c9 f7       	brne	.-14     	; 0x3d1c <strncpy+0x4>
    3d2a:	01 c0       	rjmp	.+2      	; 0x3d2e <strncpy+0x16>
    3d2c:	1d 92       	st	X+, r1
    3d2e:	41 50       	subi	r20, 0x01	; 1
    3d30:	50 40       	sbci	r21, 0x00	; 0
    3d32:	e0 f7       	brcc	.-8      	; 0x3d2c <strncpy+0x14>
    3d34:	08 95       	ret

00003d36 <ultoa>:
    3d36:	25 32       	cpi	r18, 0x25	; 37
    3d38:	31 05       	cpc	r19, r1
    3d3a:	20 f4       	brcc	.+8      	; 0x3d44 <ultoa+0xe>
    3d3c:	22 30       	cpi	r18, 0x02	; 2
    3d3e:	10 f0       	brcs	.+4      	; 0x3d44 <ultoa+0xe>
    3d40:	0c 94 a6 1e 	jmp	0x3d4c	; 0x3d4c <__ultoa_ncheck>
    3d44:	fa 01       	movw	r30, r20
    3d46:	10 82       	st	Z, r1
    3d48:	ca 01       	movw	r24, r20
    3d4a:	08 95       	ret

00003d4c <__ultoa_ncheck>:
    3d4c:	bb 27       	eor	r27, r27

00003d4e <__ultoa_common>:
    3d4e:	fa 01       	movw	r30, r20
    3d50:	a6 2f       	mov	r26, r22
    3d52:	62 17       	cp	r22, r18
    3d54:	71 05       	cpc	r23, r1
    3d56:	81 05       	cpc	r24, r1
    3d58:	91 05       	cpc	r25, r1
    3d5a:	33 0b       	sbc	r19, r19
    3d5c:	30 fb       	bst	r19, 0
    3d5e:	66 f0       	brts	.+24     	; 0x3d78 <__ultoa_common+0x2a>
    3d60:	aa 27       	eor	r26, r26
    3d62:	66 0f       	add	r22, r22
    3d64:	77 1f       	adc	r23, r23
    3d66:	88 1f       	adc	r24, r24
    3d68:	99 1f       	adc	r25, r25
    3d6a:	aa 1f       	adc	r26, r26
    3d6c:	a2 17       	cp	r26, r18
    3d6e:	10 f0       	brcs	.+4      	; 0x3d74 <__ultoa_common+0x26>
    3d70:	a2 1b       	sub	r26, r18
    3d72:	63 95       	inc	r22
    3d74:	38 50       	subi	r19, 0x08	; 8
    3d76:	a9 f7       	brne	.-22     	; 0x3d62 <__ultoa_common+0x14>
    3d78:	a0 5d       	subi	r26, 0xD0	; 208
    3d7a:	aa 33       	cpi	r26, 0x3A	; 58
    3d7c:	08 f0       	brcs	.+2      	; 0x3d80 <__ultoa_common+0x32>
    3d7e:	a9 5d       	subi	r26, 0xD9	; 217
    3d80:	a1 93       	st	Z+, r26
    3d82:	36 f7       	brtc	.-52     	; 0x3d50 <__ultoa_common+0x2>
    3d84:	b1 11       	cpse	r27, r1
    3d86:	b1 93       	st	Z+, r27
    3d88:	10 82       	st	Z, r1
    3d8a:	ca 01       	movw	r24, r20
    3d8c:	0c 94 ed 1e 	jmp	0x3dda	; 0x3dda <strrev>

00003d90 <utoa>:
    3d90:	45 32       	cpi	r20, 0x25	; 37
    3d92:	51 05       	cpc	r21, r1
    3d94:	20 f4       	brcc	.+8      	; 0x3d9e <utoa+0xe>
    3d96:	42 30       	cpi	r20, 0x02	; 2
    3d98:	10 f0       	brcs	.+4      	; 0x3d9e <utoa+0xe>
    3d9a:	0c 94 d3 1e 	jmp	0x3da6	; 0x3da6 <__utoa_ncheck>
    3d9e:	fb 01       	movw	r30, r22
    3da0:	10 82       	st	Z, r1
    3da2:	cb 01       	movw	r24, r22
    3da4:	08 95       	ret

00003da6 <__utoa_ncheck>:
    3da6:	bb 27       	eor	r27, r27

00003da8 <__utoa_common>:
    3da8:	fb 01       	movw	r30, r22
    3daa:	55 27       	eor	r21, r21
    3dac:	aa 27       	eor	r26, r26
    3dae:	88 0f       	add	r24, r24
    3db0:	99 1f       	adc	r25, r25
    3db2:	aa 1f       	adc	r26, r26
    3db4:	a4 17       	cp	r26, r20
    3db6:	10 f0       	brcs	.+4      	; 0x3dbc <__utoa_common+0x14>
    3db8:	a4 1b       	sub	r26, r20
    3dba:	83 95       	inc	r24
    3dbc:	50 51       	subi	r21, 0x10	; 16
    3dbe:	b9 f7       	brne	.-18     	; 0x3dae <__utoa_common+0x6>
    3dc0:	a0 5d       	subi	r26, 0xD0	; 208
    3dc2:	aa 33       	cpi	r26, 0x3A	; 58
    3dc4:	08 f0       	brcs	.+2      	; 0x3dc8 <__utoa_common+0x20>
    3dc6:	a9 5d       	subi	r26, 0xD9	; 217
    3dc8:	a1 93       	st	Z+, r26
    3dca:	00 97       	sbiw	r24, 0x00	; 0
    3dcc:	79 f7       	brne	.-34     	; 0x3dac <__utoa_common+0x4>
    3dce:	b1 11       	cpse	r27, r1
    3dd0:	b1 93       	st	Z+, r27
    3dd2:	11 92       	st	Z+, r1
    3dd4:	cb 01       	movw	r24, r22
    3dd6:	0c 94 ed 1e 	jmp	0x3dda	; 0x3dda <strrev>

00003dda <strrev>:
    3dda:	dc 01       	movw	r26, r24
    3ddc:	fc 01       	movw	r30, r24
    3dde:	67 2f       	mov	r22, r23
    3de0:	71 91       	ld	r23, Z+
    3de2:	77 23       	and	r23, r23
    3de4:	e1 f7       	brne	.-8      	; 0x3dde <strrev+0x4>
    3de6:	32 97       	sbiw	r30, 0x02	; 2
    3de8:	04 c0       	rjmp	.+8      	; 0x3df2 <strrev+0x18>
    3dea:	7c 91       	ld	r23, X
    3dec:	6d 93       	st	X+, r22
    3dee:	70 83       	st	Z, r23
    3df0:	62 91       	ld	r22, -Z
    3df2:	ae 17       	cp	r26, r30
    3df4:	bf 07       	cpc	r27, r31
    3df6:	c8 f3       	brcs	.-14     	; 0x3dea <strrev+0x10>
    3df8:	08 95       	ret

00003dfa <_exit>:
    3dfa:	f8 94       	cli

00003dfc <__stop_program>:
    3dfc:	ff cf       	rjmp	.-2      	; 0x3dfc <__stop_program>
